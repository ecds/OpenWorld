"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS({
  "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module2) {
    (function(global, factory) {
      typeof exports == "object" && typeof module2 < "u" ? module2.exports = factory() : typeof define == "function" && define.amd ? define(factory) : (global = typeof globalThis < "u" ? globalThis : global || self, global.maplibregl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, maplibregl2;
      function define2(_, chunk) {
        if (!shared)
          shared = chunk;
        else if (!worker)
          worker = chunk;
        else {
          var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);", sharedChunk = {};
          shared(sharedChunk), maplibregl2 = chunk(sharedChunk), typeof window < "u" && (maplibregl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
        }
      }
      define2(["exports"], function(t) {
        "use strict";
        var e = r;
        function r(t2, e2, r2, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        function n(t2, r2, n2, i2) {
          let a2 = new e(t2, r2, n2, i2);
          return function(t3) {
            return a2.solve(t3);
          };
        }
        r.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e2) {
          if (e2 === void 0 && (e2 = 1e-6), t2 < 0)
            return 0;
          if (t2 > 1)
            return 1;
          for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2)
              return r2;
            var a2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(a2) < 1e-6)
              break;
            r2 -= i2 / a2;
          }
          var s2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
            t2 > i2 ? s2 = r2 : o2 = r2, r2 = 0.5 * (o2 - s2) + s2;
          return r2;
        }, solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        } };
        let i = n(0.25, 0.1, 0.25, 1);
        function a(t2, e2, r2) {
          return Math.min(r2, Math.max(e2, t2));
        }
        function s(t2, e2, r2) {
          let n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
          return i2 === e2 ? r2 : i2;
        }
        function o(t2, ...e2) {
          for (let r2 of e2)
            for (let e3 in r2)
              t2[e3] = r2[e3];
          return t2;
        }
        let l = 1;
        function u(t2, e2) {
          t2.forEach((t3) => {
            e2[t3] && (e2[t3] = e2[t3].bind(e2));
          });
        }
        function c(t2, e2, r2) {
          let n2 = {};
          for (let i2 in t2)
            n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
          return n2;
        }
        function h(t2, e2, r2) {
          let n2 = {};
          for (let i2 in t2)
            e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
          return n2;
        }
        function p(t2) {
          return Array.isArray(t2) ? t2.map(p) : typeof t2 == "object" && t2 ? c(t2, p) : t2;
        }
        let f = {};
        function d(t2) {
          f[t2] || (typeof console < "u" && console.warn(t2), f[t2] = !0);
        }
        function y(t2, e2, r2) {
          return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
        }
        function m(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, a2 = t2.length, s2 = a2 - 1; i2 < a2; s2 = i2++)
            r2 = t2[i2], n2 = t2[s2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        function g() {
          return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
        }
        function x(t2) {
          let e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
            let a2 = n2 || i2;
            return e2[r2] = !a2 || a2.toLowerCase(), "";
          }), e2["max-age"]) {
            let t3 = parseInt(e2["max-age"], 10);
            isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
          }
          return e2;
        }
        let v, b, w = null;
        function _(t2) {
          if (w == null) {
            let e2 = t2.navigator ? t2.navigator.userAgent : null;
            w = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return w;
        }
        function A(t2) {
          return typeof ImageBitmap < "u" && t2 instanceof ImageBitmap;
        }
        let k = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t2) {
          let e2 = requestAnimationFrame(t2);
          return { cancel: () => cancelAnimationFrame(e2) };
        }, getImageData(t2, e2 = 0) {
          let r2 = window.document.createElement("canvas"), n2 = r2.getContext("2d");
          if (!n2)
            throw new Error("failed to create canvas 2d context");
          return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
        }, resolveURL: (t2) => (v || (v = document.createElement("a")), v.href = t2, v.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (b == null && (b = matchMedia("(prefers-reduced-motion: reduce)")), b.matches);
        } };
        var S = I;
        function I(t2, e2) {
          this.x = t2, this.y = e2;
        }
        I.prototype = { clone: function() {
          return new I(this.x, this.y);
        }, add: function(t2) {
          return this.clone()._add(t2);
        }, sub: function(t2) {
          return this.clone()._sub(t2);
        }, multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        }, mult: function(t2) {
          return this.clone()._mult(t2);
        }, div: function(t2) {
          return this.clone()._div(t2);
        }, rotate: function(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround: function(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult: function(t2) {
          return this.clone()._matMult(t2);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr: function(t2) {
          var e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep: function(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult: function(t2) {
          var e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        }, _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate: function(t2) {
          var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround: function(t2, e2) {
          var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, I.convert = function(t2) {
          return t2 instanceof I ? t2 : Array.isArray(t2) ? new I(t2[0], t2[1]) : t2;
        };
        let M = { MAX_PARALLEL_IMAGE_REQUESTS: 16, REGISTERED_PROTOCOLS: {} }, z = "mapbox-tiles", B, C, P = 500, V = 50;
        function E() {
          typeof caches > "u" || B || (B = caches.open(z));
        }
        let F = 1 / 0, T = { supported: !1, testSupport: function(t2) {
          !$ && D && (R ? O(t2) : L = t2);
        } }, L, D, $ = !1, R = !1;
        function O(t2) {
          let e2 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e2);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, D), t2.isContextLost())
              return;
            T.supported = !0;
          } catch {
          }
          t2.deleteTexture(e2), $ = !0;
        }
        typeof document < "u" && (D = document.createElement("img"), D.onload = function() {
          L && O(L), L = null, R = !0;
        }, D.onerror = function() {
          $ = !0, L = null;
        }, D.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        let U = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        typeof Object.freeze == "function" && Object.freeze(U);
        class q extends Error {
          constructor(t2, e2, r2, n2) {
            super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
          }
        }
        let j = g() ? () => self.worker && self.worker.referrer : () => (window.location.protocol === "blob:" ? window.parent : window).location.href;
        function N(t2, e2) {
          let r2 = new AbortController(), n2 = new Request(t2.url, { method: t2.method || "GET", body: t2.body, credentials: t2.credentials, headers: t2.headers, referrer: j(), signal: r2.signal }), i2 = !1, a2 = !1;
          return t2.type === "json" && n2.headers.set("Accept", "application/json"), ((r3, s2, o2) => {
            if (a2)
              return;
            let l2 = Date.now();
            fetch(n2).then((r4) => r4.ok ? ((r5, s3, o3) => {
              (t2.type === "arrayBuffer" ? r5.arrayBuffer() : t2.type === "json" ? r5.json() : r5.text()).then((t3) => {
                a2 || (s3 && o3 && function(t4, e3, r6) {
                  if (E(), !B)
                    return;
                  let n3 = { status: e3.status, statusText: e3.statusText, headers: new Headers() };
                  e3.headers.forEach((t5, e4) => n3.headers.set(e4, t5));
                  let i3 = x(e3.headers.get("Cache-Control") || "");
                  i3["no-store"] || (i3["max-age"] && n3.headers.set("Expires", new Date(r6 + 1e3 * i3["max-age"]).toUTCString()), new Date(n3.headers.get("Expires")).getTime() - r6 < 42e4 || function(t5, e4) {
                    if (C === void 0)
                      try {
                        new Response(new ReadableStream()), C = !0;
                      } catch {
                        C = !1;
                      }
                    C ? e4(t5.body) : t5.blob().then(e4);
                  }(e3, (e4) => {
                    let r7 = new Response(e4, n3);
                    E(), B && B.then((e5) => e5.put(function(t5) {
                      let e6 = t5.indexOf("?");
                      return e6 < 0 ? t5 : t5.slice(0, e6);
                    }(t4.url), r7)).catch((t5) => d(t5.message));
                  }));
                }(n2, s3, o3), i2 = !0, e2(null, t3, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
              }).catch((t3) => {
                a2 || e2(new Error(t3.message));
              });
            })(r4, null, l2) : r4.blob().then((n3) => e2(new q(r4.status, r4.statusText, t2.url, n3)))).catch((t3) => {
              t3.code !== 20 && e2(new Error(t3.message));
            });
          })(), { cancel: () => {
            a2 = !0, i2 || r2.abort();
          } };
        }
        let Z = function(t2, e2) {
          if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
            if (g() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t2, e2);
            if (!g()) {
              let r3 = t2.url.substring(0, t2.url.indexOf("://"));
              return (M.REGISTERED_PROTOCOLS[r3] || N)(t2, e2);
            }
          }
          if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(j()) && !/^\w+:/.test(r2))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
              return N(t2, e2);
            if (g() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t2, e2, void 0, !0);
          }
          var r2;
          return function(t3, e3) {
            let r3 = new XMLHttpRequest();
            r3.open(t3.method || "GET", t3.url, !0), t3.type === "arrayBuffer" && (r3.responseType = "arraybuffer");
            for (let e4 in t3.headers)
              r3.setRequestHeader(e4, t3.headers[e4]);
            return t3.type === "json" && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = t3.credentials === "include", r3.onerror = () => {
              e3(new Error(r3.statusText));
            }, r3.onload = () => {
              if ((r3.status >= 200 && r3.status < 300 || r3.status === 0) && r3.response !== null) {
                let n2 = r3.response;
                if (t3.type === "json")
                  try {
                    n2 = JSON.parse(r3.response);
                  } catch (t4) {
                    return e3(t4);
                  }
                e3(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
              } else {
                let n2 = new Blob([r3.response], { type: r3.getResponseHeader("Content-Type") });
                e3(new q(r3.status, r3.statusText, t3.url, n2));
              }
            }, r3.send(t3.body), { cancel: () => r3.abort() };
          }(t2, e2);
        }, K = function(t2, e2) {
          return Z(o(t2, { type: "arrayBuffer" }), e2);
        };
        function G(t2) {
          let e2 = window.document.createElement("a");
          return e2.href = t2, e2.protocol === window.document.location.protocol && e2.host === window.document.location.host;
        }
        let J = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=", X, Y;
        X = [], Y = 0;
        let H = function(t2, e2) {
          if (T.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), Y >= M.MAX_PARALLEL_IMAGE_REQUESTS) {
            let r3 = { requestParameters: t2, callback: e2, cancelled: !1, cancel() {
              this.cancelled = !0;
            } };
            return X.push(r3), r3;
          }
          Y++;
          let r2 = !1, n2 = () => {
            if (!r2)
              for (r2 = !0, Y--; X.length && Y < M.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                let t3 = X.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
                n3 || (t3.cancel = H(e3, r3).cancel);
              }
          }, i2 = K(t2, (t3, r3, i3, a2) => {
            n2(), t3 ? e2(t3) : r3 && function(t4, e3) {
              typeof createImageBitmap == "function" ? function(t5, e4) {
                let r4 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                createImageBitmap(r4).then((t6) => {
                  e4(null, t6);
                }).catch((t6) => {
                  e4(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                });
              }(t4, e3) : function(t5, e4) {
                let r4 = new Image();
                r4.onload = () => {
                  e4(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, window.requestAnimationFrame(() => {
                    r4.src = J;
                  });
                }, r4.onerror = () => e4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                let n3 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                r4.src = t5.byteLength ? URL.createObjectURL(n3) : J;
              }(t4, e3);
            }(r3, (t4, r4) => {
              t4 != null ? e2(t4) : r4 != null && e2(null, r4, { cacheControl: i3, expires: a2 });
            });
          });
          return { cancel: () => {
            i2.cancel(), n2();
          } };
        };
        function W(t2, e2, r2) {
          r2[t2] && r2[t2].indexOf(e2) !== -1 || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
        }
        function Q(t2, e2, r2) {
          if (r2 && r2[t2]) {
            let n2 = r2[t2].indexOf(e2);
            n2 !== -1 && r2[t2].splice(n2, 1);
          }
        }
        class tt {
          constructor(t2, e2 = {}) {
            o(this, e2), this.type = t2;
          }
        }
        class et extends tt {
          constructor(t2, e2 = {}) {
            super("error", o({ error: t2 }, e2));
          }
        }
        class rt {
          on(t2, e2) {
            return this._listeners = this._listeners || {}, W(t2, e2, this._listeners), this;
          }
          off(t2, e2) {
            return Q(t2, e2, this._listeners), Q(t2, e2, this._oneTimeListeners), this;
          }
          once(t2, e2) {
            return this._oneTimeListeners = this._oneTimeListeners || {}, W(t2, e2, this._oneTimeListeners), this;
          }
          fire(t2, e2) {
            typeof t2 == "string" && (t2 = new tt(t2, e2 || {}));
            let r2 = t2.type;
            if (this.listens(r2)) {
              t2.target = this;
              let e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
              for (let r3 of e3)
                r3.call(this, t2);
              let n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
              for (let e4 of n2)
                Q(r2, e4, this._oneTimeListeners), e4.call(this, t2);
              let i2 = this._eventedParent;
              i2 && (o(t2, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
            } else
              t2 instanceof et && console.error(t2.error);
            return this;
          }
          listens(t2) {
            return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
          }
          setEventedParent(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          }
        }
        var nt = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 }, elevationOffset: { type: "number", default: 450 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        class it {
          constructor(t2, e2, r2, n2) {
            this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), e2 != null && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function at(t2) {
          let e2 = t2.value;
          return e2 ? [new it(t2.key, e2, "constants have been deprecated as of v8")] : [];
        }
        function st(t2, ...e2) {
          for (let r2 of e2)
            for (let e3 in r2)
              t2[e3] = r2[e3];
          return t2;
        }
        function ot(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function lt(t2) {
          if (Array.isArray(t2))
            return t2.map(lt);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            let e2 = {};
            for (let r2 in t2)
              e2[r2] = lt(t2[r2]);
            return e2;
          }
          return ot(t2);
        }
        class ut extends Error {
          constructor(t2, e2) {
            super(e2), this.message = e2, this.key = t2;
          }
        }
        class ct {
          constructor(t2, e2 = []) {
            this.parent = t2, this.bindings = {};
            for (let [t3, r2] of e2)
              this.bindings[t3] = r2;
          }
          concat(t2) {
            return new ct(this, t2);
          }
          get(t2) {
            if (this.bindings[t2])
              return this.bindings[t2];
            if (this.parent)
              return this.parent.get(t2);
            throw new Error(`${t2} not found in scope.`);
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        let ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "padding" }, wt = { kind: "resolvedImage" };
        function _t(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function At(t2) {
          if (t2.kind === "array") {
            let e2 = At(t2.itemType);
            return typeof t2.N == "number" ? `array<${e2}, ${t2.N}>` : t2.itemType.kind === "value" ? "array" : `array<${e2}>`;
          }
          return t2.kind;
        }
        let kt = [ht, pt, ft, dt, yt, vt, mt, _t(gt), bt, wt];
        function St(t2, e2) {
          if (e2.kind === "error")
            return null;
          if (t2.kind === "array") {
            if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !St(t2.itemType, e2.itemType)) && (typeof t2.N != "number" || t2.N === e2.N))
              return null;
          } else {
            if (t2.kind === e2.kind)
              return null;
            if (t2.kind === "value") {
              for (let t3 of kt)
                if (!St(t3, e2))
                  return null;
            }
          }
          return `Expected ${At(t2)} but found ${At(e2)} instead.`;
        }
        function It(t2, e2) {
          return e2.some((e3) => e3.kind === t2.kind);
        }
        function Mt(t2, e2) {
          return e2.some((e3) => e3 === "null" ? t2 === null : e3 === "array" ? Array.isArray(t2) : e3 === "object" ? t2 && !Array.isArray(t2) && typeof t2 == "object" : e3 === typeof t2);
        }
        var zt, Bt = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function Ct(t2) {
          return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
        }
        function Pt(t2) {
          return Ct(t2[t2.length - 1] === "%" ? parseFloat(t2) / 100 * 255 : parseInt(t2));
        }
        function Vt(t2) {
          return (e2 = t2[t2.length - 1] === "%" ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e2 > 1 ? 1 : e2;
          var e2;
        }
        function Et(t2, e2, r2) {
          return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e2 - t2) * r2 * 6 : 2 * r2 < 1 ? e2 : 3 * r2 < 2 ? t2 + (e2 - t2) * (2 / 3 - r2) * 6 : t2;
        }
        try {
          zt = {}.parseCSSColor = function(t2) {
            var e2, r2 = t2.replace(/ /g, "").toLowerCase();
            if (r2 in Bt)
              return Bt[r2].slice();
            if (r2[0] === "#")
              return r2.length === 4 ? (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 4095 ? [(3840 & e2) >> 4 | (3840 & e2) >> 8, 240 & e2 | (240 & e2) >> 4, 15 & e2 | (15 & e2) << 4, 1] : null : r2.length === 7 && (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 16777215 ? [(16711680 & e2) >> 16, (65280 & e2) >> 8, 255 & e2, 1] : null;
            var n2 = r2.indexOf("("), i2 = r2.indexOf(")");
            if (n2 !== -1 && i2 + 1 === r2.length) {
              var a2 = r2.substr(0, n2), s2 = r2.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
              switch (a2) {
                case "rgba":
                  if (s2.length !== 4)
                    return null;
                  o2 = Vt(s2.pop());
                case "rgb":
                  return s2.length !== 3 ? null : [Pt(s2[0]), Pt(s2[1]), Pt(s2[2]), o2];
                case "hsla":
                  if (s2.length !== 4)
                    return null;
                  o2 = Vt(s2.pop());
                case "hsl":
                  if (s2.length !== 3)
                    return null;
                  var l2 = (parseFloat(s2[0]) % 360 + 360) % 360 / 360, u2 = Vt(s2[1]), c2 = Vt(s2[2]), h2 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h2;
                  return [Ct(255 * Et(p2, h2, l2 + 1 / 3)), Ct(255 * Et(p2, h2, l2)), Ct(255 * Et(p2, h2, l2 - 1 / 3)), o2];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch {
        }
        class Ft {
          constructor(t2, e2, r2, n2 = 1) {
            this.r = t2, this.g = e2, this.b = r2, this.a = n2;
          }
          static parse(t2) {
            if (!t2)
              return;
            if (t2 instanceof Ft)
              return t2;
            if (typeof t2 != "string")
              return;
            let e2 = zt(t2);
            return e2 ? new Ft(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
          }
          toString() {
            let [t2, e2, r2, n2] = this.toArray();
            return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n2})`;
          }
          toArray() {
            let { r: t2, g: e2, b: r2, a: n2 } = this;
            return n2 === 0 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
          }
        }
        Ft.black = new Ft(0, 0, 0, 1), Ft.white = new Ft(1, 1, 1, 1), Ft.transparent = new Ft(0, 0, 0, 0), Ft.red = new Ft(1, 0, 0, 1);
        class Tt {
          constructor(t2, e2, r2) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e2) {
            return this.collator.compare(t2, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Lt {
          constructor(t2, e2, r2, n2, i2) {
            this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
          }
        }
        class Dt {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new Dt([new Lt(t2, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t2) => t2.text.length !== 0 || t2.image && t2.image.name.length !== 0);
          }
          static factory(t2) {
            return t2 instanceof Dt ? t2 : Dt.fromString(t2);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t2) => t2.text).join("");
          }
        }
        class $t {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof $t)
              return t2;
            if (typeof t2 == "number")
              return new $t([t2, t2, t2, t2]);
            if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
              for (let e2 of t2)
                if (typeof e2 != "number")
                  return;
              switch (t2.length) {
                case 1:
                  t2 = [t2[0], t2[0], t2[0], t2[0]];
                  break;
                case 2:
                  t2 = [t2[0], t2[1], t2[0], t2[1]];
                  break;
                case 3:
                  t2 = [t2[0], t2[1], t2[2], t2[1]];
              }
              return new $t(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        class Rt {
          constructor(t2) {
            this.name = t2.name, this.available = t2.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t2) {
            return t2 ? new Rt({ name: t2, available: !1 }) : null;
          }
        }
        function Ot(t2, e2, r2, n2) {
          return typeof t2 == "number" && t2 >= 0 && t2 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r2 == "number" && r2 >= 0 && r2 <= 255 ? n2 === void 0 || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Ut(t2) {
          if (t2 === null || typeof t2 == "string" || typeof t2 == "boolean" || typeof t2 == "number" || t2 instanceof Ft || t2 instanceof Tt || t2 instanceof Dt || t2 instanceof $t || t2 instanceof Rt)
            return !0;
          if (Array.isArray(t2)) {
            for (let e2 of t2)
              if (!Ut(e2))
                return !1;
            return !0;
          }
          if (typeof t2 == "object") {
            for (let e2 in t2)
              if (!Ut(t2[e2]))
                return !1;
            return !0;
          }
          return !1;
        }
        function qt(t2) {
          if (t2 === null)
            return ht;
          if (typeof t2 == "string")
            return ft;
          if (typeof t2 == "boolean")
            return dt;
          if (typeof t2 == "number")
            return pt;
          if (t2 instanceof Ft)
            return yt;
          if (t2 instanceof Tt)
            return xt;
          if (t2 instanceof Dt)
            return vt;
          if (t2 instanceof $t)
            return bt;
          if (t2 instanceof Rt)
            return wt;
          if (Array.isArray(t2)) {
            let e2 = t2.length, r2;
            for (let e3 of t2) {
              let t3 = qt(e3);
              if (r2) {
                if (r2 === t3)
                  continue;
                r2 = gt;
                break;
              }
              r2 = t3;
            }
            return _t(r2 || gt, e2);
          }
          return mt;
        }
        function jt(t2) {
          let e2 = typeof t2;
          return t2 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t2) : t2 instanceof Ft || t2 instanceof Dt || t2 instanceof $t || t2 instanceof Rt ? t2.toString() : JSON.stringify(t2);
        }
        class Nt {
          constructor(t2, e2) {
            this.type = t2, this.value = e2;
          }
          static parse(t2, e2) {
            if (t2.length !== 2)
              return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (!Ut(t2[1]))
              return e2.error("invalid value");
            let r2 = t2[1], n2 = qt(r2), i2 = e2.expectedType;
            return n2.kind !== "array" || n2.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n2 = i2), new Nt(n2, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class Zt {
          constructor(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          }
          toJSON() {
            return this.message;
          }
        }
        let Kt = { string: ft, number: pt, boolean: dt, object: mt };
        class Gt {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            let r2, n2 = 1, i2 = t2[0];
            if (i2 === "array") {
              let i3, a3;
              if (t2.length > 2) {
                let r3 = t2[1];
                if (typeof r3 != "string" || !(r3 in Kt) || r3 === "object")
                  return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = Kt[r3], n2++;
              } else
                i3 = gt;
              if (t2.length > 3) {
                if (t2[2] !== null && (typeof t2[2] != "number" || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                  return e2.error('The length argument to "array" must be a positive integer literal', 2);
                a3 = t2[2], n2++;
              }
              r2 = _t(i3, a3);
            } else {
              if (!Kt[i2])
                throw new Error(`Types doesn't contain name = ${i2}`);
              r2 = Kt[i2];
            }
            let a2 = [];
            for (; n2 < t2.length; n2++) {
              let r3 = e2.parse(t2[n2], n2, gt);
              if (!r3)
                return null;
              a2.push(r3);
            }
            return new Gt(r2, a2);
          }
          evaluate(t2) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              let r2 = this.args[e2].evaluate(t2);
              if (!St(this.type, qt(r2)))
                return r2;
              if (e2 === this.args.length - 1)
                throw new Zt(`Expected value to be of type ${At(this.type)}, but found ${At(qt(r2))} instead.`);
            }
            throw new Error();
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        let Jt = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
        class Xt {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            let r2 = t2[0];
            if (!Jt[r2])
              throw new Error(`Can't parse ${r2} as it is not part of the known types`);
            if ((r2 === "to-boolean" || r2 === "to-string") && t2.length !== 2)
              return e2.error("Expected one argument.");
            let n2 = Jt[r2], i2 = [];
            for (let r3 = 1; r3 < t2.length; r3++) {
              let n3 = e2.parse(t2[r3], r3, gt);
              if (!n3)
                return null;
              i2.push(n3);
            }
            return new Xt(n2, i2);
          }
          evaluate(t2) {
            if (this.type.kind === "boolean")
              return Boolean(this.args[0].evaluate(t2));
            if (this.type.kind === "color") {
              let e2, r2;
              for (let n2 of this.args) {
                if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Ft)
                  return e2;
                if (typeof e2 == "string") {
                  let r3 = t2.parseColor(e2);
                  if (r3)
                    return r3;
                } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Ot(e2[0], e2[1], e2[2], e2[3]), !r2))
                  return new Ft(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new Zt(r2 || `Could not parse color from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            if (this.type.kind === "padding") {
              let e2;
              for (let r2 of this.args) {
                e2 = r2.evaluate(t2);
                let n2 = $t.parse(e2);
                if (n2)
                  return n2;
              }
              throw new Zt(`Could not parse padding from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            if (this.type.kind === "number") {
              let e2 = null;
              for (let r2 of this.args) {
                if (e2 = r2.evaluate(t2), e2 === null)
                  return 0;
                let n2 = Number(e2);
                if (!isNaN(n2))
                  return n2;
              }
              throw new Zt(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            return this.type.kind === "formatted" ? Dt.fromString(jt(this.args[0].evaluate(t2))) : this.type.kind === "resolvedImage" ? Rt.fromString(jt(this.args[0].evaluate(t2))) : jt(this.args[0].evaluate(t2));
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        let Yt = ["Unknown", "Point", "LineString", "Polygon"];
        class Ht {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Yt[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t2) {
            let e2 = this._parseColorCache[t2];
            return e2 || (e2 = this._parseColorCache[t2] = Ft.parse(t2)), e2;
          }
        }
        class Wt {
          constructor(t2, e2, r2, n2) {
            this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
          }
          evaluate(t2) {
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return !1;
          }
          static parse(t2, e2) {
            let r2 = t2[0], n2 = Wt.definitions[r2];
            if (!n2)
              return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            let i2 = Array.isArray(n2) ? n2[0] : n2.type, a2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, s2 = a2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1), o2 = null;
            for (let [n3, a3] of s2) {
              o2 = new we(e2.registry, e2.path, null, e2.scope);
              let s3 = [], l2 = !1;
              for (let e3 = 1; e3 < t2.length; e3++) {
                let r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, a4 = o2.parse(r3, 1 + s3.length, i3);
                if (!a4) {
                  l2 = !0;
                  break;
                }
                s3.push(a4);
              }
              if (!l2)
                if (Array.isArray(n3) && n3.length !== s3.length)
                  o2.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
                else {
                  for (let t3 = 0; t3 < s3.length; t3++) {
                    let e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                    o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                  }
                  if (o2.errors.length === 0)
                    return new Wt(r2, i2, a3, s3);
                }
            }
            if (s2.length === 1)
              e2.errors.push(...o2.errors);
            else {
              let r3 = (s2.length ? s2 : a2).map(([t3]) => {
                return e3 = t3, Array.isArray(e3) ? `(${e3.map(At).join(", ")})` : `(${At(e3.type)}...)`;
                var e3;
              }).join(" | "), n3 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                let i3 = e2.parse(t2[r4], 1 + n3.length);
                if (!i3)
                  return null;
                n3.push(At(i3.type));
              }
              e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t2, e2) {
            Wt.definitions = e2;
            for (let r2 in e2)
              t2[r2] = Wt;
          }
        }
        class Qt {
          constructor(t2, e2, r2) {
            this.type = xt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
          }
          static parse(t2, e2) {
            if (t2.length !== 2)
              return e2.error("Expected one argument.");
            let r2 = t2[1];
            if (typeof r2 != "object" || Array.isArray(r2))
              return e2.error("Collator options argument must be an object.");
            let n2 = e2.parse(r2["case-sensitive"] !== void 0 && r2["case-sensitive"], 1, dt);
            if (!n2)
              return null;
            let i2 = e2.parse(r2["diacritic-sensitive"] !== void 0 && r2["diacritic-sensitive"], 1, dt);
            if (!i2)
              return null;
            let a2 = null;
            return r2.locale && (a2 = e2.parse(r2.locale, 1, ft), !a2) ? null : new Qt(n2, i2, a2);
          }
          evaluate(t2) {
            return new Tt(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        let te = 8192;
        function ee(t2, e2) {
          t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
        }
        function re(t2, e2) {
          return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
        }
        function ne(t2, e2) {
          let r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
          return [Math.round(r2 * i2 * te), Math.round(n2 * i2 * te)];
        }
        function ie(t2, e2, r2) {
          let n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], a2 = t2[0] - r2[0], s2 = t2[1] - r2[1];
          return n2 * s2 - a2 * i2 == 0 && n2 * a2 <= 0 && i2 * s2 <= 0;
        }
        function ae(t2, e2) {
          let r2 = !1;
          for (let s2 = 0, o2 = e2.length; s2 < o2; s2++) {
            let o3 = e2[s2];
            for (let e3 = 0, s3 = o3.length; e3 < s3 - 1; e3++) {
              if (ie(t2, o3[e3], o3[e3 + 1]))
                return !1;
              (i2 = o3[e3])[1] > (n2 = t2)[1] != (a2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (a2[0] - i2[0]) * (n2[1] - i2[1]) / (a2[1] - i2[1]) + i2[0] && (r2 = !r2);
            }
          }
          var n2, i2, a2;
          return r2;
        }
        function se(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (ae(t2, e2[r2]))
              return !0;
          return !1;
        }
        function oe(t2, e2, r2, n2) {
          let i2 = n2[0] - r2[0], a2 = n2[1] - r2[1], s2 = (t2[0] - r2[0]) * a2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * a2 - i2 * (e2[1] - r2[1]);
          return s2 > 0 && o2 < 0 || s2 < 0 && o2 > 0;
        }
        function le(t2, e2, r2) {
          for (let u2 of r2)
            for (let r3 = 0; r3 < u2.length - 1; ++r3)
              if ((o2 = [(s2 = u2[r3 + 1])[0] - (a2 = u2[r3])[0], s2[1] - a2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] != 0 && oe(n2, i2, a2, s2) && oe(a2, s2, n2, i2))
                return !0;
          var n2, i2, a2, s2, o2, l2;
          return !1;
        }
        function ue(t2, e2) {
          for (let r2 = 0; r2 < t2.length; ++r2)
            if (!ae(t2[r2], e2))
              return !1;
          for (let r2 = 0; r2 < t2.length - 1; ++r2)
            if (le(t2[r2], t2[r2 + 1], e2))
              return !1;
          return !0;
        }
        function ce(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (ue(t2, e2[r2]))
              return !0;
          return !1;
        }
        function he(t2, e2, r2) {
          let n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            let a2 = [];
            for (let n3 = 0; n3 < t2[i2].length; n3++) {
              let s2 = ne(t2[i2][n3], r2);
              ee(e2, s2), a2.push(s2);
            }
            n2.push(a2);
          }
          return n2;
        }
        function pe(t2, e2, r2) {
          let n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            let a2 = he(t2[i2], e2, r2);
            n2.push(a2);
          }
          return n2;
        }
        function fe(t2, e2, r2, n2) {
          if (t2[0] < r2[0] || t2[0] > r2[2]) {
            let e3 = 0.5 * n2, i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
            i2 === 0 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
          }
          ee(e2, t2);
        }
        function de(t2, e2, r2, n2) {
          let i2 = Math.pow(2, n2.z) * te, a2 = [n2.x * te, n2.y * te], s2 = [];
          for (let n3 of t2)
            for (let t3 of n3) {
              let n4 = [t3.x + a2[0], t3.y + a2[1]];
              fe(n4, e2, r2, i2), s2.push(n4);
            }
          return s2;
        }
        function ye(t2, e2, r2, n2) {
          let i2 = Math.pow(2, n2.z) * te, a2 = [n2.x * te, n2.y * te], s2 = [];
          for (let r3 of t2) {
            let t3 = [];
            for (let n3 of r3) {
              let r4 = [n3.x + a2[0], n3.y + a2[1]];
              ee(e2, r4), t3.push(r4);
            }
            s2.push(t3);
          }
          if (e2[2] - e2[0] <= i2 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (let t3 of s2)
              for (let n3 of t3)
                fe(n3, e2, r2, i2);
          }
          var o2;
          return s2;
        }
        class me {
          constructor(t2, e2) {
            this.type = dt, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (t2.length !== 2)
              return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (Ut(t2[1])) {
              let e3 = t2[1];
              if (e3.type === "FeatureCollection")
                for (let t3 = 0; t3 < e3.features.length; ++t3) {
                  let r2 = e3.features[t3].geometry.type;
                  if (r2 === "Polygon" || r2 === "MultiPolygon")
                    return new me(e3, e3.features[t3].geometry);
                }
              else if (e3.type === "Feature") {
                let t3 = e3.geometry.type;
                if (t3 === "Polygon" || t3 === "MultiPolygon")
                  return new me(e3, e3.geometry);
              } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
                return new me(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (t2.geometry() != null && t2.canonicalID() != null) {
              if (t2.geometryType() === "Point")
                return function(t3, e2) {
                  let r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if (e2.type === "Polygon") {
                    let a2 = he(e2.coordinates, n2, i2), s2 = de(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return !1;
                    for (let t4 of s2)
                      if (!ae(t4, a2))
                        return !1;
                  }
                  if (e2.type === "MultiPolygon") {
                    let a2 = pe(e2.coordinates, n2, i2), s2 = de(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return !1;
                    for (let t4 of s2)
                      if (!se(t4, a2))
                        return !1;
                  }
                  return !0;
                }(t2, this.geometries);
              if (t2.geometryType() === "LineString")
                return function(t3, e2) {
                  let r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if (e2.type === "Polygon") {
                    let a2 = he(e2.coordinates, n2, i2), s2 = ye(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return !1;
                    for (let t4 of s2)
                      if (!ue(t4, a2))
                        return !1;
                  }
                  if (e2.type === "MultiPolygon") {
                    let a2 = pe(e2.coordinates, n2, i2), s2 = ye(t3.geometry(), r2, n2, i2);
                    if (!re(r2, n2))
                      return !1;
                    for (let t4 of s2)
                      if (!ce(t4, a2))
                        return !1;
                  }
                  return !0;
                }(t2, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        function ge(t2) {
          if (t2 instanceof Wt && (t2.name === "get" && t2.args.length === 1 || t2.name === "feature-state" || t2.name === "has" && t2.args.length === 1 || t2.name === "properties" || t2.name === "geometry-type" || t2.name === "id" || /^filter-/.test(t2.name)) || t2 instanceof me)
            return !1;
          let e2 = !0;
          return t2.eachChild((t3) => {
            e2 && !ge(t3) && (e2 = !1);
          }), e2;
        }
        function xe(t2) {
          if (t2 instanceof Wt && t2.name === "feature-state")
            return !1;
          let e2 = !0;
          return t2.eachChild((t3) => {
            e2 && !xe(t3) && (e2 = !1);
          }), e2;
        }
        function ve(t2, e2) {
          if (t2 instanceof Wt && e2.indexOf(t2.name) >= 0)
            return !1;
          let r2 = !0;
          return t2.eachChild((t3) => {
            r2 && !ve(t3, e2) && (r2 = !1);
          }), r2;
        }
        class be {
          constructor(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          }
          static parse(t2, e2) {
            if (t2.length !== 2 || typeof t2[1] != "string")
              return e2.error("'var' expression requires exactly one string literal argument.");
            let r2 = t2[1];
            return e2.scope.has(r2) ? new be(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class we {
          constructor(t2, e2 = [], r2, n2 = new ct(), i2 = []) {
            this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
          }
          parse(t2, e2, r2, n2, i2 = {}) {
            return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
          }
          _parse(t2, e2) {
            function r2(t3, e3, r3) {
              return r3 === "assert" ? new Gt(e3, [t3]) : r3 === "coerce" ? new Xt(e3, [t3]) : t3;
            }
            if (t2 !== null && typeof t2 != "string" && typeof t2 != "boolean" && typeof t2 != "number" || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (t2.length === 0)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              let n2 = t2[0];
              if (typeof n2 != "string")
                return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              let i2 = this.registry[n2];
              if (i2) {
                let n3 = i2.parse(t2, this);
                if (!n3)
                  return null;
                if (this.expectedType) {
                  let t3 = this.expectedType, i3 = n3.type;
                  if (t3.kind !== "string" && t3.kind !== "number" && t3.kind !== "boolean" && t3.kind !== "object" && t3.kind !== "array" || i3.kind !== "value")
                    if (t3.kind !== "color" && t3.kind !== "formatted" && t3.kind !== "resolvedImage" || i3.kind !== "value" && i3.kind !== "string")
                      if (t3.kind !== "padding" || i3.kind !== "value" && i3.kind !== "number" && i3.kind !== "array") {
                        if (this.checkSubtype(t3, i3))
                          return null;
                      } else
                        n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else
                    n3 = r2(n3, t3, e2.typeAnnotation || "assert");
                }
                if (!(n3 instanceof Nt) && n3.type.kind !== "resolvedImage" && _e(n3)) {
                  let t3 = new Ht();
                  try {
                    n3 = new Nt(n3.type, n3.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return n3;
              }
              return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t2 === void 0 ? "'undefined' value invalid. Use null instead." : typeof t2 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
          }
          concat(t2, e2, r2) {
            let n2 = typeof t2 == "number" ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
            return new we(this.registry, n2, e2 || null, i2, this.errors);
          }
          error(t2, ...e2) {
            let r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
            this.errors.push(new ut(r2, t2));
          }
          checkSubtype(t2, e2) {
            let r2 = St(t2, e2);
            return r2 && this.error(r2), r2;
          }
        }
        function _e(t2) {
          if (t2 instanceof be)
            return _e(t2.boundExpression);
          if (t2 instanceof Wt && t2.name === "error" || t2 instanceof Qt || t2 instanceof me)
            return !1;
          let e2 = t2 instanceof Xt || t2 instanceof Gt, r2 = !0;
          return t2.eachChild((t3) => {
            r2 = e2 ? r2 && _e(t3) : r2 && t3 instanceof Nt;
          }), !!r2 && ge(t2) && ve(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Ae(t2, e2) {
          let r2 = t2.length - 1, n2, i2, a2 = 0, s2 = r2, o2 = 0;
          for (; a2 <= s2; )
            if (o2 = Math.floor((a2 + s2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
              if (o2 === r2 || e2 < i2)
                return o2;
              a2 = o2 + 1;
            } else {
              if (!(n2 > e2))
                throw new Zt("Input is not a number.");
              s2 = o2 - 1;
            }
          return 0;
        }
        class ke {
          constructor(t2, e2, r2) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (let [t3, e3] of r2)
              this.labels.push(t3), this.outputs.push(e3);
          }
          static parse(t2, e2) {
            if (t2.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            let r2 = e2.parse(t2[1], 1, pt);
            if (!r2)
              return null;
            let n2 = [], i2 = null;
            e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
            for (let r3 = 1; r3 < t2.length; r3 += 2) {
              let a2 = r3 === 1 ? -1 / 0 : t2[r3], s2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
              if (typeof a2 != "number")
                return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= a2)
                return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              let u2 = e2.parse(s2, l2, i2);
              if (!u2)
                return null;
              i2 = i2 || u2.type, n2.push([a2, u2]);
            }
            return new ke(i2, r2, n2);
          }
          evaluate(t2) {
            let e2 = this.labels, r2 = this.outputs;
            if (e2.length === 1)
              return r2[0].evaluate(t2);
            let n2 = this.input.evaluate(t2);
            if (n2 <= e2[0])
              return r2[0].evaluate(t2);
            let i2 = e2.length;
            return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Ae(e2, n2)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (let e2 of this.outputs)
              t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
        }
        function Se(t2, e2, r2) {
          return t2 * (1 - r2) + e2 * r2;
        }
        var Ie = Object.freeze({ __proto__: null, number: Se, color: function(t2, e2, r2) {
          return new Ft(Se(t2.r, e2.r, r2), Se(t2.g, e2.g, r2), Se(t2.b, e2.b, r2), Se(t2.a, e2.a, r2));
        }, array: function(t2, e2, r2) {
          return t2.map((t3, n2) => Se(t3, e2[n2], r2));
        }, padding: function(t2, e2, r2) {
          let n2 = t2.values, i2 = e2.values;
          return new $t([Se(n2[0], i2[0], r2), Se(n2[1], i2[1], r2), Se(n2[2], i2[2], r2), Se(n2[3], i2[3], r2)]);
        } });
        let Me = 0.95047, ze = 1.08883, Be = 4 / 29, Ce = 6 / 29, Pe = 3 * Ce * Ce, Ve = Math.PI / 180, Ee = 180 / Math.PI;
        function Fe(t2) {
          return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Pe + Be;
        }
        function Te(t2) {
          return t2 > Ce ? t2 * t2 * t2 : Pe * (t2 - Be);
        }
        function Le(t2) {
          return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
        }
        function De(t2) {
          return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function $e(t2) {
          let e2 = De(t2.r), r2 = De(t2.g), n2 = De(t2.b), i2 = Fe((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / Me), a2 = Fe((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
          return { l: 116 * a2 - 16, a: 500 * (i2 - a2), b: 200 * (a2 - Fe((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / ze)), alpha: t2.a };
        }
        function Re(t2) {
          let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
          return e2 = 1 * Te(e2), r2 = Me * Te(r2), n2 = ze * Te(n2), new Ft(Le(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Le(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Le(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
        }
        function Oe(t2, e2, r2) {
          let n2 = e2 - t2;
          return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
        }
        let Ue = { forward: $e, reverse: Re, interpolate: function(t2, e2, r2) {
          return { l: Se(t2.l, e2.l, r2), a: Se(t2.a, e2.a, r2), b: Se(t2.b, e2.b, r2), alpha: Se(t2.alpha, e2.alpha, r2) };
        } }, qe = { forward: function(t2) {
          let { l: e2, a: r2, b: n2 } = $e(t2), i2 = Math.atan2(n2, r2) * Ee;
          return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
        }, reverse: function(t2) {
          let e2 = t2.h * Ve, r2 = t2.c;
          return Re({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
        }, interpolate: function(t2, e2, r2) {
          return { h: Oe(t2.h, e2.h, r2), c: Se(t2.c, e2.c, r2), l: Se(t2.l, e2.l, r2), alpha: Se(t2.alpha, e2.alpha, r2) };
        } };
        var je = Object.freeze({ __proto__: null, lab: Ue, hcl: qe });
        class Ne {
          constructor(t2, e2, r2, n2, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (let [t3, e3] of i2)
              this.labels.push(t3), this.outputs.push(e3);
          }
          static interpolationFactor(t2, r2, n2, i2) {
            let a2 = 0;
            if (t2.name === "exponential")
              a2 = Ze(r2, t2.base, n2, i2);
            else if (t2.name === "linear")
              a2 = Ze(r2, 1, n2, i2);
            else if (t2.name === "cubic-bezier") {
              let s2 = t2.controlPoints;
              a2 = new e(s2[0], s2[1], s2[2], s2[3]).solve(Ze(r2, 1, n2, i2));
            }
            return a2;
          }
          static parse(t2, e2) {
            let [r2, n2, i2, ...a2] = t2;
            if (!Array.isArray(n2) || n2.length === 0)
              return e2.error("Expected an interpolation type expression.", 1);
            if (n2[0] === "linear")
              n2 = { name: "linear" };
            else if (n2[0] === "exponential") {
              let t3 = n2[1];
              if (typeof t3 != "number")
                return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t3 };
            } else {
              if (n2[0] !== "cubic-bezier")
                return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                let t3 = n2.slice(1);
                if (t3.length !== 4 || t3.some((t4) => typeof t4 != "number" || t4 < 0 || t4 > 1))
                  return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            if (i2 = e2.parse(i2, 2, pt), !i2)
              return null;
            let s2 = [], o2 = null;
            r2 === "interpolate-hcl" || r2 === "interpolate-lab" ? o2 = yt : e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType);
            for (let t3 = 0; t3 < a2.length; t3 += 2) {
              let r3 = a2[t3], n3 = a2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
              if (typeof r3 != "number")
                return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (s2.length && s2[s2.length - 1][0] >= r3)
                return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              let u2 = e2.parse(n3, l2, o2);
              if (!u2)
                return null;
              o2 = o2 || u2.type, s2.push([r3, u2]);
            }
            return o2.kind === "number" || o2.kind === "color" || o2.kind === "padding" || o2.kind === "array" && o2.itemType.kind === "number" && typeof o2.N == "number" ? new Ne(o2, r2, n2, i2, s2) : e2.error(`Type ${At(o2)} is not interpolatable.`);
          }
          evaluate(t2) {
            let e2 = this.labels, r2 = this.outputs;
            if (e2.length === 1)
              return r2[0].evaluate(t2);
            let n2 = this.input.evaluate(t2);
            if (n2 <= e2[0])
              return r2[0].evaluate(t2);
            let i2 = e2.length;
            if (n2 >= e2[i2 - 1])
              return r2[i2 - 1].evaluate(t2);
            let a2 = Ae(e2, n2), s2 = Ne.interpolationFactor(this.interpolation, n2, e2[a2], e2[a2 + 1]), o2 = r2[a2].evaluate(t2), l2 = r2[a2 + 1].evaluate(t2);
            return this.operator === "interpolate" ? Ie[this.type.kind.toLowerCase()](o2, l2, s2) : this.operator === "interpolate-hcl" ? qe.reverse(qe.interpolate(qe.forward(o2), qe.forward(l2), s2)) : Ue.reverse(Ue.interpolate(Ue.forward(o2), Ue.forward(l2), s2));
          }
          eachChild(t2) {
            t2(this.input);
            for (let e2 of this.outputs)
              t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
        }
        function Ze(t2, e2, r2, n2) {
          let i2 = n2 - r2, a2 = t2 - r2;
          return i2 === 0 ? 0 : e2 === 1 ? a2 / i2 : (Math.pow(e2, a2) - 1) / (Math.pow(e2, i2) - 1);
        }
        class Ke {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expectected at least one argument.");
            let r2 = null, n2 = e2.expectedType;
            n2 && n2.kind !== "value" && (r2 = n2);
            let i2 = [];
            for (let n3 of t2.slice(1)) {
              let t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t3)
                return null;
              r2 = r2 || t3.type, i2.push(t3);
            }
            if (!r2)
              throw new Error("No output type");
            let a2 = n2 && i2.some((t3) => St(n2, t3.type));
            return new Ke(a2 ? gt : r2, i2);
          }
          evaluate(t2) {
            let e2, r2 = null, n2 = 0;
            for (let i2 of this.args)
              if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Rt && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), r2 !== null)
                break;
            return r2;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        class Ge {
          constructor(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (let e2 of this.bindings)
              t2(e2[1]);
            t2(this.result);
          }
          static parse(t2, e2) {
            if (t2.length < 4)
              return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
            let r2 = [];
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
              let i2 = t2[n3];
              if (typeof i2 != "string")
                return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i2))
                return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              let a2 = e2.parse(t2[n3 + 1], n3 + 1);
              if (!a2)
                return null;
              r2.push([i2, a2]);
            }
            let n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
            return n2 ? new Ge(r2, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Je {
          constructor(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          }
          static parse(t2, e2) {
            if (t2.length !== 3)
              return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            let r2 = e2.parse(t2[1], 1, pt), n2 = e2.parse(t2[2], 2, _t(e2.expectedType || gt));
            return r2 && n2 ? new Je(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t2) {
            let e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0)
              throw new Zt(`Array index out of bounds: ${e2} < 0.`);
            if (e2 >= r2.length)
              throw new Zt(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
            if (e2 !== Math.floor(e2))
              throw new Zt(`Array index must be an integer, but found ${e2} instead.`);
            return r2[e2];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Xe {
          constructor(t2, e2) {
            this.type = dt, this.needle = t2, this.haystack = e2;
          }
          static parse(t2, e2) {
            if (t2.length !== 3)
              return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            let r2 = e2.parse(t2[1], 1, gt), n2 = e2.parse(t2[2], 2, gt);
            return r2 && n2 ? It(r2.type, [dt, ft, pt, ht, gt]) ? new Xe(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${At(r2.type)} instead`) : null;
          }
          evaluate(t2) {
            let e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!r2)
              return !1;
            if (!Mt(e2, ["boolean", "string", "number", "null"]))
              throw new Zt(`Expected first argument to be of type boolean, string, number or null, but found ${At(qt(e2))} instead.`);
            if (!Mt(r2, ["string", "array"]))
              throw new Zt(`Expected second argument to be of type array or string, but found ${At(qt(r2))} instead.`);
            return r2.indexOf(e2) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class Ye {
          constructor(t2, e2, r2) {
            this.type = pt, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            let r2 = e2.parse(t2[1], 1, gt), n2 = e2.parse(t2[2], 2, gt);
            if (!r2 || !n2)
              return null;
            if (!It(r2.type, [dt, ft, pt, ht, gt]))
              return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${At(r2.type)} instead`);
            if (t2.length === 4) {
              let i2 = e2.parse(t2[3], 3, pt);
              return i2 ? new Ye(r2, n2, i2) : null;
            }
            return new Ye(r2, n2);
          }
          evaluate(t2) {
            let e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!Mt(e2, ["boolean", "string", "number", "null"]))
              throw new Zt(`Expected first argument to be of type boolean, string, number or null, but found ${At(qt(e2))} instead.`);
            if (!Mt(r2, ["string", "array"]))
              throw new Zt(`Expected second argument to be of type array or string, but found ${At(qt(r2))} instead.`);
            if (this.fromIndex) {
              let n2 = this.fromIndex.evaluate(t2);
              return r2.indexOf(e2, n2);
            }
            return r2.indexOf(e2);
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class He {
          constructor(t2, e2, r2, n2, i2, a2) {
            this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = a2;
          }
          static parse(t2, e2) {
            if (t2.length < 5)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 1)
              return e2.error("Expected an even number of arguments.");
            let r2, n2;
            e2.expectedType && e2.expectedType.kind !== "value" && (n2 = e2.expectedType);
            let i2 = {}, a2 = [];
            for (let s3 = 2; s3 < t2.length - 1; s3 += 2) {
              let o3 = t2[s3], l2 = t2[s3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              let u2 = e2.concat(s3);
              if (o3.length === 0)
                return u2.error("Expected at least one branch label.");
              for (let t3 of o3) {
                if (typeof t3 != "number" && typeof t3 != "string")
                  return u2.error("Branch labels must be numbers or strings.");
                if (typeof t3 == "number" && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                  return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof t3 == "number" && Math.floor(t3) !== t3)
                  return u2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u2.checkSubtype(r2, qt(t3)))
                    return null;
                } else
                  r2 = qt(t3);
                if (i2[String(t3)] !== void 0)
                  return u2.error("Branch labels must be unique.");
                i2[String(t3)] = a2.length;
              }
              let c2 = e2.parse(l2, s3, n2);
              if (!c2)
                return null;
              n2 = n2 || c2.type, a2.push(c2);
            }
            let s2 = e2.parse(t2[1], 1, gt);
            if (!s2)
              return null;
            let o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
            return o2 ? s2.type.kind !== "value" && e2.concat(1).checkSubtype(r2, s2.type) ? null : new He(r2, n2, s2, i2, a2, o2) : null;
          }
          evaluate(t2) {
            let e2 = this.input.evaluate(t2);
            return (qt(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class We {
          constructor(t2, e2, r2) {
            this.type = t2, this.branches = e2, this.otherwise = r2;
          }
          static parse(t2, e2) {
            if (t2.length < 4)
              return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 0)
              return e2.error("Expected an odd number of arguments.");
            let r2;
            e2.expectedType && e2.expectedType.kind !== "value" && (r2 = e2.expectedType);
            let n2 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              let a2 = e2.parse(t2[i3], i3, dt);
              if (!a2)
                return null;
              let s2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
              if (!s2)
                return null;
              n2.push([a2, s2]), r2 = r2 || s2.type;
            }
            let i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
            if (!i2)
              return null;
            if (!r2)
              throw new Error("Can't infer output type");
            return new We(r2, n2, i2);
          }
          evaluate(t2) {
            for (let [e2, r2] of this.branches)
              if (e2.evaluate(t2))
                return r2.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (let [e2, r2] of this.branches)
              t2(e2), t2(r2);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Qe {
          constructor(t2, e2, r2, n2) {
            this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            let r2 = e2.parse(t2[1], 1, gt), n2 = e2.parse(t2[2], 2, pt);
            if (!r2 || !n2)
              return null;
            if (!It(r2.type, [_t(gt), ft, gt]))
              return e2.error(`Expected first argument to be of type array or string, but found ${At(r2.type)} instead`);
            if (t2.length === 4) {
              let i2 = e2.parse(t2[3], 3, pt);
              return i2 ? new Qe(r2.type, r2, n2, i2) : null;
            }
            return new Qe(r2.type, r2, n2);
          }
          evaluate(t2) {
            let e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            if (!Mt(e2, ["string", "array"]))
              throw new Zt(`Expected first argument to be of type array or string, but found ${At(qt(e2))} instead.`);
            if (this.endIndex) {
              let n2 = this.endIndex.evaluate(t2);
              return e2.slice(r2, n2);
            }
            return e2.slice(r2);
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function tr(t2, e2) {
          return t2 === "==" || t2 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
        }
        function er(t2, e2, r2, n2) {
          return n2.compare(e2, r2) === 0;
        }
        function rr(t2, e2, r2) {
          let n2 = t2 !== "==" && t2 !== "!=";
          return class i2 {
            constructor(t3, e3, r3) {
              this.type = dt, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = t3.type.kind === "value" || e3.type.kind === "value";
            }
            static parse(t3, e3) {
              if (t3.length !== 3 && t3.length !== 4)
                return e3.error("Expected two or three arguments.");
              let r3 = t3[0], a2 = e3.parse(t3[1], 1, gt);
              if (!a2)
                return null;
              if (!tr(r3, a2.type))
                return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${At(a2.type)}'.`);
              let s2 = e3.parse(t3[2], 2, gt);
              if (!s2)
                return null;
              if (!tr(r3, s2.type))
                return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${At(s2.type)}'.`);
              if (a2.type.kind !== s2.type.kind && a2.type.kind !== "value" && s2.type.kind !== "value")
                return e3.error(`Cannot compare types '${At(a2.type)}' and '${At(s2.type)}'.`);
              n2 && (a2.type.kind === "value" && s2.type.kind !== "value" ? a2 = new Gt(s2.type, [a2]) : a2.type.kind !== "value" && s2.type.kind === "value" && (s2 = new Gt(a2.type, [s2])));
              let o2 = null;
              if (t3.length === 4) {
                if (a2.type.kind !== "string" && s2.type.kind !== "string" && a2.type.kind !== "value" && s2.type.kind !== "value")
                  return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t3[3], 3, xt), !o2)
                  return null;
              }
              return new i2(a2, s2, o2);
            }
            evaluate(i3) {
              let a2 = this.lhs.evaluate(i3), s2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                let e3 = qt(a2), r3 = qt(s2);
                if (e3.kind !== r3.kind || e3.kind !== "string" && e3.kind !== "number")
                  throw new Zt(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                let t3 = qt(a2), r3 = qt(s2);
                if (t3.kind !== "string" || r3.kind !== "string")
                  return e2(i3, a2, s2);
              }
              return this.collator ? r2(i3, a2, s2, this.collator.evaluate(i3)) : e2(i3, a2, s2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        let nr = rr("==", function(t2, e2, r2) {
          return e2 === r2;
        }, er), ir = rr("!=", function(t2, e2, r2) {
          return e2 !== r2;
        }, function(t2, e2, r2, n2) {
          return !er(0, e2, r2, n2);
        }), ar = rr("<", function(t2, e2, r2) {
          return e2 < r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        }), sr = rr(">", function(t2, e2, r2) {
          return e2 > r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        }), or = rr("<=", function(t2, e2, r2) {
          return e2 <= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        }), lr = rr(">=", function(t2, e2, r2) {
          return e2 >= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        });
        class ur {
          constructor(t2, e2, r2, n2, i2) {
            this.type = ft, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
          }
          static parse(t2, e2) {
            if (t2.length !== 3)
              return e2.error("Expected two arguments.");
            let r2 = e2.parse(t2[1], 1, pt);
            if (!r2)
              return null;
            let n2 = t2[2];
            if (typeof n2 != "object" || Array.isArray(n2))
              return e2.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n2.locale && (i2 = e2.parse(n2.locale, 1, ft), !i2))
              return null;
            let a2 = null;
            if (n2.currency && (a2 = e2.parse(n2.currency, 1, ft), !a2))
              return null;
            let s2 = null;
            if (n2["min-fraction-digits"] && (s2 = e2.parse(n2["min-fraction-digits"], 1, pt), !s2))
              return null;
            let o2 = null;
            return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, pt), !o2) ? null : new ur(r2, i2, a2, s2, o2);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class cr {
          constructor(t2) {
            this.type = vt, this.sections = t2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            let r2 = t2[1];
            if (!Array.isArray(r2) && typeof r2 == "object")
              return e2.error("First argument must be an image or text section.");
            let n2 = [], i2 = !1;
            for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
              let a2 = t2[r3];
              if (i2 && typeof a2 == "object" && !Array.isArray(a2)) {
                i2 = !1;
                let t3 = null;
                if (a2["font-scale"] && (t3 = e2.parse(a2["font-scale"], 1, pt), !t3))
                  return null;
                let r4 = null;
                if (a2["text-font"] && (r4 = e2.parse(a2["text-font"], 1, _t(ft)), !r4))
                  return null;
                let s2 = null;
                if (a2["text-color"] && (s2 = e2.parse(a2["text-color"], 1, yt), !s2))
                  return null;
                let o2 = n2[n2.length - 1];
                o2.scale = t3, o2.font = r4, o2.textColor = s2;
              } else {
                let a3 = e2.parse(t2[r3], 1, gt);
                if (!a3)
                  return null;
                let s2 = a3.type.kind;
                if (s2 !== "string" && s2 !== "value" && s2 !== "null" && s2 !== "resolvedImage")
                  return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = !0, n2.push({ content: a3, scale: null, font: null, textColor: null });
              }
            }
            return new cr(n2);
          }
          evaluate(t2) {
            return new Dt(this.sections.map((e2) => {
              let r2 = e2.content.evaluate(t2);
              return qt(r2) === wt ? new Lt("", r2, null, null, null) : new Lt(jt(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
            }));
          }
          eachChild(t2) {
            for (let e2 of this.sections)
              t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
          }
          outputDefined() {
            return !1;
          }
        }
        class hr {
          constructor(t2) {
            this.type = wt, this.input = t2;
          }
          static parse(t2, e2) {
            if (t2.length !== 2)
              return e2.error("Expected two arguments.");
            let r2 = e2.parse(t2[1], 1, ft);
            return r2 ? new hr(r2) : e2.error("No image name provided.");
          }
          evaluate(t2) {
            let e2 = this.input.evaluate(t2), r2 = Rt.fromString(e2);
            return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class pr {
          constructor(t2) {
            this.type = pt, this.input = t2;
          }
          static parse(t2, e2) {
            if (t2.length !== 2)
              return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            let r2 = e2.parse(t2[1], 1);
            return r2 ? r2.type.kind !== "array" && r2.type.kind !== "string" && r2.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${At(r2.type)} instead.`) : new pr(r2) : null;
          }
          evaluate(t2) {
            let e2 = this.input.evaluate(t2);
            if (typeof e2 == "string" || Array.isArray(e2))
              return e2.length;
            throw new Zt(`Expected value to be of type string or array, but found ${At(qt(e2))} instead.`);
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        let fr = { "==": nr, "!=": ir, ">": sr, "<": ar, ">=": lr, "<=": or, array: Gt, at: Je, boolean: Gt, case: We, coalesce: Ke, collator: Qt, format: cr, image: hr, in: Xe, "index-of": Ye, interpolate: Ne, "interpolate-hcl": Ne, "interpolate-lab": Ne, length: pr, let: Ge, literal: Nt, match: He, number: Gt, "number-format": ur, object: Gt, slice: Qe, step: ke, string: Gt, "to-boolean": Xt, "to-color": Xt, "to-number": Xt, "to-string": Xt, var: be, within: me };
        function dr(t2, [e2, r2, n2, i2]) {
          e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
          let a2 = i2 ? i2.evaluate(t2) : 1, s2 = Ot(e2, r2, n2, a2);
          if (s2)
            throw new Zt(s2);
          return new Ft(e2 / 255 * a2, r2 / 255 * a2, n2 / 255 * a2, a2);
        }
        function yr(t2, e2) {
          return t2 in e2;
        }
        function mr(t2, e2) {
          let r2 = e2[t2];
          return r2 === void 0 ? null : r2;
        }
        function gr(t2) {
          return { type: t2 };
        }
        function xr(t2) {
          return { result: "success", value: t2 };
        }
        function vr(t2) {
          return { result: "error", value: t2 };
        }
        function br(t2) {
          return t2["property-type"] === "data-driven" || t2["property-type"] === "cross-faded-data-driven";
        }
        function wr(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function _r(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function Ar(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
        }
        function kr(t2) {
          return typeof t2 == "object" && t2 !== null && !Array.isArray(t2);
        }
        function Sr(t2) {
          return t2;
        }
        function Ir(t2, e2) {
          let r2 = e2.type === "color", n2 = t2.stops && typeof t2.stops[0][0] == "object", i2 = n2 || !(n2 || t2.property !== void 0), a2 = t2.type || (_r(e2) ? "exponential" : "interval");
          if (r2 || e2.type === "padding") {
            let n3 = r2 ? Ft.parse : $t.parse;
            (t2 = st({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], n3(t3[1])])), t2.default = n3(t2.default ? t2.default : e2.default);
          }
          if (t2.colorSpace && t2.colorSpace !== "rgb" && !je[t2.colorSpace])
            throw new Error(`Unknown color space: ${t2.colorSpace}`);
          let s2, o2, l2;
          if (a2 === "exponential")
            s2 = Cr;
          else if (a2 === "interval")
            s2 = Br;
          else if (a2 === "categorical") {
            s2 = zr, o2 = /* @__PURE__ */ Object.create(null);
            for (let e3 of t2.stops)
              o2[e3[0]] = e3[1];
            l2 = typeof t2.stops[0][0];
          } else {
            if (a2 !== "identity")
              throw new Error(`Unknown function type "${a2}"`);
            s2 = Pr;
          }
          if (n2) {
            let r3 = {}, n3 = [];
            for (let e3 = 0; e3 < t2.stops.length; e3++) {
              let i4 = t2.stops[e3], a4 = i4[0].zoom;
              r3[a4] === void 0 && (r3[a4] = { zoom: a4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(a4)), r3[a4].stops.push([i4[0].value, i4[1]]);
            }
            let i3 = [];
            for (let t3 of n3)
              i3.push([r3[t3].zoom, Ir(r3[t3], e2)]);
            let a3 = { name: "linear" };
            return { kind: "composite", interpolationType: a3, interpolationFactor: Ne.interpolationFactor.bind(void 0, a3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Cr({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
          }
          if (i2) {
            let r3 = a2 === "exponential" ? { name: "exponential", base: t2.base !== void 0 ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: Ne.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => s2(t2, e2, r4, o2, l2) };
          }
          return { kind: "source", evaluate(r3, n3) {
            let i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
            return i3 === void 0 ? Mr(t2.default, e2.default) : s2(t2, e2, i3, o2, l2);
          } };
        }
        function Mr(t2, e2, r2) {
          return t2 !== void 0 ? t2 : e2 !== void 0 ? e2 : r2 !== void 0 ? r2 : void 0;
        }
        function zr(t2, e2, r2, n2, i2) {
          return Mr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
        }
        function Br(t2, e2, r2) {
          if (Ar(r2) !== "number")
            return Mr(t2.default, e2.default);
          let n2 = t2.stops.length;
          if (n2 === 1 || r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[n2 - 1][0])
            return t2.stops[n2 - 1][1];
          let i2 = Ae(t2.stops.map((t3) => t3[0]), r2);
          return t2.stops[i2][1];
        }
        function Cr(t2, e2, r2) {
          let n2 = t2.base !== void 0 ? t2.base : 1;
          if (Ar(r2) !== "number")
            return Mr(t2.default, e2.default);
          let i2 = t2.stops.length;
          if (i2 === 1 || r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0])
            return t2.stops[i2 - 1][1];
          let a2 = Ae(t2.stops.map((t3) => t3[0]), r2), s2 = function(t3, e3, r3, n3) {
            let i3 = n3 - r3, a3 = t3 - r3;
            return i3 === 0 ? 0 : e3 === 1 ? a3 / i3 : (Math.pow(e3, a3) - 1) / (Math.pow(e3, i3) - 1);
          }(r2, n2, t2.stops[a2][0], t2.stops[a2 + 1][0]), o2 = t2.stops[a2][1], l2 = t2.stops[a2 + 1][1], u2 = Ie[e2.type] || Sr;
          if (t2.colorSpace && t2.colorSpace !== "rgb") {
            let e3 = je[t2.colorSpace];
            u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), s2));
          }
          return typeof o2.evaluate == "function" ? { evaluate(...t3) {
            let e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
            if (e3 !== void 0 && r3 !== void 0)
              return u2(e3, r3, s2);
          } } : u2(o2, l2, s2);
        }
        function Pr(t2, e2, r2) {
          switch (e2.type) {
            case "color":
              r2 = Ft.parse(r2);
              break;
            case "formatted":
              r2 = Dt.fromString(r2.toString());
              break;
            case "resolvedImage":
              r2 = Rt.fromString(r2.toString());
              break;
            case "padding":
              r2 = $t.parse(r2);
              break;
            default:
              Ar(r2) === e2.type || e2.type === "enum" && e2.values[r2] || (r2 = void 0);
          }
          return Mr(r2, t2.default, e2.default);
        }
        Wt.register(fr, { error: [{ kind: "error" }, [ft], (t2, [e2]) => {
          throw new Zt(e2.evaluate(t2));
        }], typeof: [ft, [gt], (t2, [e2]) => At(qt(e2.evaluate(t2)))], "to-rgba": [_t(pt, 4), [yt], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [yt, [pt, pt, pt], dr], rgba: [yt, [pt, pt, pt, pt], dr], has: { type: dt, overloads: [[[ft], (t2, [e2]) => yr(e2.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e2, r2]) => yr(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: gt, overloads: [[[ft], (t2, [e2]) => mr(e2.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e2, r2]) => mr(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [gt, [ft], (t2, [e2]) => mr(e2.evaluate(t2), t2.featureState || {})], properties: [mt, [], (t2) => t2.properties()], "geometry-type": [ft, [], (t2) => t2.geometryType()], id: [gt, [], (t2) => t2.id()], zoom: [pt, [], (t2) => t2.globals.zoom], "heatmap-density": [pt, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [pt, [], (t2) => t2.globals.lineProgress || 0], accumulated: [gt, [], (t2) => t2.globals.accumulated === void 0 ? null : t2.globals.accumulated], "+": [pt, gr(pt), (t2, e2) => {
          let r2 = 0;
          for (let n2 of e2)
            r2 += n2.evaluate(t2);
          return r2;
        }], "*": [pt, gr(pt), (t2, e2) => {
          let r2 = 1;
          for (let n2 of e2)
            r2 *= n2.evaluate(t2);
          return r2;
        }], "-": { type: pt, overloads: [[[pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[pt], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [pt, [pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [pt, [pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [pt, [pt], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [pt, [pt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [pt, [pt], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [pt, [pt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [pt, [pt], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [pt, [pt], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [pt, [pt], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [pt, [pt], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [pt, [pt], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [pt, [pt], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [pt, gr(pt), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [pt, gr(pt), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [pt, [pt], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [pt, [pt], (t2, [e2]) => {
          let r2 = e2.evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [pt, [pt], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [pt, [pt], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [dt, [ft, gt], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [dt, [gt], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [dt, [ft], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [dt, [ft, gt], (t2, [e2, r2]) => {
          let n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter-id-<": [dt, [gt], (t2, [e2]) => {
          let r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 < n2;
        }], "filter->": [dt, [ft, gt], (t2, [e2, r2]) => {
          let n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-id->": [dt, [gt], (t2, [e2]) => {
          let r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 > n2;
        }], "filter-<=": [dt, [ft, gt], (t2, [e2, r2]) => {
          let n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter-id-<=": [dt, [gt], (t2, [e2]) => {
          let r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 <= n2;
        }], "filter->=": [dt, [ft, gt], (t2, [e2, r2]) => {
          let n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-id->=": [dt, [gt], (t2, [e2]) => {
          let r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 >= n2;
        }], "filter-has": [dt, [gt], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [dt, [], (t2) => t2.id() !== null && t2.id() !== void 0], "filter-type-in": [dt, [_t(ft)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [dt, [_t(gt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [dt, [ft, _t(gt)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [dt, [ft, _t(gt)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
          for (; r3 <= n2; ) {
            let i2 = r3 + n2 >> 1;
            if (e3[i2] === t3)
              return !0;
            e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
          }
          return !1;
        }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [gr(dt), (t2, e2) => {
          for (let r2 of e2)
            if (!r2.evaluate(t2))
              return !1;
          return !0;
        }]] }, any: { type: dt, overloads: [[[dt, dt], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [gr(dt), (t2, e2) => {
          for (let r2 of e2)
            if (r2.evaluate(t2))
              return !0;
          return !1;
        }]] }, "!": [dt, [dt], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [dt, [ft], (t2, [e2]) => {
          let r2 = t2.globals && t2.globals.isSupportedScript;
          return !r2 || r2(e2.evaluate(t2));
        }], upcase: [ft, [ft], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ft, [ft], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ft, gr(gt), (t2, e2) => e2.map((e3) => jt(e3.evaluate(t2))).join("")], "resolved-locale": [ft, [xt], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
        class Vr {
          constructor(t2, e2) {
            this.expression = t2, this._warningHistory = {}, this._evaluator = new Ht(), this._defaultValue = e2 ? function(t3) {
              return t3.type === "color" && kr(t3.default) ? new Ft(0, 0, 0, 0) : t3.type === "color" ? Ft.parse(t3.default) || null : t3.type === "padding" ? $t.parse(t3.default) || null : t3.default === void 0 ? null : t3.default;
            }(e2) : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e2, r2, n2, i2, a2) {
            this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2 || null;
            try {
              let t3 = this.expression.evaluate(this._evaluator);
              if (t3 == null || typeof t3 == "number" && t3 != t3)
                return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues))
                throw new Zt(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
              return t3;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = !0, typeof console < "u" && console.warn(t3.message)), this._defaultValue;
            }
          }
        }
        function Er(t2) {
          return Array.isArray(t2) && t2.length > 0 && typeof t2[0] == "string" && t2[0] in fr;
        }
        function Fr(t2, e2) {
          let r2 = new we(fr, [], e2 ? function(t3) {
            let e3 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, padding: bt, resolvedImage: wt };
            return t3.type === "array" ? _t(e3[t3.value] || gt, t3.length) : e3[t3.type];
          }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? xr(new Vr(n2, e2)) : vr(r2.errors);
        }
        class Tr {
          constructor(t2, e2) {
            this.kind = t2, this._styleExpression = e2, this.isStateDependent = t2 !== "constant" && !xe(e2.expression);
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2);
          }
          evaluate(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, a2);
          }
        }
        class Lr {
          constructor(t2, e2, r2, n2) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = t2 !== "camera" && !xe(e2.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2);
          }
          evaluate(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, a2);
          }
          interpolationFactor(t2, e2, r2) {
            return this.interpolationType ? Ne.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
          }
        }
        function Dr(t2, e2) {
          let r2 = Fr(t2, e2);
          if (r2.result === "error")
            return r2;
          let n2 = r2.value.expression, i2 = ge(n2);
          if (!i2 && !br(e2))
            return vr([new ut("", "data expressions not supported")]);
          let a2 = ve(n2, ["zoom"]);
          if (!a2 && !wr(e2))
            return vr([new ut("", "zoom expressions not supported")]);
          let s2 = Rr(n2);
          return s2 || a2 ? s2 instanceof ut ? vr([s2]) : s2 instanceof Ne && !_r(e2) ? vr([new ut("", '"interpolate" expressions cannot be used with this property')]) : xr(s2 ? new Lr(i2 ? "camera" : "composite", r2.value, s2.labels, s2 instanceof Ne ? s2.interpolation : void 0) : new Tr(i2 ? "constant" : "source", r2.value)) : vr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class $r {
          constructor(t2, e2) {
            this._parameters = t2, this._specification = e2, st(this, Ir(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new $r(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function Rr(t2) {
          let e2 = null;
          if (t2 instanceof Ge)
            e2 = Rr(t2.result);
          else if (t2 instanceof Ke) {
            for (let r2 of t2.args)
              if (e2 = Rr(r2), e2)
                break;
          } else
            (t2 instanceof ke || t2 instanceof Ne) && t2.input instanceof Wt && t2.input.name === "zoom" && (e2 = t2);
          return e2 instanceof ut || t2.eachChild((t3) => {
            let r2 = Rr(t3);
            r2 instanceof ut ? e2 = r2 : !e2 && r2 ? e2 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        function Or(t2) {
          let e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, a2 = t2.style, s2 = t2.styleSpec, o2 = [], l2 = Ar(r2);
          if (l2 !== "object")
            return [new it(e2, r2, `object expected, ${l2} found`)];
          for (let t3 in r2) {
            let l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"], c2;
            if (i2[l3])
              c2 = i2[l3];
            else if (n2[l3])
              c2 = yn;
            else if (i2["*"])
              c2 = i2["*"];
            else {
              if (!n2["*"]) {
                o2.push(new it(e2, r2[t3], `unknown property "${t3}"`));
                continue;
              }
              c2 = yn;
            }
            o2 = o2.concat(c2({ key: (e2 && `${e2}.`) + t3, value: r2[t3], valueSpec: u2, style: a2, styleSpec: s2, object: r2, objectKey: t3 }, r2));
          }
          for (let t3 in n2)
            i2[t3] || n2[t3].required && n2[t3].default === void 0 && r2[t3] === void 0 && o2.push(new it(e2, r2, `missing required property "${t3}"`));
          return o2;
        }
        function Ur(t2) {
          let e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.key, s2 = t2.arrayElementValidator || yn;
          if (Ar(e2) !== "array")
            return [new it(a2, e2, `array expected, ${Ar(e2)} found`)];
          if (r2.length && e2.length !== r2.length)
            return [new it(a2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
          if (r2["min-length"] && e2.length < r2["min-length"])
            return [new it(a2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
          let o2 = { type: r2.value, values: r2.values };
          i2.$version < 7 && (o2.function = r2.function), Ar(r2.value) === "object" && (o2 = r2.value);
          let l2 = [];
          for (let t3 = 0; t3 < e2.length; t3++)
            l2 = l2.concat(s2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${a2}[${t3}]` }));
          return l2;
        }
        function qr(t2) {
          let e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = Ar(r2);
          return i2 === "number" && r2 != r2 && (i2 = "NaN"), i2 !== "number" ? [new it(e2, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new it(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new it(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
        }
        function jr(t2) {
          let e2 = t2.valueSpec, r2 = ot(t2.value.type), n2, i2, a2, s2 = {}, o2 = r2 !== "categorical" && t2.value.property === void 0, l2 = !o2, u2 = Ar(t2.value.stops) === "array" && Ar(t2.value.stops[0]) === "array" && Ar(t2.value.stops[0][0]) === "object", c2 = Or({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if (r2 === "identity")
              return [new it(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let e3 = [], n3 = t3.value;
            return e3 = e3.concat(Ur({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), Ar(n3) === "array" && n3.length === 0 && e3.push(new it(t3.key, n3, "array must have at least one stop")), e3;
          }, default: function(t3) {
            return yn({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return r2 === "identity" && o2 && c2.push(new it(t2.key, t2.value, 'missing required property "property"')), r2 === "identity" || t2.value.stops || c2.push(new it(t2.key, t2.value, 'missing required property "stops"')), r2 === "exponential" && t2.valueSpec.expression && !_r(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !br(t2.valueSpec) ? c2.push(new it(t2.key, t2.value, "property functions not supported")) : o2 && !wr(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "zoom functions not supported"))), r2 !== "categorical" && !u2 || t2.value.property !== void 0 || c2.push(new it(t2.key, t2.value, '"property" property is required')), c2;
          function h2(t3) {
            let r3 = [], n3 = t3.value, o3 = t3.key;
            if (Ar(n3) !== "array")
              return [new it(o3, n3, `array expected, ${Ar(n3)} found`)];
            if (n3.length !== 2)
              return [new it(o3, n3, `array length 2 expected, length ${n3.length} found`)];
            if (u2) {
              if (Ar(n3[0]) !== "object")
                return [new it(o3, n3, `object expected, ${Ar(n3[0])} found`)];
              if (n3[0].zoom === void 0)
                return [new it(o3, n3, "object stop key must have zoom")];
              if (n3[0].value === void 0)
                return [new it(o3, n3, "object stop key must have value")];
              if (a2 && a2 > ot(n3[0].zoom))
                return [new it(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              ot(n3[0].zoom) !== a2 && (a2 = ot(n3[0].zoom), i2 = void 0, s2 = {}), r3 = r3.concat(Or({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: qr, value: p2 } }));
            } else
              r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
            return Er(lt(n3[1])) ? r3.concat([new it(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(yn({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function p2(t3, a3) {
            let o3 = Ar(t3.value), l3 = ot(t3.value), u3 = t3.value !== null ? t3.value : a3;
            if (n2) {
              if (o3 !== n2)
                return [new it(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else
              n2 = o3;
            if (o3 !== "number" && o3 !== "string" && o3 !== "boolean")
              return [new it(t3.key, u3, "stop domain value must be a number, string, or boolean")];
            if (o3 !== "number" && r2 !== "categorical") {
              let n3 = `number expected, ${o3} found`;
              return br(e2) && r2 === void 0 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new it(t3.key, u3, n3)];
            }
            return r2 !== "categorical" || o3 !== "number" || isFinite(l3) && Math.floor(l3) === l3 ? r2 !== "categorical" && o3 === "number" && i2 !== void 0 && l3 < i2 ? [new it(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, r2 === "categorical" && l3 in s2 ? [new it(t3.key, u3, "stop domain values must be unique")] : (s2[l3] = !0, [])) : [new it(t3.key, u3, `integer expected, found ${l3}`)];
          }
        }
        function Nr(t2) {
          let e2 = (t2.expressionContext === "property" ? Dr : Fr)(lt(t2.value), t2.valueSpec);
          if (e2.result === "error")
            return e2.value.map((e3) => new it(`${t2.key}${e3.key}`, t2.value, e3.message));
          let r2 = e2.value.expression || e2.value._styleExpression.expression;
          if (t2.expressionContext === "property" && t2.propertyKey === "text-font" && !r2.outputDefined())
            return [new it(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (t2.expressionContext === "property" && t2.propertyType === "layout" && !xe(r2))
            return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (t2.expressionContext === "filter" && !xe(r2))
            return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
          if (t2.expressionContext && t2.expressionContext.indexOf("cluster") === 0) {
            if (!ve(r2, ["zoom", "feature-state"]))
              return [new it(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (t2.expressionContext === "cluster-initial" && !ge(r2))
              return [new it(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Zr(t2) {
          let e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
          return Array.isArray(n2.values) ? n2.values.indexOf(ot(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : Object.keys(n2.values).indexOf(ot(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
        }
        function Kr(t2) {
          if (t2 === !0 || t2 === !1)
            return !0;
          if (!Array.isArray(t2) || t2.length === 0)
            return !1;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && t2[1] !== "$id" && t2[1] !== "$type";
            case "in":
              return t2.length >= 3 && (typeof t2[1] != "string" || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return t2.length !== 3 || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (let e2 of t2.slice(1))
                if (!Kr(e2) && typeof e2 != "boolean")
                  return !1;
              return !0;
            default:
              return !0;
          }
        }
        let Gr = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function Jr(t2) {
          if (t2 == null)
            return { filter: () => !0, needGeometry: !1 };
          Kr(t2) || (t2 = Hr(t2));
          let e2 = Fr(t2, Gr);
          if (e2.result === "error")
            throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
          return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: Yr(t2) };
        }
        function Xr(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Yr(t2) {
          if (!Array.isArray(t2))
            return !1;
          if (t2[0] === "within")
            return !0;
          for (let e2 = 1; e2 < t2.length; e2++)
            if (Yr(t2[e2]))
              return !0;
          return !1;
        }
        function Hr(t2) {
          if (!t2)
            return !0;
          let e2 = t2[0];
          return t2.length <= 1 ? e2 !== "any" : e2 === "==" ? Wr(t2[1], t2[2], "==") : e2 === "!=" ? en(Wr(t2[1], t2[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? Wr(t2[1], t2[2], e2) : e2 === "any" ? (r2 = t2.slice(1), ["any"].concat(r2.map(Hr))) : e2 === "all" ? ["all"].concat(t2.slice(1).map(Hr)) : e2 === "none" ? ["all"].concat(t2.slice(1).map(Hr).map(en)) : e2 === "in" ? Qr(t2[1], t2.slice(2)) : e2 === "!in" ? en(Qr(t2[1], t2.slice(2))) : e2 === "has" ? tn(t2[1]) : e2 === "!has" ? en(tn(t2[1])) : e2 !== "within" || t2;
          var r2;
        }
        function Wr(t2, e2, r2) {
          switch (t2) {
            case "$type":
              return [`filter-type-${r2}`, e2];
            case "$id":
              return [`filter-id-${r2}`, e2];
            default:
              return [`filter-${r2}`, t2, e2];
          }
        }
        function Qr(t2, e2) {
          if (e2.length === 0)
            return !1;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Xr)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function tn(t2) {
          switch (t2) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function en(t2) {
          return ["!", t2];
        }
        function rn(t2) {
          return Kr(lt(t2.value)) ? Nr(st({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : nn(t2);
        }
        function nn(t2) {
          let e2 = t2.value, r2 = t2.key;
          if (Ar(e2) !== "array")
            return [new it(r2, e2, `array expected, ${Ar(e2)} found`)];
          let n2 = t2.styleSpec, i2, a2 = [];
          if (e2.length < 1)
            return [new it(r2, e2, "filter array must have at least 1 element")];
          switch (a2 = a2.concat(Zr({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), ot(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && ot(e2[1]) === "$type" && a2.push(new it(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
            case "==":
            case "!=":
              e2.length !== 3 && a2.push(new it(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e2.length >= 2 && (i2 = Ar(e2[1]), i2 !== "string" && a2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
              for (let s2 = 2; s2 < e2.length; s2++)
                i2 = Ar(e2[s2]), ot(e2[1]) === "$type" ? a2 = a2.concat(Zr({ key: `${r2}[${s2}]`, value: e2[s2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && a2.push(new it(`${r2}[${s2}]`, e2[s2], `string, number, or boolean expected, ${i2} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e2.length; n3++)
                a2 = a2.concat(nn({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = Ar(e2[1]), e2.length !== 2 ? a2.push(new it(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && a2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
              break;
            case "within":
              i2 = Ar(e2[1]), e2.length !== 2 ? a2.push(new it(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "object" && a2.push(new it(`${r2}[1]`, e2[1], `object expected, ${i2} found`));
          }
          return a2;
        }
        function an(t2, e2) {
          let r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.value, s2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
          if (!o2)
            return [];
          let l2 = s2.match(/^(.*)-transition$/);
          if (e2 === "paint" && l2 && o2[l2[1]] && o2[l2[1]].transition)
            return yn({ key: r2, value: a2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
          let u2 = t2.valueSpec || o2[s2];
          if (!u2)
            return [new it(r2, a2, `unknown property "${s2}"`)];
          let c2;
          if (Ar(a2) === "string" && br(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(a2)))
            return [new it(r2, a2, `"${s2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
          let h2 = [];
          return t2.layerType === "symbol" && (s2 === "text-field" && n2 && !n2.glyphs && h2.push(new it(r2, a2, 'use of "text-field" requires a style "glyphs" property')), s2 === "text-font" && kr(lt(a2)) && ot(a2.type) === "identity" && h2.push(new it(r2, a2, '"text-font" does not support identity functions'))), h2.concat(yn({ key: t2.key, value: a2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: s2 }));
        }
        function sn(t2) {
          return an(t2, "paint");
        }
        function on(t2) {
          return an(t2, "layout");
        }
        function ln(t2) {
          let e2 = [], r2 = t2.value, n2 = t2.key, i2 = t2.style, a2 = t2.styleSpec;
          r2.type || r2.ref || e2.push(new it(n2, r2, 'either "type" or "ref" is required'));
          let s2 = ot(r2.type), o2 = ot(r2.ref);
          if (r2.id) {
            let a3 = ot(r2.id);
            for (let s3 = 0; s3 < t2.arrayIndex; s3++) {
              let t3 = i2.layers[s3];
              ot(t3.id) === a3 && e2.push(new it(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
            }
          }
          if ("ref" in r2) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
              t4 in r2 && e2.push(new it(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
            }), i2.layers.forEach((e3) => {
              ot(e3.id) === o2 && (t3 = e3);
            }), t3 ? t3.ref ? e2.push(new it(n2, r2.ref, "ref cannot reference another ref layer")) : s2 = ot(t3.type) : e2.push(new it(n2, r2.ref, `ref layer "${o2}" not found`));
          } else if (s2 !== "background")
            if (r2.source) {
              let t3 = i2.sources && i2.sources[r2.source], a3 = t3 && ot(t3.type);
              t3 ? a3 === "vector" && s2 === "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : a3 === "raster" && s2 !== "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : a3 !== "vector" || r2["source-layer"] ? a3 === "raster-dem" && s2 !== "hillshade" ? e2.push(new it(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : s2 !== "line" || !r2.paint || !r2.paint["line-gradient"] || a3 === "geojson" && t3.lineMetrics || e2.push(new it(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new it(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new it(n2, r2.source, `source "${r2.source}" not found`));
            } else
              e2.push(new it(n2, r2, 'missing required property "source"'));
          return e2 = e2.concat(Or({ key: n2, value: r2, valueSpec: a2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => yn({ key: `${n2}.type`, value: r2.type, valueSpec: a2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: rn, layout: (t3) => Or({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => on(st({ layerType: s2 }, t4)) } }), paint: (t3) => Or({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => sn(st({ layerType: s2 }, t4)) } }) } })), e2;
        }
        function un(t2) {
          let e2 = t2.value, r2 = t2.key, n2 = Ar(e2);
          return n2 !== "string" ? [new it(r2, e2, `string expected, ${n2} found`)] : [];
        }
        let cn = { promoteId: function({ key: t2, value: e2 }) {
          if (Ar(e2) === "string")
            return un({ key: t2, value: e2 });
          {
            let r2 = [];
            for (let n2 in e2)
              r2.push(...un({ key: `${t2}.${n2}`, value: e2[n2] }));
            return r2;
          }
        } };
        function hn(t2) {
          let e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
          if (!e2.type)
            return [new it(r2, e2, '"type" is required')];
          let a2 = ot(e2.type), s2;
          switch (a2) {
            case "vector":
            case "raster":
            case "raster-dem":
              return s2 = Or({ key: r2, value: e2, valueSpec: n2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: cn }), s2;
            case "geojson":
              if (s2 = Or({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: cn }), e2.cluster)
                for (let t3 in e2.clusterProperties) {
                  let [n3, i3] = e2.clusterProperties[t3], a3 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t3]] : n3;
                  s2.push(...Nr({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), s2.push(...Nr({ key: `${r2}.${t3}.reduce`, value: a3, expressionContext: "cluster-reduce" }));
                }
              return s2;
            case "video":
              return Or({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
            case "image":
              return Or({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
            case "canvas":
              return [new it(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Zr({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
          }
        }
        function pn(t2) {
          let e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style, a2 = [], s2 = Ar(e2);
          if (e2 === void 0)
            return a2;
          if (s2 !== "object")
            return a2 = a2.concat([new it("light", e2, `object expected, ${s2} found`)]), a2;
          for (let t3 in e2) {
            let s3 = t3.match(/^(.*)-transition$/);
            a2 = a2.concat(s3 && n2[s3[1]] && n2[s3[1]].transition ? yn({ key: t3, value: e2[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? yn({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new it(t3, e2[t3], `unknown property "${t3}"`)]);
          }
          return a2;
        }
        function fn(t2) {
          let e2 = t2.value, r2 = t2.styleSpec, n2 = r2.terrain, i2 = t2.style, a2 = [], s2 = Ar(e2);
          if (e2 === void 0)
            return a2;
          if (s2 !== "object")
            return a2 = a2.concat([new it("terrain", e2, `object expected, ${s2} found`)]), a2;
          for (let t3 in e2)
            a2 = a2.concat(n2[t3] ? yn({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new it(t3, e2[t3], `unknown property "${t3}"`)]);
          return a2;
        }
        let dn = { "*": () => [], array: Ur, boolean: function(t2) {
          let e2 = t2.value, r2 = t2.key, n2 = Ar(e2);
          return n2 !== "boolean" ? [new it(r2, e2, `boolean expected, ${n2} found`)] : [];
        }, number: qr, color: function(t2) {
          let e2 = t2.key, r2 = t2.value, n2 = Ar(r2);
          return n2 !== "string" ? [new it(e2, r2, `color expected, ${n2} found`)] : zt(r2) === null ? [new it(e2, r2, `color expected, "${r2}" found`)] : [];
        }, constants: at, enum: Zr, filter: rn, function: jr, layer: ln, object: Or, source: hn, light: pn, terrain: fn, string: un, formatted: function(t2) {
          return un(t2).length === 0 ? [] : Nr(t2);
        }, resolvedImage: function(t2) {
          return un(t2).length === 0 ? [] : Nr(t2);
        }, padding: function(t2) {
          let e2 = t2.key, r2 = t2.value;
          if (Ar(r2) === "array") {
            if (r2.length < 1 || r2.length > 4)
              return [new it(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
            let t3 = { type: "number" }, n2 = [];
            for (let i2 = 0; i2 < r2.length; i2++)
              n2 = n2.concat(yn({ key: `${e2}[${i2}]`, value: r2[i2], valueSpec: t3 }));
            return n2;
          }
          return qr({ key: e2, value: r2, valueSpec: {} });
        } };
        function yn(t2) {
          let e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
          return r2.expression && kr(ot(e2)) ? jr(t2) : r2.expression && Er(lt(e2)) ? Nr(t2) : r2.type && dn[r2.type] ? dn[r2.type](t2) : Or(st({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function mn(t2) {
          let e2 = t2.value, r2 = t2.key, n2 = un(t2);
          return n2.length || (e2.indexOf("{fontstack}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function gn(t2, e2 = nt) {
          let r2 = [];
          return r2 = r2.concat(yn({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: mn, "*": () => [] } })), t2.constants && (r2 = r2.concat(at({ key: "constants", value: t2.constants, style: t2, styleSpec: e2 }))), xn(r2);
        }
        function xn(t2) {
          return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
        }
        function vn(t2) {
          return function(...e2) {
            return xn(t2.apply(this, e2));
          };
        }
        gn.source = vn(hn), gn.light = vn(pn), gn.terrain = vn(fn), gn.layer = vn(ln), gn.filter = vn(rn), gn.paintProperty = vn(sn), gn.layoutProperty = vn(on);
        let bn = gn, wn = bn.light, _n = bn.paintProperty, An = bn.layoutProperty;
        function kn(t2, e2) {
          let r2 = !1;
          if (e2 && e2.length)
            for (let n2 of e2)
              t2.fire(new et(new Error(n2.message))), r2 = !0;
          return r2;
        }
        class Sn {
          constructor(t2, e2, r2) {
            let n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              let i3 = new Int32Array(this.arrayBuffer);
              t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
              for (let t3 = 0; t3 < this.d * this.d; t3++) {
                let e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
              }
              let a2 = i3[3 + n2.length + 1];
              this.keys = i3.subarray(i3[3 + n2.length], a2), this.bboxes = i3.subarray(a2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r2;
              for (let t3 = 0; t3 < this.d * this.d; t3++)
                n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
            let i2 = r2 / e2 * t2;
            this.min = -i2, this.max = t2 + i2;
          }
          insert(t2, e2, r2, n2, i2) {
            this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t2, e2, r2, n2, i2, a2) {
            this.cells[i2].push(a2);
          }
          query(t2, e2, r2, n2, i2) {
            let a2 = this.min, s2 = this.max;
            if (t2 <= a2 && e2 <= a2 && s2 <= r2 && s2 <= n2 && !i2)
              return Array.prototype.slice.call(this.keys);
            {
              let a3 = [];
              return this._forEachCell(t2, e2, r2, n2, this._queryCell, a3, {}, i2), a3;
            }
          }
          _queryCell(t2, e2, r2, n2, i2, a2, s2, o2) {
            let l2 = this.cells[i2];
            if (l2 !== null) {
              let i3 = this.keys, u2 = this.bboxes;
              for (let c2 = 0; c2 < l2.length; c2++) {
                let h2 = l2[c2];
                if (s2[h2] === void 0) {
                  let l3 = 4 * h2;
                  (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (s2[h2] = !0, a2.push(i3[h2])) : s2[h2] = !1;
                }
              }
            }
          }
          _forEachCell(t2, e2, r2, n2, i2, a2, s2, o2) {
            let l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
            for (let p2 = l2; p2 <= c2; p2++)
              for (let l3 = u2; l3 <= h2; l3++) {
                let u3 = this.d * l3 + p2;
                if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e2, r2, n2, u3, a2, s2, o2))
                  return;
              }
          }
          _convertFromCellCoord(t2) {
            return (t2 - this.padding) / this.scale;
          }
          _convertToCellCoord(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            let t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0;
            for (let t3 = 0; t3 < this.cells.length; t3++)
              r2 += this.cells[t3].length;
            let n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
            n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
            let i2 = e2;
            for (let e3 = 0; e3 < t2.length; e3++) {
              let r3 = t2[e3];
              n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
            }
            return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
          }
          static serialize(t2, e2) {
            let r2 = t2.toArrayBuffer();
            return e2 && e2.push(r2), { buffer: r2 };
          }
          static deserialize(t2) {
            return new Sn(t2.buffer);
          }
        }
        let In = {};
        function Mn(t2, e2, r2 = {}) {
          if (In[t2])
            throw new Error(`${t2} is already registered.`);
          Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: !1 }), In[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        Mn("Object", Object), Mn("TransferableGridIndex", Sn), Mn("Color", Ft), Mn("Error", Error), Mn("AJAXError", q), Mn("ResolvedImage", Rt), Mn("StylePropertyFunction", $r), Mn("StyleExpression", Vr, { omit: ["_evaluator"] }), Mn("ZoomDependentExpression", Lr), Mn("ZoomConstantExpression", Tr), Mn("CompoundExpression", Wt, { omit: ["_evaluate"] });
        for (let t2 in fr)
          fr[t2]._classRegistryKey || Mn(`Expression_${t2}`, fr[t2]);
        function zn(t2) {
          return t2 && typeof ArrayBuffer < "u" && (t2 instanceof ArrayBuffer || t2.constructor && t2.constructor.name === "ArrayBuffer");
        }
        function Bn(t2, e2) {
          if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob)
            return t2;
          if (zn(t2) || A(t2))
            return e2 && e2.push(t2), t2;
          if (ArrayBuffer.isView(t2)) {
            let r2 = t2;
            return e2 && e2.push(r2.buffer), r2;
          }
          if (t2 instanceof ImageData)
            return e2 && e2.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            let r2 = [];
            for (let n2 of t2)
              r2.push(Bn(n2, e2));
            return r2;
          }
          if (typeof t2 == "object") {
            let r2 = t2.constructor, n2 = r2._classRegistryKey;
            if (!n2)
              throw new Error("can't serialize object of unregistered class");
            if (!In[n2])
              throw new Error(`${n2} is not registered.`);
            let i2 = r2.serialize ? r2.serialize(t2, e2) : {};
            if (r2.serialize) {
              if (e2 && i2 === e2[e2.length - 1])
                throw new Error("statically serialized object won't survive transfer of $name property");
            } else {
              for (let r3 in t2) {
                if (!t2.hasOwnProperty(r3) || In[n2].omit.indexOf(r3) >= 0)
                  continue;
                let a2 = t2[r3];
                i2[r3] = In[n2].shallow.indexOf(r3) >= 0 ? a2 : Bn(a2, e2);
              }
              t2 instanceof Error && (i2.message = t2.message);
            }
            if (i2.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return n2 !== "Object" && (i2.$name = n2), i2;
          }
          throw new Error("can't serialize object of type " + typeof t2);
        }
        function Cn(t2) {
          if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || zn(t2) || A(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData)
            return t2;
          if (Array.isArray(t2))
            return t2.map(Cn);
          if (typeof t2 == "object") {
            let e2 = t2.$name || "Object";
            if (!In[e2])
              throw new Error(`can't deserialize unregistered class ${e2}`);
            let { klass: r2 } = In[e2];
            if (!r2)
              throw new Error(`can't deserialize unregistered class ${e2}`);
            if (r2.deserialize)
              return r2.deserialize(t2);
            let n2 = Object.create(r2.prototype);
            for (let r3 of Object.keys(t2)) {
              if (r3 === "$name")
                continue;
              let i2 = t2[r3];
              n2[r3] = In[e2].shallow.indexOf(r3) >= 0 ? i2 : Cn(i2);
            }
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t2);
        }
        class Pn {
          constructor() {
            this.first = !0;
          }
          update(t2, e2) {
            let r2 = Math.floor(t2);
            return this.first ? (this.first = !1, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, !0) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, !0));
          }
        }
        let Vn = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
        function En(t2) {
          for (let e2 of t2)
            if (Ln(e2.charCodeAt(0)))
              return !0;
          return !1;
        }
        function Fn(t2) {
          for (let e2 of t2)
            if (!Tn(e2.charCodeAt(0)))
              return !1;
          return !0;
        }
        function Tn(t2) {
          return !(Vn.Arabic(t2) || Vn["Arabic Supplement"](t2) || Vn["Arabic Extended-A"](t2) || Vn["Arabic Presentation Forms-A"](t2) || Vn["Arabic Presentation Forms-B"](t2));
        }
        function Ln(t2) {
          return !(t2 !== 746 && t2 !== 747 && (t2 < 4352 || !(Vn["Bopomofo Extended"](t2) || Vn.Bopomofo(t2) || Vn["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Vn["CJK Compatibility Ideographs"](t2) || Vn["CJK Compatibility"](t2) || Vn["CJK Radicals Supplement"](t2) || Vn["CJK Strokes"](t2) || !(!Vn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || t2 === 12336) || Vn["CJK Unified Ideographs Extension A"](t2) || Vn["CJK Unified Ideographs"](t2) || Vn["Enclosed CJK Letters and Months"](t2) || Vn["Hangul Compatibility Jamo"](t2) || Vn["Hangul Jamo Extended-A"](t2) || Vn["Hangul Jamo Extended-B"](t2) || Vn["Hangul Jamo"](t2) || Vn["Hangul Syllables"](t2) || Vn.Hiragana(t2) || Vn["Ideographic Description Characters"](t2) || Vn.Kanbun(t2) || Vn["Kangxi Radicals"](t2) || Vn["Katakana Phonetic Extensions"](t2) || Vn.Katakana(t2) && t2 !== 12540 || !(!Vn["Halfwidth and Fullwidth Forms"](t2) || t2 === 65288 || t2 === 65289 || t2 === 65293 || t2 >= 65306 && t2 <= 65310 || t2 === 65339 || t2 === 65341 || t2 === 65343 || t2 >= 65371 && t2 <= 65503 || t2 === 65507 || t2 >= 65512 && t2 <= 65519) || !(!Vn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Vn["Unified Canadian Aboriginal Syllabics"](t2) || Vn["Unified Canadian Aboriginal Syllabics Extended"](t2) || Vn["Vertical Forms"](t2) || Vn["Yijing Hexagram Symbols"](t2) || Vn["Yi Syllables"](t2) || Vn["Yi Radicals"](t2))));
        }
        function Dn(t2) {
          return !(Ln(t2) || function(t3) {
            return !!(Vn["Latin-1 Supplement"](t3) && (t3 === 167 || t3 === 169 || t3 === 174 || t3 === 177 || t3 === 188 || t3 === 189 || t3 === 190 || t3 === 215 || t3 === 247) || Vn["General Punctuation"](t3) && (t3 === 8214 || t3 === 8224 || t3 === 8225 || t3 === 8240 || t3 === 8241 || t3 === 8251 || t3 === 8252 || t3 === 8258 || t3 === 8263 || t3 === 8264 || t3 === 8265 || t3 === 8273) || Vn["Letterlike Symbols"](t3) || Vn["Number Forms"](t3) || Vn["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || t3 === 9003 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || t3 === 9167 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Vn["Control Pictures"](t3) && t3 !== 9251 || Vn["Optical Character Recognition"](t3) || Vn["Enclosed Alphanumerics"](t3) || Vn["Geometric Shapes"](t3) || Vn["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Vn["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Vn["CJK Symbols and Punctuation"](t3) || Vn.Katakana(t3) || Vn["Private Use Area"](t3) || Vn["CJK Compatibility Forms"](t3) || Vn["Small Form Variants"](t3) || Vn["Halfwidth and Fullwidth Forms"](t3) || t3 === 8734 || t3 === 8756 || t3 === 8757 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || t3 === 65532 || t3 === 65533);
          }(t2));
        }
        function $n(t2) {
          return t2 >= 1424 && t2 <= 2303 || Vn["Arabic Presentation Forms-A"](t2) || Vn["Arabic Presentation Forms-B"](t2);
        }
        function Rn(t2, e2) {
          return !(!e2 && $n(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Vn.Khmer(t2));
        }
        function On(t2) {
          for (let e2 of t2)
            if ($n(e2.charCodeAt(0)))
              return !0;
          return !1;
        }
        let Un = "deferred", qn = "loading", jn = "loaded", Nn = null, Zn = "unavailable", Kn = null, Gn = function(t2) {
          t2 && typeof t2 == "string" && t2.indexOf("NetworkError") > -1 && (Zn = "error"), Nn && Nn(t2);
        };
        function Jn() {
          Xn.fire(new tt("pluginStateChange", { pluginStatus: Zn, pluginURL: Kn }));
        }
        let Xn = new rt(), Yn = function() {
          return Zn;
        }, Hn = function() {
          if (Zn !== Un || !Kn)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Zn = qn, Jn(), Kn && K({ url: Kn }, (t2) => {
            t2 ? Gn(t2) : (Zn = jn, Jn());
          });
        }, Wn = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Zn === jn || Wn.applyArabicShaping != null, isLoading: () => Zn === qn, setState(t2) {
          if (!g())
            throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
          Zn = t2.pluginStatus, Kn = t2.pluginURL;
        }, isParsed() {
          if (!g())
            throw new Error("rtl-text-plugin is only parsed on the worker-threads");
          return Wn.applyArabicShaping != null && Wn.processBidirectionalText != null && Wn.processStyledBidirectionalText != null;
        }, getPluginURL() {
          if (!g())
            throw new Error("rtl-text-plugin url can only be queried from the worker threads");
          return Kn;
        } };
        class Qn {
          constructor(t2, e2) {
            this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Pn(), this.transition = {});
          }
          isSupportedScript(t2) {
            return function(t3, e2) {
              for (let r2 of t3)
                if (!Rn(r2.charCodeAt(0), e2))
                  return !1;
              return !0;
            }(t2, Wn.isLoaded());
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            let t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
            return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
          }
        }
        class ti {
          constructor(t2, e2) {
            this.property = t2, this.value = e2, this.expression = function(t3, e3) {
              if (kr(t3))
                return new $r(t3, e3);
              if (Er(t3)) {
                let r2 = Dr(t3, e3);
                if (r2.result === "error")
                  throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                return r2.value;
              }
              {
                let r2 = t3;
                return e3.type === "color" && typeof t3 == "string" ? r2 = Ft.parse(t3) : e3.type !== "padding" || typeof t3 != "number" && !Array.isArray(t3) || (r2 = $t.parse(t3)), { kind: "constant", evaluate: () => r2 };
              }
            }(e2 === void 0 ? t2.specification.default : e2, t2.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          possiblyEvaluate(t2, e2, r2) {
            return this.property.possiblyEvaluate(this, t2, e2, r2);
          }
        }
        class ei {
          constructor(t2) {
            this.property = t2, this.value = new ti(t2, void 0);
          }
          transitioned(t2, e2) {
            return new ni(this.property, this.value, e2, o({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new ni(this.property, this.value, null, {}, 0);
          }
        }
        class ri {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
          }
          getValue(t2) {
            return p(this._values[t2].value.value);
          }
          setValue(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new ei(this._values[t2].property)), this._values[t2].value = new ti(this._values[t2].property, e2 === null ? void 0 : p(e2));
          }
          getTransition(t2) {
            return p(this._values[t2].transition);
          }
          setTransition(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new ei(this._values[t2].property)), this._values[t2].transition = p(e2) || void 0;
          }
          serialize() {
            let t2 = {};
            for (let e2 of Object.keys(this._values)) {
              let r2 = this.getValue(e2);
              r2 !== void 0 && (t2[e2] = r2);
              let n2 = this.getTransition(e2);
              n2 !== void 0 && (t2[`${e2}-transition`] = n2);
            }
            return t2;
          }
          transitioned(t2, e2) {
            let r2 = new ii(this._properties);
            for (let n2 of Object.keys(this._values))
              r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
            return r2;
          }
          untransitioned() {
            let t2 = new ii(this._properties);
            for (let e2 of Object.keys(this._values))
              t2._values[e2] = this._values[e2].untransitioned();
            return t2;
          }
        }
        class ni {
          constructor(t2, e2, r2, n2, i2) {
            this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t2, e2, r2) {
            let n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), a2 = this.prior;
            if (a2) {
              if (n2 > this.end)
                return this.prior = null, i2;
              if (this.value.isDataDriven())
                return this.prior = null, i2;
              if (n2 < this.begin)
                return a2.possiblyEvaluate(t2, e2, r2);
              {
                let s2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(a2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
                  if (t3 <= 0)
                    return 0;
                  if (t3 >= 1)
                    return 1;
                  let e3 = t3 * t3, r3 = e3 * t3;
                  return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
                }(s2));
              }
            }
            return i2;
          }
        }
        class ii {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e2, r2) {
            let n2 = new oi(this._properties);
            for (let i2 of Object.keys(this._values))
              n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
          hasTransition() {
            for (let t2 of Object.keys(this._values))
              if (this._values[t2].prior)
                return !0;
            return !1;
          }
        }
        class ai {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
          }
          getValue(t2) {
            return p(this._values[t2].value);
          }
          setValue(t2, e2) {
            this._values[t2] = new ti(this._values[t2].property, e2 === null ? void 0 : p(e2));
          }
          serialize() {
            let t2 = {};
            for (let e2 of Object.keys(this._values)) {
              let r2 = this.getValue(e2);
              r2 !== void 0 && (t2[e2] = r2);
            }
            return t2;
          }
          possiblyEvaluate(t2, e2, r2) {
            let n2 = new oi(this._properties);
            for (let i2 of Object.keys(this._values))
              n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
        }
        class si {
          constructor(t2, e2, r2) {
            this.property = t2, this.value = e2, this.parameters = r2;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t2) {
            return this.value.kind === "constant" ? this.value.value : t2;
          }
          evaluate(t2, e2, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
          }
        }
        class oi {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class li {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            if (t2.isDataDriven())
              throw new Error("Value should not be data driven");
            return t2.expression.evaluate(e2);
          }
          interpolate(t2, e2, r2) {
            let n2 = Ie[this.specification.type];
            return n2 ? n2(t2, e2, r2) : t2;
          }
        }
        class ui {
          constructor(t2, e2) {
            this.specification = t2, this.overrides = e2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return new si(this, t2.expression.kind === "constant" || t2.expression.kind === "camera" ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
          }
          interpolate(t2, e2, r2) {
            if (t2.value.kind !== "constant" || e2.value.kind !== "constant")
              return t2;
            if (t2.value.value === void 0 || e2.value.value === void 0)
              return new si(this, { kind: "constant", value: void 0 }, t2.parameters);
            let n2 = Ie[this.specification.type];
            return n2 ? new si(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
          }
          evaluate(t2, e2, r2, n2, i2, a2) {
            return t2.kind === "constant" ? t2.value : t2.evaluate(e2, r2, n2, i2, a2);
          }
        }
        class ci extends ui {
          possiblyEvaluate(t2, e2, r2, n2) {
            if (t2.value === void 0)
              return new si(this, { kind: "constant", value: void 0 }, e2);
            if (t2.expression.kind === "constant") {
              let i2 = t2.expression.evaluate(e2, null, {}, r2, n2), a2 = t2.property.specification.type === "resolvedImage" && typeof i2 != "string" ? i2.name : i2, s2 = this._calculate(a2, a2, a2, e2);
              return new si(this, { kind: "constant", value: s2 }, e2);
            }
            if (t2.expression.kind === "camera") {
              let r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
              return new si(this, { kind: "constant", value: r3 }, e2);
            }
            return new si(this, t2.expression, e2);
          }
          evaluate(t2, e2, r2, n2, i2, a2) {
            if (t2.kind === "source") {
              let s2 = t2.evaluate(e2, r2, n2, i2, a2);
              return this._calculate(s2, s2, s2, e2);
            }
            return t2.kind === "composite" ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class hi {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            if (t2.value !== void 0) {
              if (t2.expression.kind === "constant") {
                let i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
                return this._calculate(i2, i2, i2, e2);
              }
              return this._calculate(t2.expression.evaluate(new Qn(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new Qn(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new Qn(Math.floor(e2.zoom + 1), e2)), e2);
            }
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class pi {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return !!t2.expression.evaluate(e2, null, {}, r2, n2);
          }
          interpolate() {
            return !1;
          }
        }
        class fi {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (let e2 in t2) {
              let r2 = t2[e2];
              r2.specification.overridable && this.overridableProperties.push(e2);
              let n2 = this.defaultPropertyValues[e2] = new ti(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new ei(r2);
              this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
            }
          }
        }
        Mn("DataDrivenProperty", ui), Mn("DataConstantProperty", li), Mn("CrossFadedDataDrivenProperty", ci), Mn("CrossFadedProperty", hi), Mn("ColorRampProperty", pi);
        let di = "-transition";
        class yi extends rt {
          constructor(t2, e2) {
            if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, t2.type !== "custom" && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type !== "background" && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new ai(e2.layout)), e2.paint)) {
              this._transitionablePaint = new ri(e2.paint);
              for (let e3 in t2.paint)
                this.setPaintProperty(e3, t2.paint[e3], { validate: !1 });
              for (let e3 in t2.layout)
                this.setLayoutProperty(e3, t2.layout[e3], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new oi(e2.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t2) {
            return t2 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          setLayoutProperty(t2, e2, r2 = {}) {
            e2 != null && this._validate(An, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || (t2 !== "visibility" ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
          }
          getPaintProperty(t2) {
            return t2.endsWith(di) ? this._transitionablePaint.getTransition(t2.slice(0, -di.length)) : this._transitionablePaint.getValue(t2);
          }
          setPaintProperty(t2, e2, r2 = {}) {
            if (e2 != null && this._validate(_n, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
              return !1;
            if (t2.endsWith(di))
              return this._transitionablePaint.setTransition(t2.slice(0, -di.length), e2 || void 0), !1;
            {
              let r3 = this._transitionablePaint._values[t2], n2 = r3.property.specification["property-type"] === "cross-faded-data-driven", i2 = r3.value.isDataDriven(), a2 = r3.value;
              this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
              let s2 = this._transitionablePaint._values[t2].value;
              return s2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, a2, s2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !1;
          }
          isHidden(t2) {
            return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t2, e2) {
            t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
          }
          serialize() {
            let t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), h(t2, (t3, e2) => !(t3 === void 0 || e2 === "layout" && !Object.keys(t3).length || e2 === "paint" && !Object.keys(t3).length));
          }
          _validate(t2, e2, r2, n2, i2 = {}) {
            return (!i2 || i2.validate !== !1) && kn(this, t2.call(bn, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: nt, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (let t2 in this.paint._values) {
              let e2 = this.paint.get(t2);
              if (e2 instanceof si && br(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
                return !0;
            }
            return !1;
          }
        }
        let mi = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class gi {
          constructor(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class xi {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(t2, e2) {
            return t2._trim(), e2 && (t2.isTransferred = !0, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            let e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              let e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function vi(t2, e2 = 1) {
          let r2 = 0, n2 = 0;
          return { members: t2.map((t3) => {
            let i2 = mi[t3.type].BYTES_PER_ELEMENT, a2 = r2 = bi(r2, Math.max(e2, i2)), s2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r2 += i2 * s2, { name: t3.name, type: t3.type, components: s2, offset: a2 };
          }), size: bi(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function bi(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        class wi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            let r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            let n2 = 2 * t2;
            return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
          }
        }
        wi.prototype.bytesPerElement = 4, Mn("StructArrayLayout2i4", wi);
        class _i extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            let i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            let a2 = 4 * t2;
            return this.int16[a2 + 0] = e2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, t2;
          }
        }
        _i.prototype.bytesPerElement = 8, Mn("StructArrayLayout4i8", _i);
        class Ai extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2) {
            let s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2, a2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2) {
            let o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = a2, this.int16[o2 + 5] = s2, t2;
          }
        }
        Ai.prototype.bytesPerElement = 12, Mn("StructArrayLayout2i4i12", Ai);
        class ki extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2) {
            let s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2, a2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2) {
            let o2 = 4 * t2, l2 = 8 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = a2, this.uint8[l2 + 7] = s2, t2;
          }
        }
        ki.prototype.bytesPerElement = 8, Mn("StructArrayLayout2i4ub8", ki);
        class Si extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            let r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            let n2 = 2 * t2;
            return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
          }
        }
        Si.prototype.bytesPerElement = 8, Mn("StructArrayLayout2f8", Si);
        class Ii extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2) {
            let c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, a2, s2, o2, l2, u2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2) {
            let h2 = 10 * t2;
            return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = a2, this.uint16[h2 + 5] = s2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
          }
        }
        Ii.prototype.bytesPerElement = 20, Mn("StructArrayLayout10ui20", Ii);
        class Mi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2) {
            let p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2) {
            let f2 = 12 * t2;
            return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = a2, this.uint16[f2 + 5] = s2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
          }
        }
        Mi.prototype.bytesPerElement = 24, Mn("StructArrayLayout4i4ui4i24", Mi);
        class zi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            let n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            let i2 = 3 * t2;
            return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        zi.prototype.bytesPerElement = 12, Mn("StructArrayLayout3f12", zi);
        class Bi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            let e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint32[1 * t2 + 0] = e2, t2;
          }
        }
        Bi.prototype.bytesPerElement = 4, Mn("StructArrayLayout1ul4", Bi);
        class Ci extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2, s2, o2, l2) {
            let u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, a2, s2, o2, l2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2) {
            let c2 = 10 * t2, h2 = 5 * t2;
            return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = a2, this.int16[c2 + 5] = s2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
          }
        }
        Ci.prototype.bytesPerElement = 20, Mn("StructArrayLayout6i1ul2ui20", Ci);
        class Pi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2) {
            let s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2, a2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2) {
            let o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = a2, this.int16[o2 + 5] = s2, t2;
          }
        }
        Pi.prototype.bytesPerElement = 12, Mn("StructArrayLayout2i2i2i12", Pi);
        class Vi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            let a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, a2) {
            let s2 = 4 * t2, o2 = 8 * t2;
            return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = a2, t2;
          }
        }
        Vi.prototype.bytesPerElement = 16, Mn("StructArrayLayout2f1f2i16", Vi);
        class Ei extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            let i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            let a2 = 12 * t2, s2 = 3 * t2;
            return this.uint8[a2 + 0] = e2, this.uint8[a2 + 1] = r2, this.float32[s2 + 1] = n2, this.float32[s2 + 2] = i2, t2;
          }
        }
        Ei.prototype.bytesPerElement = 12, Mn("StructArrayLayout2ub2f12", Ei);
        class Fi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            let n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            let i2 = 3 * t2;
            return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
          }
        }
        Fi.prototype.bytesPerElement = 6, Mn("StructArrayLayout3ui6", Fi);
        class Ti extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
            let g2 = this.length;
            return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
            let x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
            return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = a2, this.uint32[v2 + 3] = s2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
          }
        }
        Ti.prototype.bytesPerElement = 48, Mn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ti);
        class Li extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, I2, M2) {
            let z2 = this.length;
            return this.resize(z2 + 1), this.emplace(z2, t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, I2, M2);
          }
          emplace(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, I2, M2, z2) {
            let B2 = 34 * t2, C2 = 17 * t2;
            return this.int16[B2 + 0] = e2, this.int16[B2 + 1] = r2, this.int16[B2 + 2] = n2, this.int16[B2 + 3] = i2, this.int16[B2 + 4] = a2, this.int16[B2 + 5] = s2, this.int16[B2 + 6] = o2, this.int16[B2 + 7] = l2, this.uint16[B2 + 8] = u2, this.uint16[B2 + 9] = c2, this.uint16[B2 + 10] = h2, this.uint16[B2 + 11] = p2, this.uint16[B2 + 12] = f2, this.uint16[B2 + 13] = d2, this.uint16[B2 + 14] = y2, this.uint16[B2 + 15] = m2, this.uint16[B2 + 16] = g2, this.uint16[B2 + 17] = x2, this.uint16[B2 + 18] = v2, this.uint16[B2 + 19] = b2, this.uint16[B2 + 20] = w2, this.uint16[B2 + 21] = _2, this.uint16[B2 + 22] = A2, this.uint32[C2 + 12] = k2, this.float32[C2 + 13] = S2, this.float32[C2 + 14] = I2, this.float32[C2 + 15] = M2, this.float32[C2 + 16] = z2, t2;
          }
        }
        Li.prototype.bytesPerElement = 68, Mn("StructArrayLayout8i15ui1ul4f68", Li);
        class Di extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            let e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.float32[1 * t2 + 0] = e2, t2;
          }
        }
        Di.prototype.bytesPerElement = 4, Mn("StructArrayLayout1f4", Di);
        class $i extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            let n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            let i2 = 3 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
          }
        }
        $i.prototype.bytesPerElement = 6, Mn("StructArrayLayout3i6", $i);
        class Ri extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            let n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            let i2 = 4 * t2;
            return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
          }
        }
        Ri.prototype.bytesPerElement = 8, Mn("StructArrayLayout1ul2ui8", Ri);
        class Oi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            let r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            let n2 = 2 * t2;
            return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
          }
        }
        Oi.prototype.bytesPerElement = 4, Mn("StructArrayLayout2ui4", Oi);
        class Ui extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            let e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint16[1 * t2 + 0] = e2, t2;
          }
        }
        Ui.prototype.bytesPerElement = 2, Mn("StructArrayLayout1ui2", Ui);
        class qi extends xi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            let i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            let a2 = 4 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, t2;
          }
        }
        qi.prototype.bytesPerElement = 16, Mn("StructArrayLayout4f16", qi);
        class ji extends gi {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new S(this.anchorPointX, this.anchorPointY);
          }
        }
        ji.prototype.size = 20;
        class Ni extends Ci {
          get(t2) {
            return new ji(this, t2);
          }
        }
        Mn("CollisionBoxArray", Ni);
        class Zi extends gi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 37] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 38] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 10] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        Zi.prototype.size = 48;
        class Ki extends Ti {
          get(t2) {
            return new Zi(this, t2);
          }
        }
        Mn("PlacedSymbolArray", Ki);
        class Gi extends gi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 12] = t2;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 15];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 16];
          }
        }
        Gi.prototype.size = 68;
        class Ji extends Li {
          get(t2) {
            return new Gi(this, t2);
          }
        }
        Mn("SymbolInstanceArray", Ji);
        class Xi extends Di {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        Mn("GlyphOffsetArray", Xi);
        class Yi extends $i {
          getx(t2) {
            return this.int16[3 * t2 + 0];
          }
          gety(t2) {
            return this.int16[3 * t2 + 1];
          }
          gettileUnitDistanceFromAnchor(t2) {
            return this.int16[3 * t2 + 2];
          }
        }
        Mn("SymbolLineVertexArray", Yi);
        class Hi extends gi {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        Hi.prototype.size = 8;
        class Wi extends Ri {
          get(t2) {
            return new Hi(this, t2);
          }
        }
        Mn("FeatureIndexArray", Wi);
        class Qi extends wi {
        }
        class ta extends wi {
        }
        class ea extends wi {
        }
        class ra extends Ai {
        }
        class na extends ki {
        }
        class ia extends Si {
        }
        class aa extends Ii {
        }
        class sa extends Mi {
        }
        class oa extends zi {
        }
        class la extends Bi {
        }
        class ua extends Pi {
        }
        class ca extends Ei {
        }
        class ha extends Fi {
        }
        class pa extends Oi {
        }
        let fa = vi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: da } = fa;
        class ya {
          constructor(t2 = []) {
            this.segments = t2;
          }
          prepareSegment(t2, e2, r2, n2) {
            let i2 = this.segments[this.segments.length - 1];
            return t2 > ya.MAX_VERTEX_ARRAY_LENGTH && d(`Max vertices per segment is ${ya.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > ya.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, n2 !== void 0 && (i2.sortKey = n2), this.segments.push(i2)), i2;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (let t2 of this.segments)
              for (let e2 in t2.vaos)
                t2.vaos[e2].destroy();
          }
          static simpleSegment(t2, e2, r2, n2) {
            return new ya([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        function ma(t2, e2) {
          return 256 * (t2 = a(Math.floor(t2), 0, 255)) + a(Math.floor(e2), 0, 255);
        }
        ya.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Mn("SegmentVector", ya);
        let ga = vi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var xa = { exports: {} }, va = { exports: {} };
        va.exports = function(t2, e2) {
          var r2, n2, i2, a2, s2, o2, l2, u2;
          for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, s2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
            l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (a2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a2 >>> 16) & 65535) << 16);
          switch (l2 = 0, r2) {
            case 3:
              l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
            case 2:
              l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
        var ba = { exports: {} };
        ba.exports = function(t2, e2) {
          for (var r2, n2 = t2.length, i2 = e2 ^ n2, a2 = 0; n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(a2) | (255 & t2.charCodeAt(++a2)) << 8 | (255 & t2.charCodeAt(++a2)) << 16 | (255 & t2.charCodeAt(++a2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++a2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t2.charCodeAt(a2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t2.charCodeAt(a2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(a2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
        var wa = va.exports, _a = ba.exports;
        xa.exports = wa, xa.exports.murmur3 = wa, xa.exports.murmur2 = _a;
        class Aa {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(t2, e2, r2, n2) {
            this.ids.push(ka(t2)), this.positions.push(e2, r2, n2);
          }
          getPositions(t2) {
            if (!this.indexed)
              throw new Error("Trying to get index, but feature positions are not indexed");
            let e2 = ka(t2), r2 = 0, n2 = this.ids.length - 1;
            for (; r2 < n2; ) {
              let t3 = r2 + n2 >> 1;
              this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
            }
            let i2 = [];
            for (; this.ids[r2] === e2; )
              i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return i2;
          }
          static serialize(t2, e2) {
            let r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return Sa(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
          }
          static deserialize(t2) {
            let e2 = new Aa();
            return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = !0, e2;
          }
        }
        function ka(t2) {
          let e2 = +t2;
          return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : xa.exports(String(t2));
        }
        function Sa(t2, e2, r2, n2) {
          for (; r2 < n2; ) {
            let i2 = t2[r2 + n2 >> 1], a2 = r2 - 1, s2 = n2 + 1;
            for (; ; ) {
              do
                a2++;
              while (t2[a2] < i2);
              do
                s2--;
              while (t2[s2] > i2);
              if (a2 >= s2)
                break;
              Ia(t2, a2, s2), Ia(e2, 3 * a2, 3 * s2), Ia(e2, 3 * a2 + 1, 3 * s2 + 1), Ia(e2, 3 * a2 + 2, 3 * s2 + 2);
            }
            s2 - r2 < n2 - s2 ? (Sa(t2, e2, r2, s2), r2 = s2 + 1) : (Sa(t2, e2, s2 + 1, n2), n2 = s2);
          }
        }
        function Ia(t2, e2, r2) {
          let n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        Mn("FeaturePositionMap", Aa);
        class Ma {
          constructor(t2, e2) {
            this.gl = t2.gl, this.location = e2;
          }
        }
        class za extends Ma {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
          }
        }
        class Ba extends Ma {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
          }
        }
        class Ca extends Ma {
          constructor(t2, e2) {
            super(t2, e2), this.current = Ft.transparent;
          }
          set(t2) {
            t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
          }
        }
        let Pa = new Float32Array(16);
        function Va(t2) {
          return [ma(255 * t2.r, 255 * t2.g), ma(255 * t2.b, 255 * t2.a)];
        }
        class Ea {
          constructor(t2, e2, r2) {
            this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
          }
          setUniform(t2, e2, r2) {
            t2.set(r2.constantOr(this.value));
          }
          getBinding(t2, e2, r2) {
            return this.type === "color" ? new Ca(t2, e2) : new za(t2, e2);
          }
        }
        class Fa {
          constructor(t2, e2) {
            this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t2, e2) {
            this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
          }
          setUniform(t2, e2, r2, n2) {
            let i2 = n2 === "u_pattern_to" ? this.patternTo : n2 === "u_pattern_from" ? this.patternFrom : n2 === "u_pixel_ratio_to" ? this.pixelRatioTo : n2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            i2 && t2.set(i2);
          }
          getBinding(t2, e2, r2) {
            return r2.substr(0, 9) === "u_pattern" ? new Ba(t2, e2) : new za(t2, e2);
          }
        }
        class Ta {
          constructor(t2, e2, r2, n2) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e2, r2, n2, i2) {
            let a2 = this.paintVertexArray.length, s2 = this.expression.evaluate(new Qn(0), e2, {}, n2, [], i2);
            this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, s2);
          }
          updatePaintArray(t2, e2, r2, n2) {
            let i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
            this._setPaintValue(t2, e2, i2);
          }
          _setPaintValue(t2, e2, r2) {
            if (this.type === "color") {
              let n2 = Va(r2);
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, n2[0], n2[1]);
            } else {
              for (let n2 = t2; n2 < e2; n2++)
                this.paintVertexArray.emplace(n2, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class La {
          constructor(t2, e2, r2, n2, i2, a2) {
            this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new a2();
          }
          populatePaintArray(t2, e2, r2, n2, i2) {
            let a2 = this.expression.evaluate(new Qn(this.zoom), e2, {}, n2, [], i2), s2 = this.expression.evaluate(new Qn(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, a2, s2);
          }
          updatePaintArray(t2, e2, r2, n2) {
            let i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
            this._setPaintValue(t2, e2, i2, a2);
          }
          _setPaintValue(t2, e2, r2, n2) {
            if (this.type === "color") {
              let i2 = Va(r2), a2 = Va(n2);
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, i2[0], i2[1], a2[0], a2[1]);
            } else {
              for (let i2 = t2; i2 < e2; i2++)
                this.paintVertexArray.emplace(i2, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e2) {
            let r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = a(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
            t2.set(n2);
          }
          getBinding(t2, e2, r2) {
            return new za(t2, e2);
          }
        }
        class Da {
          constructor(t2, e2, r2, n2, i2, a2) {
            this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = a2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
          }
          populatePaintArray(t2, e2, r2) {
            let n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
          }
          updatePaintArray(t2, e2, r2, n2, i2) {
            this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
          }
          _setPaintValues(t2, e2, r2, n2) {
            if (!n2 || !r2)
              return;
            let { min: i2, mid: a2, max: s2 } = r2, o2 = n2[i2], l2 = n2[a2], u2 = n2[s2];
            if (o2 && l2 && u2)
              for (let r3 = t2; r3 < e2; r3++)
                this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
          }
          upload(t2) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, ga.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, ga.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class $a {
          constructor(t2, e2, r2) {
            this.binders = {}, this._buffers = [];
            let n2 = [];
            for (let i2 in t2.paint._values) {
              if (!r2(i2))
                continue;
              let a2 = t2.paint.get(i2);
              if (!(a2 instanceof si && br(a2.property.specification)))
                continue;
              let s2 = Oa(i2, t2.type), o2 = a2.value, l2 = a2.property.specification.type, u2 = a2.property.useIntegerZoom, c2 = a2.property.specification["property-type"], h2 = c2 === "cross-faded" || c2 === "cross-faded-data-driven";
              if (o2.kind === "constant")
                this.binders[i2] = h2 ? new Fa(o2.value, s2) : new Ea(o2.value, s2, l2), n2.push(`/u_${i2}`);
              else if (o2.kind === "source" || h2) {
                let r3 = Ua(i2, l2, "source");
                this.binders[i2] = h2 ? new Da(o2, l2, u2, e2, r3, t2.id) : new Ta(o2, s2, l2, r3), n2.push(`/a_${i2}`);
              } else {
                let t3 = Ua(i2, l2, "composite");
                this.binders[i2] = new La(o2, s2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
              }
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t2) {
            let e2 = this.binders[t2];
            return e2 instanceof Ta || e2 instanceof La ? e2.maxValue : 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2) {
            for (let a2 in this.binders) {
              let s2 = this.binders[a2];
              (s2 instanceof Ta || s2 instanceof La || s2 instanceof Da) && s2.populatePaintArray(t2, e2, r2, n2, i2);
            }
          }
          setConstantPatternPositions(t2, e2) {
            for (let r2 in this.binders) {
              let n2 = this.binders[r2];
              n2 instanceof Fa && n2.setConstantPatternPositions(t2, e2);
            }
          }
          updatePaintArrays(t2, e2, r2, n2, i2) {
            let a2 = !1;
            for (let s2 in t2) {
              let o2 = e2.getPositions(s2);
              for (let e3 of o2) {
                let o3 = r2.feature(e3.index);
                for (let r3 in this.binders) {
                  let l2 = this.binders[r3];
                  if ((l2 instanceof Ta || l2 instanceof La || l2 instanceof Da) && l2.expression.isStateDependent === !0) {
                    let u2 = n2.paint.get(r3);
                    l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[s2], i2), a2 = !0;
                  }
                }
              }
            }
            return a2;
          }
          defines() {
            let t2 = [];
            for (let e2 in this.binders) {
              let r2 = this.binders[e2];
              (r2 instanceof Ea || r2 instanceof Fa) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
            }
            return t2;
          }
          getBinderAttributes() {
            let t2 = [];
            for (let e2 in this.binders) {
              let r2 = this.binders[e2];
              if (r2 instanceof Ta || r2 instanceof La)
                for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                  t2.push(r2.paintVertexAttributes[e3].name);
              else if (r2 instanceof Da)
                for (let e3 = 0; e3 < ga.members.length; e3++)
                  t2.push(ga.members[e3].name);
            }
            return t2;
          }
          getBinderUniforms() {
            let t2 = [];
            for (let e2 in this.binders) {
              let r2 = this.binders[e2];
              if (r2 instanceof Ea || r2 instanceof Fa || r2 instanceof La)
                for (let e3 of r2.uniformNames)
                  t2.push(e3);
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2, e2) {
            let r2 = [];
            for (let n2 in this.binders) {
              let i2 = this.binders[n2];
              if (i2 instanceof Ea || i2 instanceof Fa || i2 instanceof La) {
                for (let a2 of i2.uniformNames)
                  if (e2[a2]) {
                    let s2 = i2.getBinding(t2, e2[a2], a2);
                    r2.push({ name: a2, property: n2, binding: s2 });
                  }
              }
            }
            return r2;
          }
          setUniforms(t2, e2, r2, n2) {
            for (let { name: t3, property: i2, binding: a2 } of e2)
              this.binders[i2].setUniform(a2, n2, r2.get(i2), t3);
          }
          updatePaintBuffers(t2) {
            this._buffers = [];
            for (let e2 in this.binders) {
              let r2 = this.binders[e2];
              if (t2 && r2 instanceof Da) {
                let e3 = t2.fromScale === 2 ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                e3 && this._buffers.push(e3);
              } else
                (r2 instanceof Ta || r2 instanceof La) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
            }
          }
          upload(t2) {
            for (let e2 in this.binders) {
              let r2 = this.binders[e2];
              (r2 instanceof Ta || r2 instanceof La || r2 instanceof Da) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (let t2 in this.binders) {
              let e2 = this.binders[t2];
              (e2 instanceof Ta || e2 instanceof La || e2 instanceof Da) && e2.destroy();
            }
          }
        }
        class Ra {
          constructor(t2, e2, r2 = () => !0) {
            this.programConfigurations = {};
            for (let n2 of t2)
              this.programConfigurations[n2.id] = new $a(n2, e2, r2);
            this.needsUpload = !1, this._featureMap = new Aa(), this._bufferOffset = 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2, a2) {
            for (let r3 in this.programConfigurations)
              this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, a2);
            e2.id !== void 0 && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = !0;
          }
          updatePaintArrays(t2, e2, r2, n2) {
            for (let i2 of r2)
              this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (let e2 in this.programConfigurations)
                this.programConfigurations[e2].upload(t2);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (let t2 in this.programConfigurations)
              this.programConfigurations[t2].destroy();
          }
        }
        function Oa(t2, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        function Ua(t2, e2, r2) {
          let n2 = { color: { source: Si, composite: qi }, number: { source: Di, composite: Si } }, i2 = function(t3) {
            return { "line-pattern": { source: aa, composite: aa }, "fill-pattern": { source: aa, composite: aa }, "fill-extrusion-pattern": { source: aa, composite: aa } }[t3];
          }(t2);
          return i2 && i2[r2] || n2[e2][r2];
        }
        Mn("ConstantBinder", Ea), Mn("CrossFadedConstantBinder", Fa), Mn("SourceExpressionBinder", Ta), Mn("CrossFadedCompositeBinder", Da), Mn("CompositeExpressionBinder", La), Mn("ProgramConfiguration", $a, { omit: ["_buffers"] }), Mn("ProgramConfigurationSet", Ra);
        var qa = 8192;
        let ja = Math.pow(2, 14) - 1, Na = -ja - 1;
        function Za(t2) {
          let e2 = qa / t2.extent, r2 = t2.loadGeometry();
          for (let t3 = 0; t3 < r2.length; t3++) {
            let n2 = r2[t3];
            for (let t4 = 0; t4 < n2.length; t4++) {
              let r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
              r3.x = a(i2, Na, ja), r3.y = a(s2, Na, ja), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && d("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r2;
        }
        function Ka(t2, e2) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Za(t2) : [] };
        }
        function Ga(t2, e2, r2, n2, i2) {
          t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
        }
        class Ja {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = !1, this.layoutVertexArray = new ta(), this.indexArray = new ha(), this.segments = new ya(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            let n2 = this.layers[0], i2 = [], a2 = null, s2 = !1;
            n2.type === "circle" && (a2 = n2.layout.get("circle-sort-key"), s2 = !a2.isConstant());
            for (let { feature: e3, id: n3, index: o2, sourceLayerIndex: l2 } of t2) {
              let t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ka(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), u2, r2))
                continue;
              let c2 = s2 ? a2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Za(e3), patterns: {}, sortKey: c2 };
              i2.push(h2);
            }
            s2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (let n3 of i2) {
              let { geometry: i3, index: a3, sourceLayerIndex: s3 } = n3, o2 = t2[a3].feature;
              this.addFeature(n3, i3, a3, r2), e2.featureIndex.insert(o2, i3, a3, s3, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, da), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e2, r2, n2) {
            for (let r3 of e2)
              for (let e3 of r3) {
                let r4 = e3.x, n3 = e3.y;
                if (r4 < 0 || r4 >= qa || n3 < 0 || n3 >= qa)
                  continue;
                let i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), a2 = i2.vertexLength;
                Ga(this.layoutVertexArray, r4, n3, -1, -1), Ga(this.layoutVertexArray, r4, n3, 1, -1), Ga(this.layoutVertexArray, r4, n3, 1, 1), Ga(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(a2, a2 + 1, a2 + 2), this.indexArray.emplaceBack(a2, a2 + 3, a2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
          }
        }
        function Xa(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++)
            if (is(e2, t2[r2]))
              return !0;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (is(t2, e2[r2]))
              return !0;
          return !!Qa(t2, e2);
        }
        function Ya(t2, e2, r2) {
          return !!is(t2, e2) || !!es(e2, t2, r2);
        }
        function Ha(t2, e2) {
          if (t2.length === 1)
            return ns(e2, t2[0]);
          for (let r2 = 0; r2 < e2.length; r2++) {
            let n2 = e2[r2];
            for (let e3 = 0; e3 < n2.length; e3++)
              if (is(t2, n2[e3]))
                return !0;
          }
          for (let r2 = 0; r2 < t2.length; r2++)
            if (ns(e2, t2[r2]))
              return !0;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (Qa(t2, e2[r2]))
              return !0;
          return !1;
        }
        function Wa(t2, e2, r2) {
          if (t2.length > 1) {
            if (Qa(t2, e2))
              return !0;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (es(e2[n2], t2, r2))
                return !0;
          }
          for (let n2 = 0; n2 < t2.length; n2++)
            if (es(t2[n2], e2, r2))
              return !0;
          return !1;
        }
        function Qa(t2, e2) {
          if (t2.length === 0 || e2.length === 0)
            return !1;
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            let n2 = t2[r2], i2 = t2[r2 + 1];
            for (let t3 = 0; t3 < e2.length - 1; t3++)
              if (ts(n2, i2, e2[t3], e2[t3 + 1]))
                return !0;
          }
          return !1;
        }
        function ts(t2, e2, r2, n2) {
          return y(t2, r2, n2) !== y(e2, r2, n2) && y(t2, e2, r2) !== y(t2, e2, n2);
        }
        function es(t2, e2, r2) {
          let n2 = r2 * r2;
          if (e2.length === 1)
            return t2.distSqr(e2[0]) < n2;
          for (let r3 = 1; r3 < e2.length; r3++)
            if (rs(t2, e2[r3 - 1], e2[r3]) < n2)
              return !0;
          return !1;
        }
        function rs(t2, e2, r2) {
          let n2 = e2.distSqr(r2);
          if (n2 === 0)
            return t2.distSqr(e2);
          let i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
          return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
        }
        function ns(t2, e2) {
          let r2, n2, i2, a2 = !1;
          for (let s2 = 0; s2 < t2.length; s2++) {
            r2 = t2[s2];
            for (let t3 = 0, s3 = r2.length - 1; t3 < r2.length; s3 = t3++)
              n2 = r2[t3], i2 = r2[s3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (a2 = !a2);
          }
          return a2;
        }
        function is(t2, e2) {
          let r2 = !1;
          for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            let a2 = t2[n2], s2 = t2[i2];
            a2.y > e2.y != s2.y > e2.y && e2.x < (s2.x - a2.x) * (e2.y - a2.y) / (s2.y - a2.y) + a2.x && (r2 = !r2);
          }
          return r2;
        }
        function as(t2, e2, r2) {
          let n2 = r2[0], i2 = r2[2];
          if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
            return !1;
          let a2 = y(t2, e2, r2[0]);
          return a2 !== y(t2, e2, r2[1]) || a2 !== y(t2, e2, r2[2]) || a2 !== y(t2, e2, r2[3]);
        }
        function ss(t2, e2, r2) {
          let n2 = e2.paint.get(t2).value;
          return n2.kind === "constant" ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
        }
        function os(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function ls(t2, e2, r2, n2, i2) {
          if (!e2[0] && !e2[1])
            return t2;
          let a2 = S.convert(e2)._mult(i2);
          r2 === "viewport" && a2._rotate(-n2);
          let s2 = [];
          for (let e3 = 0; e3 < t2.length; e3++)
            s2.push(t2[e3].sub(a2));
          return s2;
        }
        Mn("CircleBucket", Ja, { omit: ["layers"] });
        let us = new fi({ "circle-sort-key": new ui(nt.layout_circle["circle-sort-key"]) });
        var cs = { paint: new fi({ "circle-radius": new ui(nt.paint_circle["circle-radius"]), "circle-color": new ui(nt.paint_circle["circle-color"]), "circle-blur": new ui(nt.paint_circle["circle-blur"]), "circle-opacity": new ui(nt.paint_circle["circle-opacity"]), "circle-translate": new li(nt.paint_circle["circle-translate"]), "circle-translate-anchor": new li(nt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new li(nt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new li(nt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ui(nt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ui(nt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ui(nt.paint_circle["circle-stroke-opacity"]) }), layout: us }, hs = 1e-6, ps = typeof Float32Array < "u" ? Float32Array : Array;
        function fs() {
          var t2 = new ps(9);
          return ps != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }
        function ds(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function ys(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2], s2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
          return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, e2 = arguments.length; e2--; )
            t2 += arguments[e2] * arguments[e2];
          return Math.sqrt(t2);
        });
        var ms, gs = ys;
        function xs() {
          var t2 = new ps(3);
          return ps != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
        }
        function vs(t2, e2, r2) {
          var n2 = new ps(3);
          return n2[0] = t2, n2[1] = e2, n2[2] = r2, n2;
        }
        function bs(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2], s2 = e2[3];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * a2 + r2[12] * s2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * a2 + r2[13] * s2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * a2 + r2[14] * s2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * a2 + r2[15] * s2, t2;
        }
        function ws() {
          var t2 = new ps(4);
          return ps != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
        }
        function _s(t2, e2) {
          let r2 = bs([], [t2.x, t2.y, 0, 1], e2);
          return new S(r2[0] / r2[3], r2[1] / r2[3]);
        }
        xs(), ms = new ps(4), ps != Float32Array && (ms[0] = 0, ms[1] = 0, ms[2] = 0, ms[3] = 0), xs(), vs(1, 0, 0), vs(0, 1, 0), ws(), ws(), fs(), function() {
          var t2;
          t2 = new ps(2), ps != Float32Array && (t2[0] = 0, t2[1] = 0);
        }();
        class As extends Ja {
        }
        Mn("HeatmapBucket", As, { omit: ["layers"] });
        var ks = { paint: new fi({ "heatmap-radius": new ui(nt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ui(nt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new li(nt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new pi(nt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new li(nt.paint_heatmap["heatmap-opacity"]) }) };
        function Ss(t2, { width: e2, height: r2 }, n2, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray)
              i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e2 * r2 * n2)
              throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
          } else
            i2 = new Uint8Array(e2 * r2 * n2);
          return t2.width = e2, t2.height = r2, t2.data = i2, t2;
        }
        function Is(t2, { width: e2, height: r2 }, n2) {
          if (e2 === t2.width && r2 === t2.height)
            return;
          let i2 = Ss({}, { width: e2, height: r2 }, n2);
          Ms(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
        }
        function Ms(t2, e2, r2, n2, i2, a2) {
          if (i2.width === 0 || i2.height === 0)
            return e2;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
            throw new RangeError("out of range destination coordinates for image copy");
          let s2 = t2.data, o2 = e2.data;
          if (s2 === o2)
            throw new Error("srcData equals dstData, so image is already copied");
          for (let l2 = 0; l2 < i2.height; l2++) {
            let u2 = ((r2.y + l2) * t2.width + r2.x) * a2, c2 = ((n2.y + l2) * e2.width + n2.x) * a2;
            for (let t3 = 0; t3 < i2.width * a2; t3++)
              o2[c2 + t3] = s2[u2 + t3];
          }
          return e2;
        }
        class zs {
          constructor(t2, e2) {
            Ss(this, t2, 1, e2);
          }
          resize(t2) {
            Is(this, t2, 1);
          }
          clone() {
            return new zs({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            Ms(t2, e2, r2, n2, i2, 1);
          }
        }
        class Bs {
          constructor(t2, e2) {
            Ss(this, t2, 4, e2);
          }
          resize(t2) {
            Is(this, t2, 4);
          }
          replace(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new Bs({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            Ms(t2, e2, r2, n2, i2, 4);
          }
        }
        function Cs(t2) {
          let e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Bs({ width: r2, height: n2 });
          if (Math.log(r2) / Math.LN2 % 1 != 0)
            throw new Error(`width is not a power of 2 - ${r2}`);
          let a2 = (r3, n3, a3) => {
            e2[t2.evaluationKey] = a3;
            let s2 = t2.expression.evaluate(e2);
            i2.data[r3 + n3 + 0] = Math.floor(255 * s2.r / s2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * s2.g / s2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * s2.b / s2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * s2.a);
          };
          if (t2.clips)
            for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
              for (let n3 = 0, s2 = 0; n3 < r2; n3++, s2 += 4) {
                let o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
                a2(i3, s2, l2 * (1 - o2) + u2 * o2);
              }
          else
            for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
              a2(0, e3, t3 / (r2 - 1));
          return i2;
        }
        Mn("AlphaImage", zs), Mn("RGBAImage", Bs);
        var Ps = { paint: new fi({ "hillshade-illumination-direction": new li(nt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new li(nt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new li(nt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new li(nt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new li(nt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new li(nt.paint_hillshade["hillshade-accent-color"]) }) };
        let Vs = vi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Es } = Vs;
        var Fs = { exports: {} };
        function Ts(t2, e2, r2) {
          r2 = r2 || 2;
          var n2, i2, a2, s2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r2 : t2.length, p2 = Ls(t2, 0, h2, r2, !0), f2 = [];
          if (!p2 || p2.next === p2.prev)
            return f2;
          if (c2 && (p2 = function(t3, e3, r3, n3) {
            var i3, a3, s3, o3 = [];
            for (i3 = 0, a3 = e3.length; i3 < a3; i3++)
              (s3 = Ls(t3, e3[i3] * n3, i3 < a3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, !1)) === s3.next && (s3.steiner = !0), o3.push(Gs(s3));
            for (o3.sort(js), i3 = 0; i3 < o3.length; i3++)
              r3 = Ns(o3[i3], r3);
            return r3;
          }(t2, e2, p2, r2)), t2.length > 80 * r2) {
            n2 = a2 = t2[0], i2 = s2 = t2[1];
            for (var d2 = r2; d2 < h2; d2 += r2)
              (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > a2 && (a2 = o2), l2 > s2 && (s2 = l2);
            u2 = (u2 = Math.max(a2 - n2, s2 - i2)) !== 0 ? 32767 / u2 : 0;
          }
          return $s(p2, f2, r2, n2, i2, u2, 0), f2;
        }
        function Ls(t2, e2, r2, n2, i2) {
          var a2, s2;
          if (i2 === so(t2, e2, r2, n2) > 0)
            for (a2 = e2; a2 < r2; a2 += n2)
              s2 = no(a2, t2[a2], t2[a2 + 1], s2);
          else
            for (a2 = r2 - n2; a2 >= e2; a2 -= n2)
              s2 = no(a2, t2[a2], t2[a2 + 1], s2);
          return s2 && Hs(s2, s2.next) && (io(s2), s2 = s2.next), s2;
        }
        function Ds(t2, e2) {
          if (!t2)
            return t2;
          e2 || (e2 = t2);
          var r2, n2 = t2;
          do
            if (r2 = !1, n2.steiner || !Hs(n2, n2.next) && Ys(n2.prev, n2, n2.next) !== 0)
              n2 = n2.next;
            else {
              if (io(n2), (n2 = e2 = n2.prev) === n2.next)
                break;
              r2 = !0;
            }
          while (r2 || n2 !== e2);
          return e2;
        }
        function $s(t2, e2, r2, n2, i2, a2, s2) {
          if (t2) {
            !s2 && a2 && function(t3, e3, r3, n3) {
              var i3 = t3;
              do
                i3.z === 0 && (i3.z = Ks(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                var e4, r4, n4, i4, a3, s3, o3, l3, u3 = 1;
                do {
                  for (r4 = t4, t4 = null, a3 = null, s3 = 0; r4; ) {
                    for (s3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                      ;
                    for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                      o3 !== 0 && (l3 === 0 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), a3 ? a3.nextZ = i4 : t4 = i4, i4.prevZ = a3, a3 = i4;
                    r4 = n4;
                  }
                  a3.nextZ = null, u3 *= 2;
                } while (s3 > 1);
              }(i3);
            }(t2, n2, i2, a2);
            for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
              if (o2 = t2.prev, l2 = t2.next, a2 ? Os(t2, n2, i2, a2) : Rs(t2))
                e2.push(o2.i / r2 | 0), e2.push(t2.i / r2 | 0), e2.push(l2.i / r2 | 0), io(t2), t2 = l2.next, u2 = l2.next;
              else if ((t2 = l2) === u2) {
                s2 ? s2 === 1 ? $s(t2 = Us(Ds(t2), e2, r2), e2, r2, n2, i2, a2, 2) : s2 === 2 && qs(t2, e2, r2, n2, i2, a2) : $s(Ds(t2), e2, r2, n2, i2, a2, 1);
                break;
              }
          }
        }
        function Rs(t2) {
          var e2 = t2.prev, r2 = t2, n2 = t2.next;
          if (Ys(e2, r2, n2) >= 0)
            return !1;
          for (var i2 = e2.x, a2 = r2.x, s2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = i2 < a2 ? i2 < s2 ? i2 : s2 : a2 < s2 ? a2 : s2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > a2 ? i2 > s2 ? i2 : s2 : a2 > s2 ? a2 : s2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e2; ) {
            if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && Js(i2, o2, a2, l2, s2, u2, d2.x, d2.y) && Ys(d2.prev, d2, d2.next) >= 0)
              return !1;
            d2 = d2.next;
          }
          return !0;
        }
        function Os(t2, e2, r2, n2) {
          var i2 = t2.prev, a2 = t2, s2 = t2.next;
          if (Ys(i2, a2, s2) >= 0)
            return !1;
          for (var o2 = i2.x, l2 = a2.x, u2 = s2.x, c2 = i2.y, h2 = a2.y, p2 = s2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = Ks(f2, d2, e2, r2, n2), x2 = Ks(y2, m2, e2, r2, n2), v2 = t2.prevZ, b2 = t2.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== s2 && Js(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ys(v2.prev, v2, v2.next) >= 0 || (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== s2 && Js(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ys(b2.prev, b2, b2.next) >= 0))
              return !1;
            b2 = b2.nextZ;
          }
          for (; v2 && v2.z >= g2; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== s2 && Js(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ys(v2.prev, v2, v2.next) >= 0)
              return !1;
            v2 = v2.prevZ;
          }
          for (; b2 && b2.z <= x2; ) {
            if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== s2 && Js(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ys(b2.prev, b2, b2.next) >= 0)
              return !1;
            b2 = b2.nextZ;
          }
          return !0;
        }
        function Us(t2, e2, r2) {
          var n2 = t2;
          do {
            var i2 = n2.prev, a2 = n2.next.next;
            !Hs(i2, a2) && Ws(i2, n2, n2.next, a2) && eo(i2, a2) && eo(a2, i2) && (e2.push(i2.i / r2 | 0), e2.push(n2.i / r2 | 0), e2.push(a2.i / r2 | 0), io(n2), io(n2.next), n2 = t2 = a2), n2 = n2.next;
          } while (n2 !== t2);
          return Ds(n2);
        }
        function qs(t2, e2, r2, n2, i2, a2) {
          var s2 = t2;
          do {
            for (var o2 = s2.next.next; o2 !== s2.prev; ) {
              if (s2.i !== o2.i && Xs(s2, o2)) {
                var l2 = ro(s2, o2);
                return s2 = Ds(s2, s2.next), l2 = Ds(l2, l2.next), $s(s2, e2, r2, n2, i2, a2, 0), void $s(l2, e2, r2, n2, i2, a2, 0);
              }
              o2 = o2.next;
            }
            s2 = s2.next;
          } while (s2 !== t2);
        }
        function js(t2, e2) {
          return t2.x - e2.x;
        }
        function Ns(t2, e2) {
          var r2 = function(t3, e3) {
            var r3, n3 = e3, i2 = t3.x, a2 = t3.y, s2 = -1 / 0;
            do {
              if (a2 <= n3.y && a2 >= n3.next.y && n3.next.y !== n3.y) {
                var o2 = n3.x + (a2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                if (o2 <= i2 && o2 > s2 && (s2 = o2, r3 = n3.x < n3.next.x ? n3 : n3.next, o2 === i2))
                  return r3;
              }
              n3 = n3.next;
            } while (n3 !== e3);
            if (!r3)
              return null;
            var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
            n3 = r3;
            do
              i2 >= n3.x && n3.x >= c2 && i2 !== n3.x && Js(a2 < h2 ? i2 : s2, a2, c2, h2, a2 < h2 ? s2 : i2, a2, n3.x, n3.y) && (l2 = Math.abs(a2 - n3.y) / (i2 - n3.x), eo(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && Zs(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
            while (n3 !== u2);
            return r3;
          }(t2, e2);
          if (!r2)
            return e2;
          var n2 = ro(r2, t2);
          return Ds(n2, n2.next), Ds(r2, r2.next);
        }
        function Zs(t2, e2) {
          return Ys(t2.prev, t2, e2.prev) < 0 && Ys(e2.next, t2, t2.next) < 0;
        }
        function Ks(t2, e2, r2, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function Gs(t2) {
          var e2 = t2, r2 = t2;
          do
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          while (e2 !== t2);
          return r2;
        }
        function Js(t2, e2, r2, n2, i2, a2, s2, o2) {
          return (i2 - s2) * (e2 - o2) >= (t2 - s2) * (a2 - o2) && (t2 - s2) * (n2 - o2) >= (r2 - s2) * (e2 - o2) && (r2 - s2) * (a2 - o2) >= (i2 - s2) * (n2 - o2);
        }
        function Xs(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
            var r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ws(r2, r2.next, t3, e3))
                return !0;
              r2 = r2.next;
            } while (r2 !== t3);
            return !1;
          }(t2, e2) && (eo(t2, e2) && eo(e2, t2) && function(t3, e3) {
            var r2 = t3, n2 = !1, i2 = (t3.x + e3.x) / 2, a2 = (t3.y + e3.y) / 2;
            do
              r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            while (r2 !== t3);
            return n2;
          }(t2, e2) && (Ys(t2.prev, t2, e2.prev) || Ys(t2, e2.prev, e2)) || Hs(t2, e2) && Ys(t2.prev, t2, t2.next) > 0 && Ys(e2.prev, e2, e2.next) > 0);
        }
        function Ys(t2, e2, r2) {
          return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
        }
        function Hs(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function Ws(t2, e2, r2, n2) {
          var i2 = to(Ys(t2, e2, r2)), a2 = to(Ys(t2, e2, n2)), s2 = to(Ys(r2, n2, t2)), o2 = to(Ys(r2, n2, e2));
          return i2 !== a2 && s2 !== o2 || !(i2 !== 0 || !Qs(t2, r2, e2)) || !(a2 !== 0 || !Qs(t2, n2, e2)) || !(s2 !== 0 || !Qs(r2, t2, n2)) || !(o2 !== 0 || !Qs(r2, e2, n2));
        }
        function Qs(t2, e2, r2) {
          return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
        }
        function to(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function eo(t2, e2) {
          return Ys(t2.prev, t2, t2.next) < 0 ? Ys(t2, e2, t2.next) >= 0 && Ys(t2, t2.prev, e2) >= 0 : Ys(t2, e2, t2.prev) < 0 || Ys(t2, t2.next, e2) < 0;
        }
        function ro(t2, e2) {
          var r2 = new ao(t2.i, t2.x, t2.y), n2 = new ao(e2.i, e2.x, e2.y), i2 = t2.next, a2 = e2.prev;
          return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
        }
        function no(t2, e2, r2, n2) {
          var i2 = new ao(t2, e2, r2);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function io(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function ao(t2, e2, r2) {
          this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        function so(t2, e2, r2, n2) {
          for (var i2 = 0, a2 = e2, s2 = r2 - n2; a2 < r2; a2 += n2)
            i2 += (t2[s2] - t2[a2]) * (t2[a2 + 1] + t2[s2 + 1]), s2 = a2;
          return i2;
        }
        function oo(t2, e2, r2, n2, i2) {
          lo(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || co);
        }
        function lo(t2, e2, r2, n2, i2) {
          for (; n2 > r2; ) {
            if (n2 - r2 > 600) {
              var a2 = n2 - r2 + 1, s2 = e2 - r2 + 1, o2 = Math.log(a2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (a2 - l2) / a2) * (s2 - a2 / 2 < 0 ? -1 : 1);
              lo(t2, e2, Math.max(r2, Math.floor(e2 - s2 * l2 / a2 + u2)), Math.min(n2, Math.floor(e2 + (a2 - s2) * l2 / a2 + u2)), i2);
            }
            var c2 = t2[e2], h2 = r2, p2 = n2;
            for (uo(t2, r2, e2), i2(t2[n2], c2) > 0 && uo(t2, r2, n2); h2 < p2; ) {
              for (uo(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
                h2++;
              for (; i2(t2[p2], c2) > 0; )
                p2--;
            }
            i2(t2[r2], c2) === 0 ? uo(t2, r2, p2) : uo(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
          }
        }
        function uo(t2, e2, r2) {
          var n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function co(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function ho(t2, e2) {
          let r2 = t2.length;
          if (r2 <= 1)
            return [t2];
          let n2 = [], i2, a2;
          for (let e3 = 0; e3 < r2; e3++) {
            let r3 = m(t2[e3]);
            r3 !== 0 && (t2[e3].area = Math.abs(r3), a2 === void 0 && (a2 = r3 < 0), a2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
          }
          if (i2 && n2.push(i2), e2 > 1)
            for (let t3 = 0; t3 < n2.length; t3++)
              n2[t3].length <= e2 || (oo(n2[t3], e2, 1, n2[t3].length - 1, po), n2[t3] = n2[t3].slice(0, e2));
          return n2;
        }
        function po(t2, e2) {
          return e2.area - t2.area;
        }
        function fo(t2, e2, r2) {
          let n2 = r2.patternDependencies, i2 = !1;
          for (let r3 of e2) {
            let e3 = r3.paint.get(`${t2}-pattern`);
            e3.isConstant() || (i2 = !0);
            let a2 = e3.constantOr(null);
            a2 && (i2 = !0, n2[a2.to] = !0, n2[a2.from] = !0);
          }
          return i2;
        }
        function yo(t2, e2, r2, n2, i2) {
          let a2 = i2.patternDependencies;
          for (let s2 of e2) {
            let e3 = s2.paint.get(`${t2}-pattern`).value;
            if (e3.kind !== "constant") {
              let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, a2[t3] = !0, a2[o2] = !0, a2[l2] = !0, r2.patterns[s2.id] = { min: t3, mid: o2, max: l2 };
            }
          }
          return r2;
        }
        Fs.exports = Ts, Fs.exports.default = Ts, Ts.deviation = function(t2, e2, r2, n2) {
          var i2 = e2 && e2.length, a2 = Math.abs(so(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
          if (i2)
            for (var s2 = 0, o2 = e2.length; s2 < o2; s2++)
              a2 -= Math.abs(so(t2, e2[s2] * r2, s2 < o2 - 1 ? e2[s2 + 1] * r2 : t2.length, r2));
          var l2 = 0;
          for (s2 = 0; s2 < n2.length; s2 += 3) {
            var u2 = n2[s2] * r2, c2 = n2[s2 + 1] * r2, h2 = n2[s2 + 2] * r2;
            l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
          }
          return a2 === 0 && l2 === 0 ? 0 : Math.abs((l2 - a2) / a2);
        }, Ts.flatten = function(t2) {
          for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
            for (var a2 = 0; a2 < t2[i2].length; a2++)
              for (var s2 = 0; s2 < e2; s2++)
                r2.vertices.push(t2[i2][a2][s2]);
            i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
          }
          return r2;
        };
        class mo {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new ea(), this.indexArray = new ha(), this.indexArray2 = new pa(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.segments = new ya(), this.segments2 = new ya(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.hasPattern = fo("fill", this.layers, e2);
            let n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), a2 = [];
            for (let { feature: s2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
              let t3 = this.layers[0]._featureFilter.needGeometry, c2 = Ka(s2, t3);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), c2, r2))
                continue;
              let h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: s2.properties, type: s2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Za(s2), patterns: {}, sortKey: h2 };
              a2.push(p2);
            }
            i2 && a2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (let n3 of a2) {
              let { geometry: i3, index: a3, sourceLayerIndex: s2 } = n3;
              if (this.hasPattern) {
                let t3 = yo("fill", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n3, i3, a3, r2, {});
              e2.featureIndex.insert(t2[a3].feature, i3, a3, s2, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e2, r2) {
            for (let t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e2, r2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Es), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t2, e2, r2, n2, i2) {
            for (let t3 of ho(e2, 500)) {
              let e3 = 0;
              for (let r4 of t3)
                e3 += r4.length;
              let r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], a2 = [];
              for (let e4 of t3) {
                if (e4.length === 0)
                  continue;
                e4 !== t3[0] && a2.push(i3.length / 2);
                let r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                for (let t4 = 1; t4 < e4.length; t4++)
                  this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
              }
              let s2 = Fs.exports(i3, a2);
              for (let t4 = 0; t4 < s2.length; t4 += 3)
                this.indexArray.emplaceBack(n3 + s2[t4], n3 + s2[t4 + 1], n3 + s2[t4 + 2]);
              r3.vertexLength += e3, r3.primitiveLength += s2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        Mn("FillBucket", mo, { omit: ["layers", "patternFeatures"] });
        let go = new fi({ "fill-sort-key": new ui(nt.layout_fill["fill-sort-key"]) });
        var xo = { paint: new fi({ "fill-antialias": new li(nt.paint_fill["fill-antialias"]), "fill-opacity": new ui(nt.paint_fill["fill-opacity"]), "fill-color": new ui(nt.paint_fill["fill-color"]), "fill-outline-color": new ui(nt.paint_fill["fill-outline-color"]), "fill-translate": new li(nt.paint_fill["fill-translate"]), "fill-translate-anchor": new li(nt.paint_fill["fill-translate-anchor"]), "fill-pattern": new ci(nt.paint_fill["fill-pattern"]) }), layout: go };
        let vo = vi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), bo = vi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: wo } = vo;
        var _o = {}, Ao = S, ko = So;
        function So(t2, e2, r2, n2, i2) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Io, this, e2);
        }
        function Io(t2, e2, r2) {
          t2 == 1 ? e2.id = r2.readVarint() : t2 == 2 ? function(t3, e3) {
            for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
              e3.properties[n2] = i2;
            }
          }(r2, e2) : t2 == 3 ? e2.type = r2.readVarint() : t2 == 4 && (e2._geometry = r2.pos);
        }
        function Mo(t2) {
          for (var e2, r2, n2 = 0, i2 = 0, a2 = t2.length, s2 = a2 - 1; i2 < a2; s2 = i2++)
            n2 += ((r2 = t2[s2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
          return n2;
        }
        So.types = ["Unknown", "Point", "LineString", "Polygon"], So.prototype.loadGeometry = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, a2 = 0, s2 = 0, o2 = []; t2.pos < r2; ) {
            if (i2 <= 0) {
              var l2 = t2.readVarint();
              n2 = 7 & l2, i2 = l2 >> 3;
            }
            if (i2--, n2 === 1 || n2 === 2)
              a2 += t2.readSVarint(), s2 += t2.readSVarint(), n2 === 1 && (e2 && o2.push(e2), e2 = []), e2.push(new Ao(a2, s2));
            else {
              if (n2 !== 7)
                throw new Error("unknown command " + n2);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && o2.push(e2), o2;
        }, So.prototype.bbox = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, a2 = 0, s2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
            if (n2 <= 0) {
              var c2 = t2.readVarint();
              r2 = 7 & c2, n2 = c2 >> 3;
            }
            if (n2--, r2 === 1 || r2 === 2)
              (i2 += t2.readSVarint()) < s2 && (s2 = i2), i2 > o2 && (o2 = i2), (a2 += t2.readSVarint()) < l2 && (l2 = a2), a2 > u2 && (u2 = a2);
            else if (r2 !== 7)
              throw new Error("unknown command " + r2);
          }
          return [s2, l2, o2, u2];
        }, So.prototype.toGeoJSON = function(t2, e2, r2) {
          var n2, i2, a2 = this.extent * Math.pow(2, r2), s2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = So.types[this.type];
          function c2(t3) {
            for (var e3 = 0; e3 < t3.length; e3++) {
              var r3 = t3[e3];
              t3[e3] = [360 * (r3.x + s2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / a2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n2 = 0; n2 < l2.length; n2++)
                h2[n2] = l2[n2][0];
              c2(l2 = h2);
              break;
            case 2:
              for (n2 = 0; n2 < l2.length; n2++)
                c2(l2[n2]);
              break;
            case 3:
              for (l2 = function(t3) {
                var e3 = t3.length;
                if (e3 <= 1)
                  return [t3];
                for (var r3, n3, i3 = [], a3 = 0; a3 < e3; a3++) {
                  var s3 = Mo(t3[a3]);
                  s3 !== 0 && (n3 === void 0 && (n3 = s3 < 0), n3 === s3 < 0 ? (r3 && i3.push(r3), r3 = [t3[a3]]) : r3.push(t3[a3]));
                }
                return r3 && i3.push(r3), i3;
              }(l2), n2 = 0; n2 < l2.length; n2++)
                for (i2 = 0; i2 < l2[n2].length; i2++)
                  c2(l2[n2][i2]);
          }
          l2.length === 1 ? l2 = l2[0] : u2 = "Multi" + u2;
          var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
          return "id" in this && (p2.id = this.id), p2;
        };
        var zo = ko, Bo = Co;
        function Co(t2, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Po, this, e2), this.length = this._features.length;
        }
        function Po(t2, e2, r2) {
          t2 === 15 ? e2.version = r2.readVarint() : t2 === 1 ? e2.name = r2.readString() : t2 === 5 ? e2.extent = r2.readVarint() : t2 === 2 ? e2._features.push(r2.pos) : t2 === 3 ? e2._keys.push(r2.readString()) : t2 === 4 && e2._values.push(function(t3) {
            for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = t3.readVarint() >> 3;
              e3 = n2 === 1 ? t3.readString() : n2 === 2 ? t3.readFloat() : n2 === 3 ? t3.readDouble() : n2 === 4 ? t3.readVarint64() : n2 === 5 ? t3.readVarint() : n2 === 6 ? t3.readSVarint() : n2 === 7 ? t3.readBoolean() : null;
            }
            return e3;
          }(r2));
        }
        Co.prototype.feature = function(t2) {
          if (t2 < 0 || t2 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t2];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new zo(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var Vo = Bo;
        function Eo(t2, e2, r2) {
          if (t2 === 3) {
            var n2 = new Vo(r2, r2.readVarint() + r2.pos);
            n2.length && (e2[n2.name] = n2);
          }
        }
        _o.VectorTile = function(t2, e2) {
          this.layers = t2.readFields(Eo, {}, e2);
        }, _o.VectorTileFeature = ko, _o.VectorTileLayer = Bo;
        let Fo = _o.VectorTileFeature.types, To = Math.pow(2, 13);
        function Lo(t2, e2, r2, n2, i2, a2, s2, o2) {
          t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * To) + s2, i2 * To * 2, a2 * To * 2, Math.round(o2));
        }
        class Do {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = !1, this.layoutVertexArray = new ra(), this.centroidVertexArray = new Qi(), this.indexArray = new ha(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.segments = new ya(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.features = [], this.hasPattern = fo("fill-extrusion", this.layers, e2);
            for (let { feature: n2, id: i2, index: a2, sourceLayerIndex: s2 } of t2) {
              let t3 = this.layers[0]._featureFilter.needGeometry, o2 = Ka(n2, t3);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), o2, r2))
                continue;
              let l2 = { id: i2, sourceLayerIndex: s2, index: a2, geometry: t3 ? o2.geometry : Za(n2), properties: n2.properties, type: n2.type, patterns: {} };
              this.hasPattern ? this.features.push(yo("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, a2, r2, {}), e2.featureIndex.insert(n2, l2.geometry, a2, s2, this.index, !0);
            }
          }
          addFeatures(t2, e2, r2) {
            for (let t3 of this.features) {
              let { geometry: n2 } = t3;
              this.addFeature(t3, n2, t3.index, e2, r2);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, wo), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, bo.members, !0), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t2, e2, r2, n2, i2) {
            let a2 = { x: 0, y: 0, vertexCount: 0 };
            for (let r3 of ho(e2, 500)) {
              let e3 = 0;
              for (let t3 of r3)
                e3 += t3.length;
              let n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (let t3 of r3) {
                if (t3.length === 0 || Ro(t3))
                  continue;
                let e4 = 0;
                for (let r4 = 0; r4 < t3.length; r4++) {
                  let i4 = t3[r4];
                  if (r4 >= 1) {
                    let s3 = t3[r4 - 1];
                    if (!$o(i4, s3)) {
                      n3.vertexLength + 4 > ya.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      let t4 = i4.sub(s3)._perp()._unit(), r5 = s3.dist(i4);
                      e4 + r5 > 32768 && (e4 = 0), Lo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 0, e4), Lo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 1, e4), a2.x += 2 * i4.x, a2.y += 2 * i4.y, a2.vertexCount += 2, e4 += r5, Lo(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 0, e4), Lo(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 1, e4), a2.x += 2 * s3.x, a2.y += 2 * s3.y, a2.vertexCount += 2;
                      let o3 = n3.vertexLength;
                      this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                    }
                  }
                }
              }
              if (n3.vertexLength + e3 > ya.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), Fo[t2.type] !== "Polygon")
                continue;
              let i3 = [], s2 = [], o2 = n3.vertexLength;
              for (let t3 of r3)
                if (t3.length !== 0) {
                  t3 !== r3[0] && s2.push(i3.length / 2);
                  for (let e4 = 0; e4 < t3.length; e4++) {
                    let r4 = t3[e4];
                    Lo(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), a2.x += r4.x, a2.y += r4.y, a2.vertexCount += 1, i3.push(r4.x), i3.push(r4.y);
                  }
                }
              let l2 = Fs.exports(i3, s2);
              for (let t3 = 0; t3 < l2.length; t3 += 3)
                this.indexArray.emplaceBack(o2 + l2[t3], o2 + l2[t3 + 2], o2 + l2[t3 + 1]);
              n3.primitiveLength += l2.length / 3, n3.vertexLength += e3;
            }
            for (let t3 = 0; t3 < a2.vertexCount; t3++)
              this.centroidVertexArray.emplaceBack(Math.floor(a2.x / a2.vertexCount), Math.floor(a2.y / a2.vertexCount));
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        function $o(t2, e2) {
          return t2.x === e2.x && (t2.x < 0 || t2.x > qa) || t2.y === e2.y && (t2.y < 0 || t2.y > qa);
        }
        function Ro(t2) {
          return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > qa) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > qa);
        }
        Mn("FillExtrusionBucket", Do, { omit: ["layers", "features"] });
        var Oo = { paint: new fi({ "fill-extrusion-opacity": new li(nt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ui(nt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new li(nt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new li(nt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ci(nt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ui(nt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ui(nt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new li(nt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
        function Uo(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function qo(t2, e2) {
          if (t2.length === 1) {
            let r2 = 0, n2 = e2[r2++], i2;
            for (; !i2 || n2.equals(i2); )
              if (i2 = e2[r2++], !i2)
                return 1 / 0;
            for (; r2 < e2.length; r2++) {
              let a2 = e2[r2], s2 = t2[0], o2 = i2.sub(n2), l2 = a2.sub(n2), u2 = s2.sub(n2), c2 = Uo(o2, o2), h2 = Uo(o2, l2), p2 = Uo(l2, l2), f2 = Uo(u2, o2), d2 = Uo(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + a2.z * g2;
              if (isFinite(x2))
                return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (let r2 of e2)
              t3 = Math.min(t3, r2.z);
            return t3;
          }
        }
        let jo = vi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: No } = jo, Zo = vi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Ko } = Zo, Go = _o.VectorTileFeature.types, Jo = Math.cos(Math.PI / 180 * 37.5), Xo = Math.pow(2, 14) / 0.5;
        class Yo {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
              this.gradients[t3.id] = {};
            }), this.layoutVertexArray = new na(), this.layoutVertexArray2 = new ia(), this.indexArray = new ha(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.segments = new ya(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.hasPattern = fo("line", this.layers, e2);
            let n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), a2 = [];
            for (let { feature: e3, id: s2, index: o2, sourceLayerIndex: l2 } of t2) {
              let t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ka(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), u2, r2))
                continue;
              let c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: s2, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Za(e3), patterns: {}, sortKey: c2 };
              a2.push(h2);
            }
            i2 && a2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (let n3 of a2) {
              let { geometry: i3, index: a3, sourceLayerIndex: s2 } = n3;
              if (this.hasPattern) {
                let t3 = yo("line", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n3, i3, a3, r2, {});
              e2.featureIndex.insert(t2[a3].feature, i3, a3, s2, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e2, r2) {
            for (let t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e2, r2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ko)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, No), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2) {
            if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
              return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }
          addFeature(t2, e2, r2, n2, i2) {
            let a2 = this.layers[0].layout, s2 = a2.get("line-join").evaluate(t2, {}), o2 = a2.get("line-cap"), l2 = a2.get("line-miter-limit"), u2 = a2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (let r3 of e2)
              this.addLine(r3, t2, s2, o2, l2, u2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
          addLine(t2, e2, r2, n2, i2, a2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t2.length - 1; e3++)
                this.totalDistance += t2[e3].dist(t2[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            let s2 = Go[e2.type] === "Polygon", o2 = t2.length;
            for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
              o2--;
            let l2 = 0;
            for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
              l2++;
            if (o2 < (s2 ? 3 : 2))
              return;
            r2 === "bevel" && (i2 = 1.05);
            let u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray), h2, p2, f2, d2, y2;
            this.e1 = this.e2 = -1, s2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
            for (let e3 = l2; e3 < o2; e3++) {
              if (f2 = e3 === o2 - 1 ? s2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2))
                continue;
              y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
              let m2 = d2.add(y2);
              m2.x === 0 && m2.y === 0 || m2._unit();
              let g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = x2 !== 0 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Jo && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
              if (w2 && e3 > l2) {
                let t3 = h2.dist(p2);
                if (t3 > 2 * u2) {
                  let e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                  this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
                }
              }
              let A2 = p2 && f2, k2 = A2 ? r2 : s2 ? "butt" : n2;
              if (A2 && k2 === "round" && (v2 < a2 ? k2 = "miter" : v2 <= 2 && (k2 = "fakeround")), k2 === "miter" && v2 > i2 && (k2 = "bevel"), k2 === "bevel" && (v2 > 2 && (k2 = "flipbevel"), v2 < i2 && (k2 = "miter")), p2 && this.updateDistance(p2, h2), k2 === "miter")
                m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if (k2 === "flipbevel") {
                if (v2 > 100)
                  m2 = y2.mult(-1);
                else {
                  let t3 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                  m2._perp()._mult(t3 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
              } else if (k2 === "bevel" || k2 === "fakeround") {
                let t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), k2 === "fakeround") {
                  let t4 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e5 = 1; e5 < t4; e5++) {
                    let r4 = e5 / t4;
                    if (r4 !== 0.5) {
                      let t5 = r4 - 0.5;
                      r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    let n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h2, n3.x, n3.y, !1, _2, 0, c2);
                  }
                }
                f2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
              } else if (k2 === "butt")
                this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if (k2 === "square") {
                let t3 = p2 ? 1 : -1;
                this.addCurrentVertex(h2, m2, t3, t3, c2);
              } else
                k2 === "round" && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, !0)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, !0), this.addCurrentVertex(h2, y2, 0, 0, c2)));
              if (w2 && e3 < o2 - 1) {
                let t3 = h2.dist(f2);
                if (t3 > 2 * u2) {
                  let e4 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                  this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
                }
              }
            }
          }
          addCurrentVertex(t2, e2, r2, n2, i2, a2 = !1) {
            let s2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
            this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, a2, !1, r2, i2), this.addHalfVertex(t2, s2, o2, a2, !0, -n2, i2), this.distance > Xo / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(t2, e2, r2, n2, i2, a2));
          }
          addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, a2, s2, o2) {
            let l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Xo - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (a2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (s2 === 0 ? 0 : s2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            let u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), a2 ? this.e2 = u2 : this.e1 = u2;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t2, e2) {
            this.distance += t2.dist(e2), this.updateScaledDistance();
          }
        }
        Mn("LineBucket", Yo, { omit: ["layers", "patternFeatures"] });
        let Ho = new fi({ "line-cap": new li(nt.layout_line["line-cap"]), "line-join": new ui(nt.layout_line["line-join"]), "line-miter-limit": new li(nt.layout_line["line-miter-limit"]), "line-round-limit": new li(nt.layout_line["line-round-limit"]), "line-sort-key": new ui(nt.layout_line["line-sort-key"]) });
        var Wo = { paint: new fi({ "line-opacity": new ui(nt.paint_line["line-opacity"]), "line-color": new ui(nt.paint_line["line-color"]), "line-translate": new li(nt.paint_line["line-translate"]), "line-translate-anchor": new li(nt.paint_line["line-translate-anchor"]), "line-width": new ui(nt.paint_line["line-width"]), "line-gap-width": new ui(nt.paint_line["line-gap-width"]), "line-offset": new ui(nt.paint_line["line-offset"]), "line-blur": new ui(nt.paint_line["line-blur"]), "line-dasharray": new hi(nt.paint_line["line-dasharray"]), "line-pattern": new ci(nt.paint_line["line-pattern"]), "line-gradient": new pi(nt.paint_line["line-gradient"]) }), layout: Ho };
        let Qo = new class extends ui {
          possiblyEvaluate(t2, e2) {
            return e2 = new Qn(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
          }
          evaluate(t2, e2, r2, n2) {
            return e2 = o({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
          }
        }(Wo.paint.properties["line-width"].specification);
        function tl(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        Qo.useIntegerZoom = !0;
        let el = vi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), rl = vi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        vi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        let nl = vi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
        vi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        let il = vi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), al = vi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function sl(t2, e2, r2) {
          return t2.sections.forEach((t3) => {
            t3.text = function(t4, e3, r3) {
              let n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return n2 === "uppercase" ? t4 = t4.toLocaleUpperCase() : n2 === "lowercase" && (t4 = t4.toLocaleLowerCase()), Wn.applyArabicShaping && (t4 = Wn.applyArabicShaping(t4)), t4;
            }(t3.text, e2, r2);
          }), t2;
        }
        vi([{ name: "triangle", components: 3, type: "Uint16" }]), vi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), vi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), vi([{ type: "Float32", name: "offsetX" }]), vi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
        let ol = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var ll = 24, ul = pl, cl = function(t2, e2, r2, n2, i2) {
          var a2, s2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
          for (h2 += p2, a2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
            ;
          for (s2 = a2 & (1 << -c2) - 1, a2 >>= -c2, c2 += n2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
            ;
          if (a2 === 0)
            a2 = 1 - u2;
          else {
            if (a2 === l2)
              return s2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            s2 += Math.pow(2, n2), a2 -= u2;
          }
          return (f2 ? -1 : 1) * s2 * Math.pow(2, a2 - n2);
        }, hl = function(t2, e2, r2, n2, i2, a2) {
          var s2, o2, l2, u2 = 8 * a2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : a2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, s2 = c2) : (s2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -s2)) < 1 && (s2--, l2 *= 2), (e2 += s2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (s2++, l2 /= 2), s2 + h2 >= c2 ? (o2 = 0, s2 = c2) : s2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), s2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), s2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
            ;
          for (s2 = s2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & s2, f2 += d2, s2 /= 256, u2 -= 8)
            ;
          t2[r2 + f2 - d2] |= 128 * y2;
        };
        function pl(t2) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        pl.Varint = 0, pl.Fixed64 = 1, pl.Bytes = 2, pl.Fixed32 = 5;
        var fl, dl = 4294967296, yl = 1 / dl, ml = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
        function gl(t2) {
          return t2.type === pl.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
        }
        function xl(t2, e2, r2) {
          return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function vl(t2, e2, r2) {
          var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (var i2 = r2.pos - 1; i2 >= t2; i2--)
            r2.buf[i2 + n2] = r2.buf[i2];
        }
        function bl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeVarint(t2[r2]);
        }
        function wl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSVarint(t2[r2]);
        }
        function _l(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFloat(t2[r2]);
        }
        function Al(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeDouble(t2[r2]);
        }
        function kl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeBoolean(t2[r2]);
        }
        function Sl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed32(t2[r2]);
        }
        function Il(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed32(t2[r2]);
        }
        function Ml(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed64(t2[r2]);
        }
        function zl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed64(t2[r2]);
        }
        function Bl(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
        }
        function Cl(t2, e2, r2) {
          t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
        }
        function Pl(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
        }
        function Vl(t2, e2, r2) {
          t2 === 1 && r2.readMessage(El, e2);
        }
        function El(t2, e2, r2) {
          if (t2 === 3) {
            let { id: t3, bitmap: n2, width: i2, height: a2, left: s2, top: o2, advance: l2 } = r2.readMessage(Fl, {});
            e2.push({ id: t3, bitmap: new zs({ width: i2 + 6, height: a2 + 6 }, n2), metrics: { width: i2, height: a2, left: s2, top: o2, advance: l2 } });
          }
        }
        function Fl(t2, e2, r2) {
          t2 === 1 ? e2.id = r2.readVarint() : t2 === 2 ? e2.bitmap = r2.readBytes() : t2 === 3 ? e2.width = r2.readVarint() : t2 === 4 ? e2.height = r2.readVarint() : t2 === 5 ? e2.left = r2.readSVarint() : t2 === 6 ? e2.top = r2.readSVarint() : t2 === 7 && (e2.advance = r2.readVarint());
        }
        function Tl(t2) {
          let e2 = 0, r2 = 0;
          for (let n3 of t2)
            e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
          t2.sort((t3, e3) => e3.h - t3.h);
          let n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }], i2 = 0, a2 = 0;
          for (let e3 of t2)
            for (let t3 = n2.length - 1; t3 >= 0; t3--) {
              let r3 = n2[t3];
              if (!(e3.w > r3.w || e3.h > r3.h)) {
                if (e3.x = r3.x, e3.y = r3.y, a2 = Math.max(a2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                  let e4 = n2.pop();
                  t3 < n2.length && (n2[t3] = e4);
                } else
                  e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                break;
              }
            }
          return { w: i2, h: a2, fill: e2 / (i2 * a2) || 0 };
        }
        pl.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t2, e2, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n2 = this.readVarint(), i2 = n2 >> 3, a2 = this.pos;
            this.type = 7 & n2, t2(i2, e2, this), this.pos === a2 && this.skip(n2);
          }
          return e2;
        }, readMessage: function(t2, e2) {
          return this.readFields(t2, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t2 = Bl(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readSFixed32: function() {
          var t2 = Pl(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readFixed64: function() {
          var t2 = Bl(this.buf, this.pos) + Bl(this.buf, this.pos + 4) * dl;
          return this.pos += 8, t2;
        }, readSFixed64: function() {
          var t2 = Bl(this.buf, this.pos) + Pl(this.buf, this.pos + 4) * dl;
          return this.pos += 8, t2;
        }, readFloat: function() {
          var t2 = cl(this.buf, this.pos, !0, 23, 4);
          return this.pos += 4, t2;
        }, readDouble: function() {
          var t2 = cl(this.buf, this.pos, !0, 52, 8);
          return this.pos += 8, t2;
        }, readVarint: function(t2) {
          var e2, r2, n2 = this.buf;
          return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
            var n3, i2, a2 = r3.buf;
            if (n3 = (112 & (i2 = a2[r3.pos++])) >> 4, i2 < 128 || (n3 |= (127 & (i2 = a2[r3.pos++])) << 3, i2 < 128) || (n3 |= (127 & (i2 = a2[r3.pos++])) << 10, i2 < 128) || (n3 |= (127 & (i2 = a2[r3.pos++])) << 17, i2 < 128) || (n3 |= (127 & (i2 = a2[r3.pos++])) << 24, i2 < 128) || (n3 |= (1 & (i2 = a2[r3.pos++])) << 31, i2 < 128))
              return xl(t3, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
        }, readVarint64: function() {
          return this.readVarint(!0);
        }, readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t2, t2 - e2 >= 12 && ml ? function(t3, e3, r2) {
            return ml.decode(t3.subarray(e3, r2));
          }(this.buf, e2, t2) : function(t3, e3, r2) {
            for (var n2 = "", i2 = e3; i2 < r2; ) {
              var a2, s2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i2 + c2 > r2)
                break;
              c2 === 1 ? l2 < 128 && (u2 = l2) : c2 === 2 ? (192 & (a2 = t3[i2 + 1])) == 128 && (u2 = (31 & l2) << 6 | 63 & a2) <= 127 && (u2 = null) : c2 === 3 ? (s2 = t3[i2 + 2], (192 & (a2 = t3[i2 + 1])) == 128 && (192 & s2) == 128 && ((u2 = (15 & l2) << 12 | (63 & a2) << 6 | 63 & s2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : c2 === 4 && (s2 = t3[i2 + 2], o2 = t3[i2 + 3], (192 & (a2 = t3[i2 + 1])) == 128 && (192 & s2) == 128 && (192 & o2) == 128 && ((u2 = (15 & l2) << 18 | (63 & a2) << 12 | (63 & s2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), u2 === null ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
            }
            return n2;
          }(this.buf, e2, t2);
        }, readBytes: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e2;
        }, readPackedVarint: function(t2, e2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readVarint(e2));
          var r2 = gl(this);
          for (t2 = t2 || []; this.pos < r2; )
            t2.push(this.readVarint(e2));
          return t2;
        }, readPackedSVarint: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readSVarint());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSVarint());
          return t2;
        }, readPackedBoolean: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readBoolean());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readBoolean());
          return t2;
        }, readPackedFloat: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readFloat());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFloat());
          return t2;
        }, readPackedDouble: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readDouble());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readDouble());
          return t2;
        }, readPackedFixed32: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readFixed32());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed32());
          return t2;
        }, readPackedSFixed32: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readSFixed32());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed32());
          return t2;
        }, readPackedFixed64: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readFixed64());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed64());
          return t2;
        }, readPackedSFixed64: function(t2) {
          if (this.type !== pl.Bytes)
            return t2.push(this.readSFixed64());
          var e2 = gl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed64());
          return t2;
        }, skip: function(t2) {
          var e2 = 7 & t2;
          if (e2 === pl.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e2 === pl.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e2 === pl.Fixed32)
            this.pos += 4;
          else {
            if (e2 !== pl.Fixed64)
              throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t2, e2) {
          this.writeVarint(t2 << 3 | e2);
        }, realloc: function(t2) {
          for (var e2 = this.length || 16; e2 < this.pos + t2; )
            e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t2) {
          this.realloc(4), Cl(this.buf, t2, this.pos), this.pos += 4;
        }, writeSFixed32: function(t2) {
          this.realloc(4), Cl(this.buf, t2, this.pos), this.pos += 4;
        }, writeFixed64: function(t2) {
          this.realloc(8), Cl(this.buf, -1 & t2, this.pos), Cl(this.buf, Math.floor(t2 * yl), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t2) {
          this.realloc(8), Cl(this.buf, -1 & t2, this.pos), Cl(this.buf, Math.floor(t2 * yl), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
            var r2, n2;
            if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t4, e3, r3) {
              r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
            }(r2, 0, e2), function(t4, e3) {
              var r3 = (7 & t4) << 4;
              e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
            }(n2, e2);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        }, writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        }, writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        }, writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t3, e3, r3) {
            for (var n2, i2, a2 = 0; a2 < e3.length; a2++) {
              if ((n2 = e3.charCodeAt(a2)) > 55295 && n2 < 57344) {
                if (!i2) {
                  n2 > 56319 || a2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                  continue;
                }
                n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
              } else
                i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
              n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t2, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && vl(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t2) {
          this.realloc(4), hl(this.buf, t2, this.pos, !0, 23, 4), this.pos += 4;
        }, writeDouble: function(t2) {
          this.realloc(8), hl(this.buf, t2, this.pos, !0, 52, 8), this.pos += 8;
        }, writeBytes: function(t2) {
          var e2 = t2.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0; r2 < e2; r2++)
            this.buf[this.pos++] = t2[r2];
        }, writeRawMessage: function(t2, e2) {
          this.pos++;
          var r2 = this.pos;
          t2(e2, this);
          var n2 = this.pos - r2;
          n2 >= 128 && vl(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t2, e2, r2) {
          this.writeTag(t2, pl.Bytes), this.writeRawMessage(e2, r2);
        }, writePackedVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, bl, e2);
        }, writePackedSVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, wl, e2);
        }, writePackedBoolean: function(t2, e2) {
          e2.length && this.writeMessage(t2, kl, e2);
        }, writePackedFloat: function(t2, e2) {
          e2.length && this.writeMessage(t2, _l, e2);
        }, writePackedDouble: function(t2, e2) {
          e2.length && this.writeMessage(t2, Al, e2);
        }, writePackedFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, Sl, e2);
        }, writePackedSFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, Il, e2);
        }, writePackedFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ml, e2);
        }, writePackedSFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, zl, e2);
        }, writeBytesField: function(t2, e2) {
          this.writeTag(t2, pl.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t2, e2) {
          this.writeTag(t2, pl.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t2, e2) {
          this.writeTag(t2, pl.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t2, e2) {
          this.writeTag(t2, pl.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t2, e2) {
          this.writeTag(t2, pl.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t2, e2) {
          this.writeTag(t2, pl.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t2, e2) {
          this.writeTag(t2, pl.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t2, e2) {
          this.writeTag(t2, pl.Bytes), this.writeString(e2);
        }, writeFloatField: function(t2, e2) {
          this.writeTag(t2, pl.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t2, e2) {
          this.writeTag(t2, pl.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t2, e2) {
          this.writeVarintField(t2, Boolean(e2));
        } };
        class Ll {
          constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: a2 }) {
            this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = a2, this.version = r2;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Dl {
          constructor(t2, e2) {
            let r2 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            let i2 = [];
            this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
            let { w: a2, h: s2 } = Tl(i2), o2 = new Bs({ width: a2 || 1, height: s2 || 1 });
            for (let e3 in t2) {
              let n3 = t2[e3], i3 = r2[e3].paddedRect;
              Bs.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
            }
            for (let t3 in e2) {
              let r3 = e2[t3], i3 = n2[t3].paddedRect, a3 = i3.x + 1, s3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
              Bs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3, y: s3 }, r3.data), Bs.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: a3, y: s3 - 1 }, { width: l2, height: 1 }), Bs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3, y: s3 + u2 }, { width: l2, height: 1 }), Bs.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: a3 - 1, y: s3 }, { width: 1, height: u2 }), Bs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3 + l2, y: s3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
          }
          addImages(t2, e2, r2) {
            for (let n2 in t2) {
              let i2 = t2[n2], a2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
              r2.push(a2), e2[n2] = new Ll(a2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t2, e2) {
            t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (let r2 in t2.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
          }
          patchUpdatedImage(t2, e2, r2) {
            if (!t2 || !e2 || t2.version === e2.version)
              return;
            t2.version = e2.version;
            let [n2, i2] = t2.tl;
            r2.update(e2.data, void 0, { x: n2, y: i2 });
          }
        }
        Mn("ImagePosition", Ll), Mn("ImageAtlas", Dl), t.WritingMode = void 0, (fl = t.WritingMode || (t.WritingMode = {}))[fl.none = 0] = "none", fl[fl.horizontal = 1] = "horizontal", fl[fl.vertical = 2] = "vertical", fl[fl.horizontalOnly = 3] = "horizontalOnly";
        let $l = -17;
        class Rl {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t2, e2) {
            let r2 = new Rl();
            return r2.scale = t2 || 1, r2.fontStack = e2, r2;
          }
          static forImage(t2) {
            let e2 = new Rl();
            return e2.imageName = t2, e2;
          }
        }
        class Ol {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t2, e2) {
            let r2 = new Ol();
            for (let n2 = 0; n2 < t2.sections.length; n2++) {
              let i2 = t2.sections[n2];
              i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
            }
            return r2;
          }
          length() {
            return this.text.length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          getCharCode(t2) {
            return this.text.charCodeAt(t2);
          }
          verticalizePunctuation() {
            this.text = function(t2) {
              let e2 = "";
              for (let r2 = 0; r2 < t2.length; r2++) {
                let n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                e2 += n2 && Dn(n2) && !ol[t2[r2 + 1]] || i2 && Dn(i2) && !ol[t2[r2 - 1]] || !ol[t2[r2]] ? t2[r2] : ol[t2[r2]];
              }
              return e2;
            }(this.text);
          }
          trim() {
            let t2 = 0;
            for (let e3 = 0; e3 < this.text.length && ql[this.text.charCodeAt(e3)]; e3++)
              t2++;
            let e2 = this.text.length;
            for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && ql[this.text.charCodeAt(r2)]; r2--)
              e2--;
            this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
          }
          substring(t2, e2) {
            let r2 = new Ol();
            return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
          }
          addTextSection(t2, e2) {
            this.text += t2.text, this.sections.push(Rl.forText(t2.scale, t2.fontStack || e2));
            let r2 = this.sections.length - 1;
            for (let e3 = 0; e3 < t2.text.length; ++e3)
              this.sectionIndex.push(r2);
          }
          addImageSection(t2) {
            let e2 = t2.image ? t2.image.name : "";
            if (e2.length === 0)
              return void d("Can't add FormattedSection with an empty image.");
            let r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Rl.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : d("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Ul(e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
          let g2 = Ol.fromFeature(e2, a2), x2;
          p2 === t.WritingMode.vertical && g2.verticalizePunctuation();
          let { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = Wn;
          if (v2 && g2.sections.length === 1) {
            x2 = [];
            let t2 = v2(g2.toString(), Xl(g2, c2, s2, r2, i2, d2, y2));
            for (let e3 of t2) {
              let t3 = new Ol();
              t3.text = e3, t3.sections = g2.sections;
              for (let r3 = 0; r3 < e3.length; r3++)
                t3.sectionIndex.push(0);
              x2.push(t3);
            }
          } else if (b2) {
            x2 = [];
            let t2 = b2(g2.text, g2.sectionIndex, Xl(g2, c2, s2, r2, i2, d2, y2));
            for (let e3 of t2) {
              let t3 = new Ol();
              t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = g2.sections, x2.push(t3);
            }
          } else
            x2 = function(t2, e3) {
              let r3 = [], n3 = t2.text, i3 = 0;
              for (let n4 of e3)
                r3.push(t2.substring(i3, n4)), i3 = n4;
              return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
            }(g2, Xl(g2, c2, s2, r2, i2, d2, y2));
          let w2 = [], _2 = { positionedLines: w2, text: g2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: !1, verticalizable: !1 };
          return function(e3, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
            let f3 = 0, d3 = $l, y3 = 0, m3 = 0, g3 = l3 === "right" ? 1 : l3 === "left" ? 0 : 0.5, x3 = 0;
            for (let o4 of a3) {
              o4.trim();
              let a4 = o4.getMaxScale(), l4 = (a4 - 1) * ll, b4 = { positionedGlyphs: [], lineOffset: 0 };
              e3.positionedLines[x3] = b4;
              let w4 = b4.positionedGlyphs, _4 = 0;
              if (!o4.length()) {
                d3 += s3, ++x3;
                continue;
              }
              for (let s4 = 0; s4 < o4.length(); s4++) {
                let y4 = o4.getSection(s4), m4 = o4.getSectionIndex(s4), g4 = o4.getCharCode(s4), x4 = 0, b5 = null, A3 = null, k2 = null, S2 = ll, I2 = !(u3 === t.WritingMode.horizontal || !h3 && !Ln(g4) || h3 && (ql[g4] || (v3 = g4, Vn.Arabic(v3) || Vn["Arabic Supplement"](v3) || Vn["Arabic Extended-A"](v3) || Vn["Arabic Presentation Forms-A"](v3) || Vn["Arabic Presentation Forms-B"](v3))));
                if (y4.imageName) {
                  let t2 = i3[y4.imageName];
                  if (!t2)
                    continue;
                  k2 = y4.imageName, e3.iconsInText = e3.iconsInText || !0, A3 = t2.paddedRect;
                  let r4 = t2.displaySize;
                  y4.scale = y4.scale * ll / p3, b5 = { width: r4[0], height: r4[1], left: 1, top: -3, advance: I2 ? r4[1] : r4[0] }, x4 = l4 + (ll - r4[1] * y4.scale), S2 = b5.advance;
                  let n4 = I2 ? r4[0] * y4.scale - ll * a4 : r4[1] * y4.scale - ll * a4;
                  n4 > 0 && n4 > _4 && (_4 = n4);
                } else {
                  let t2 = n3[y4.fontStack], e4 = t2 && t2[g4];
                  if (e4 && e4.rect)
                    A3 = e4.rect, b5 = e4.metrics;
                  else {
                    let t3 = r3[y4.fontStack], e5 = t3 && t3[g4];
                    if (!e5)
                      continue;
                    b5 = e5.metrics;
                  }
                  x4 = (a4 - y4.scale) * ll;
                }
                I2 ? (e3.verticalizable = !0, w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x4, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += S2 * y4.scale + c3) : (w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x4, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += b5.advance * y4.scale + c3);
              }
              w4.length !== 0 && (y3 = Math.max(f3 - c3, y3), Hl(w4, 0, w4.length - 1, g3, _4)), f3 = 0;
              let A2 = s3 * a4 + _4;
              b4.lineOffset = Math.max(_4, l4), d3 += A2, m3 = Math.max(A2, m3), ++x3;
            }
            var v3;
            let b3 = d3 - $l, { horizontalAlign: w3, verticalAlign: _3 } = Yl(o3);
            (function(t2, e4, r4, n4, i4, a4, s4, o4, l4) {
              let u4 = (e4 - r4) * i4, c4 = 0;
              c4 = a4 !== s4 ? -o4 * n4 - $l : (-n4 * l4 + 0.5) * s4;
              for (let e5 of t2)
                for (let t3 of e5.positionedGlyphs)
                  t3.x += u4, t3.y += c4;
            })(e3.positionedLines, g3, w3, _3, y3, m3, s3, b3, a3.length), e3.top += -_3 * b3, e3.bottom = e3.top + b3, e3.left += -w3 * y3, e3.right = e3.left + y3;
          }(_2, r2, n2, i2, x2, o2, l2, u2, p2, c2, f2, m2), !function(t2) {
            for (let e3 of t2)
              if (e3.positionedGlyphs.length !== 0)
                return !1;
            return !0;
          }(w2) && _2;
        }
        let ql = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, jl = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
        function Nl(t2, e2, r2, n2, i2, a2) {
          if (e2.imageName) {
            let t3 = n2[e2.imageName];
            return t3 ? t3.displaySize[0] * e2.scale * ll / a2 + i2 : 0;
          }
          {
            let n3 = r2[e2.fontStack], a3 = n3 && n3[t2];
            return a3 ? a3.metrics.advance * e2.scale + i2 : 0;
          }
        }
        function Zl(t2, e2, r2, n2) {
          let i2 = Math.pow(t2 - e2, 2);
          return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function Kl(t2, e2, r2) {
          let n2 = 0;
          return t2 === 10 && (n2 -= 1e4), r2 && (n2 += 150), t2 !== 40 && t2 !== 65288 || (n2 += 50), e2 !== 41 && e2 !== 65289 || (n2 += 50), n2;
        }
        function Gl(t2, e2, r2, n2, i2, a2) {
          let s2 = null, o2 = Zl(e2, r2, i2, a2);
          for (let t3 of n2) {
            let n3 = Zl(e2 - t3.x, r2, i2, a2) + t3.badness;
            n3 <= o2 && (s2 = t3, o2 = n3);
          }
          return { index: t2, x: e2, priorBreak: s2, badness: o2 };
        }
        function Jl(t2) {
          return t2 ? Jl(t2.priorBreak).concat(t2.index) : [];
        }
        function Xl(t2, e2, r2, n2, i2, a2, s2) {
          if (a2 !== "point")
            return [];
          if (!t2)
            return [];
          let o2 = [], l2 = function(t3, e3, r3, n3, i3, a3) {
            let s3 = 0;
            for (let r4 = 0; r4 < t3.length(); r4++) {
              let o3 = t3.getSection(r4);
              s3 += Nl(t3.getCharCode(r4), o3, n3, i3, e3, a3);
            }
            return s3 / Math.max(1, Math.ceil(s3 / r3));
          }(t2, e2, r2, n2, i2, s2), u2 = t2.text.indexOf("\u200B") >= 0, c2 = 0;
          for (let r3 = 0; r3 < t2.length(); r3++) {
            let a3 = t2.getSection(r3), p2 = t2.getCharCode(r3);
            if (ql[p2] || (c2 += Nl(p2, a3, n2, i2, e2, s2)), r3 < t2.length() - 1) {
              let e3 = !((h2 = p2) < 11904 || !(Vn["Bopomofo Extended"](h2) || Vn.Bopomofo(h2) || Vn["CJK Compatibility Forms"](h2) || Vn["CJK Compatibility Ideographs"](h2) || Vn["CJK Compatibility"](h2) || Vn["CJK Radicals Supplement"](h2) || Vn["CJK Strokes"](h2) || Vn["CJK Symbols and Punctuation"](h2) || Vn["CJK Unified Ideographs Extension A"](h2) || Vn["CJK Unified Ideographs"](h2) || Vn["Enclosed CJK Letters and Months"](h2) || Vn["Halfwidth and Fullwidth Forms"](h2) || Vn.Hiragana(h2) || Vn["Ideographic Description Characters"](h2) || Vn["Kangxi Radicals"](h2) || Vn["Katakana Phonetic Extensions"](h2) || Vn.Katakana(h2) || Vn["Vertical Forms"](h2) || Vn["Yi Radicals"](h2) || Vn["Yi Syllables"](h2)));
              (jl[p2] || e3 || a3.imageName) && o2.push(Gl(r3 + 1, c2, l2, o2, Kl(p2, t2.getCharCode(r3 + 1), e3 && u2), !1));
            }
          }
          var h2;
          return Jl(Gl(t2.length(), c2, l2, o2, 0, !0));
        }
        function Yl(t2) {
          let e2 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function Hl(t2, e2, r2, n2, i2) {
          if (!n2 && !i2)
            return;
          let a2 = t2[r2], s2 = (t2[r2].x + a2.metrics.advance * a2.scale) * n2;
          for (let n3 = e2; n3 <= r2; n3++)
            t2[n3].x -= s2, t2[n3].y += i2;
        }
        function Wl(t2, e2, r2) {
          let { horizontalAlign: n2, verticalAlign: i2 } = Yl(r2), a2 = e2[0] - t2.displaySize[0] * n2, s2 = e2[1] - t2.displaySize[1] * i2;
          return { image: t2, top: s2, bottom: s2 + t2.displaySize[1], left: a2, right: a2 + t2.displaySize[0] };
        }
        function Ql(t2, e2, r2, n2, i2, a2) {
          let s2 = t2.image, o2;
          if (s2.content) {
            let t3 = s2.content, e3 = s2.pixelRatio || 1;
            o2 = [t3[0] / e3, t3[1] / e3, s2.displaySize[0] - t3[2] / e3, s2.displaySize[1] - t3[3] / e3];
          }
          let l2 = e2.left * a2, u2 = e2.right * a2, c2, h2, p2, f2;
          r2 === "width" || r2 === "both" ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - s2.displaySize[0]) / 2, h2 = f2 + s2.displaySize[0]);
          let d2 = e2.top * a2, y2 = e2.bottom * a2;
          return r2 === "height" || r2 === "both" ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - s2.displaySize[1]) / 2, p2 = c2 + s2.displaySize[1]), { image: s2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
        }
        let tu = 128;
        function eu(t2, e2) {
          let { expression: r2 } = e2;
          if (r2.kind === "constant")
            return { kind: "constant", layoutSize: r2.evaluate(new Qn(t2 + 1)) };
          if (r2.kind === "source")
            return { kind: "source" };
          {
            let { zoomStops: e3, interpolationType: n2 } = r2, i2 = 0;
            for (; i2 < e3.length && e3[i2] <= t2; )
              i2++;
            i2 = Math.max(0, i2 - 1);
            let a2 = i2;
            for (; a2 < e3.length && e3[a2] < t2 + 1; )
              a2++;
            a2 = Math.min(e3.length - 1, a2);
            let s2 = e3[i2], o2 = e3[a2];
            return r2.kind === "composite" ? { kind: "composite", minZoom: s2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: s2, maxZoom: o2, minSize: r2.evaluate(new Qn(s2)), maxSize: r2.evaluate(new Qn(o2)), interpolationType: n2 };
          }
        }
        class ru extends S {
          constructor(t2, e2, r2, n2) {
            super(t2, e2), this.angle = r2, n2 !== void 0 && (this.segment = n2);
          }
          clone() {
            return new ru(this.x, this.y, this.angle, this.segment);
          }
        }
        function nu(t2, e2, r2, n2, i2) {
          if (e2.segment === void 0)
            return !0;
          let a2 = e2, s2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (s2--, s2 < 0)
              return !1;
            o2 -= t2[s2].dist(a2), a2 = t2[s2];
          }
          o2 += t2[s2].dist(t2[s2 + 1]), s2++;
          let l2 = [], u2 = 0;
          for (; o2 < r2 / 2; ) {
            let e3 = t2[s2], r3 = t2[s2 + 1];
            if (!r3)
              return !1;
            let a3 = t2[s2 - 1].angleTo(e3) - e3.angleTo(r3);
            for (a3 = Math.abs((a3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: a3 }), u2 += a3; o2 - l2[0].distance > n2; )
              u2 -= l2.shift().angleDelta;
            if (u2 > i2)
              return !1;
            s2++, o2 += e3.dist(r3);
          }
          return !0;
        }
        function iu(t2) {
          let e2 = 0;
          for (let r2 = 0; r2 < t2.length - 1; r2++)
            e2 += t2[r2].dist(t2[r2 + 1]);
          return e2;
        }
        function au(t2, e2, r2) {
          return t2 ? 0.6 * e2 * r2 : 0;
        }
        function su(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function ou(t2, e2, r2, n2, i2, a2) {
          let s2 = au(r2, i2, a2), o2 = su(r2, n2) * a2, l2 = 0, u2 = iu(t2) / 2;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            let n3 = t2[r3], i3 = t2[r3 + 1], a3 = n3.dist(i3);
            if (l2 + a3 > u2) {
              let c2 = (u2 - l2) / a3, h2 = Se(n3.x, i3.x, c2), p2 = Se(n3.y, i3.y, c2), f2 = new ru(h2, p2, i3.angleTo(n3), r3);
              return f2._round(), !s2 || nu(t2, f2, o2, s2, e2) ? f2 : void 0;
            }
            l2 += a3;
          }
        }
        function lu(t2, e2, r2, n2, i2, a2, s2, o2, l2) {
          let u2 = au(n2, a2, s2), c2 = su(n2, i2), h2 = c2 * s2, p2 = t2[0].x === 0 || t2[0].x === l2 || t2[0].y === 0 || t2[0].y === l2;
          return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), uu(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * a2) * s2 * o2 % e2, e2, u2, r2, h2, p2, !1, l2);
        }
        function uu(t2, e2, r2, n2, i2, a2, s2, o2, l2) {
          let u2 = a2 / 2, c2 = iu(t2), h2 = 0, p2 = e2 - r2, f2 = [];
          for (let e3 = 0; e3 < t2.length - 1; e3++) {
            let s3 = t2[e3], o3 = t2[e3 + 1], d2 = s3.dist(o3), y2 = o3.angleTo(s3);
            for (; p2 + r2 < h2 + d2; ) {
              p2 += r2;
              let m2 = (p2 - h2) / d2, g2 = Se(s3.x, o3.x, m2), x2 = Se(s3.y, o3.y, m2);
              if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                let r3 = new ru(g2, x2, y2, e3);
                r3._round(), n2 && !nu(t2, r3, a2, n2, i2) || f2.push(r3);
              }
            }
            h2 += d2;
          }
          return o2 || f2.length || s2 || (f2 = uu(t2, h2 / 2, r2, n2, i2, a2, s2, !0, l2)), f2;
        }
        function cu(t2, e2, r2, n2, i2) {
          let a2 = [];
          for (let s2 = 0; s2 < t2.length; s2++) {
            let o2 = t2[s2], l2;
            for (let t3 = 0; t3 < o2.length - 1; t3++) {
              let s3 = o2[t3], u2 = o2[t3 + 1];
              s3.x < e2 && u2.x < e2 || (s3.x < e2 ? s3 = new S(e2, s3.y + (e2 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round() : u2.x < e2 && (u2 = new S(e2, s3.y + (e2 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round()), s3.y < r2 && u2.y < r2 || (s3.y < r2 ? s3 = new S(s3.x + (r2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), r2)._round() : u2.y < r2 && (u2 = new S(s3.x + (r2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), r2)._round()), s3.x >= n2 && u2.x >= n2 || (s3.x >= n2 ? s3 = new S(n2, s3.y + (n2 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round() : u2.x >= n2 && (u2 = new S(n2, s3.y + (n2 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round()), s3.y >= i2 && u2.y >= i2 || (s3.y >= i2 ? s3 = new S(s3.x + (i2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), i2)._round() : u2.y >= i2 && (u2 = new S(s3.x + (i2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), i2)._round()), l2 && s3.equals(l2[l2.length - 1]) || (l2 = [s3], a2.push(l2)), l2.push(u2)))));
            }
          }
          return a2;
        }
        function hu(t2, e2, r2, n2) {
          let i2 = [], a2 = t2.image, s2 = a2.pixelRatio, o2 = a2.paddedRect.w - 2, l2 = a2.paddedRect.h - 2, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = a2.stretchX || [[0, o2]], p2 = a2.stretchY || [[0, l2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = o2 - d2, g2 = l2 - y2, x2 = 0, v2 = d2, b2 = 0, w2 = y2, _2 = 0, A2 = m2, k2 = 0, I2 = g2;
          if (a2.content && n2) {
            let t3 = a2.content;
            x2 = pu(h2, 0, t3[0]), b2 = pu(p2, 0, t3[1]), v2 = pu(h2, t3[0], t3[2]), w2 = pu(p2, t3[1], t3[3]), _2 = t3[0] - x2, k2 = t3[1] - b2, A2 = t3[2] - t3[0] - v2, I2 = t3[3] - t3[1] - w2;
          }
          let M2 = (n3, i3, o3, l3) => {
            let h3 = du(n3.stretch - x2, v2, u2, t2.left), p3 = yu(n3.fixed - _2, A2, n3.stretch, d2), f3 = du(i3.stretch - b2, w2, c2, t2.top), m3 = yu(i3.fixed - k2, I2, i3.stretch, y2), g3 = du(o3.stretch - x2, v2, u2, t2.left), M3 = yu(o3.fixed - _2, A2, o3.stretch, d2), z2 = du(l3.stretch - b2, w2, c2, t2.top), B2 = yu(l3.fixed - k2, I2, l3.stretch, y2), C2 = new S(h3, f3), P2 = new S(g3, f3), V2 = new S(g3, z2), E2 = new S(h3, z2), F2 = new S(p3 / s2, m3 / s2), T2 = new S(M3 / s2, B2 / s2), L2 = e2 * Math.PI / 180;
            if (L2) {
              let t3 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t3, t3, e3];
              C2._matMult(r3), P2._matMult(r3), E2._matMult(r3), V2._matMult(r3);
            }
            let D2 = n3.stretch + n3.fixed, $2 = i3.stretch + i3.fixed;
            return { tl: C2, tr: P2, bl: E2, br: V2, tex: { x: a2.paddedRect.x + 1 + D2, y: a2.paddedRect.y + 1 + $2, w: o3.stretch + o3.fixed - D2, h: l3.stretch + l3.fixed - $2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: T2, minFontScaleX: A2 / s2 / u2, minFontScaleY: I2 / s2 / c2, isSDF: r2 };
          };
          if (n2 && (a2.stretchX || a2.stretchY)) {
            let t3 = fu(h2, m2, d2), e3 = fu(p2, g2, y2);
            for (let r3 = 0; r3 < t3.length - 1; r3++) {
              let n3 = t3[r3], a3 = t3[r3 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++)
                i2.push(M2(n3, e3[t4], a3, e3[t4 + 1]));
            }
          } else
            i2.push(M2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
          return i2;
        }
        function pu(t2, e2, r2) {
          let n2 = 0;
          for (let i2 of t2)
            n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
          return n2;
        }
        function fu(t2, e2, r2) {
          let n2 = [{ fixed: -1, stretch: 0 }];
          for (let [e3, r3] of t2) {
            let t3 = n2[n2.length - 1];
            n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
          }
          return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
        }
        function du(t2, e2, r2, n2) {
          return t2 / e2 * r2 + n2;
        }
        function yu(t2, e2, r2, n2) {
          return t2 - e2 * r2 / n2;
        }
        Mn("Anchor", ru);
        class mu {
          constructor(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2) {
            if (this.boxStartIndex = t2.length, l2) {
              let t3 = a2.top, e3 = a2.bottom, r3 = a2.collisionPadding;
              r3 && (t3 -= r3[1], e3 += r3[3]);
              let n3 = e3 - t3;
              n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
            } else {
              let l3 = a2.top * s2 - o2[0], c2 = a2.bottom * s2 + o2[2], h2 = a2.left * s2 - o2[3], p2 = a2.right * s2 + o2[1], f2 = a2.collisionPadding;
              if (f2 && (h2 -= f2[0] * s2, l3 -= f2[1] * s2, p2 += f2[2] * s2, c2 += f2[3] * s2), u2) {
                let t3 = new S(h2, l3), e3 = new S(p2, l3), r3 = new S(h2, c2), n3 = new S(p2, c2), i3 = u2 * Math.PI / 180;
                t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), h2 = Math.min(t3.x, e3.x, r3.x, n3.x), p2 = Math.max(t3.x, e3.x, r3.x, n3.x), l3 = Math.min(t3.y, e3.y, r3.y, n3.y), c2 = Math.max(t3.y, e3.y, r3.y, n3.y);
              }
              t2.emplaceBack(e2.x, e2.y, h2, l3, p2, c2, r2, n2, i2);
            }
            this.boxEndIndex = t2.length;
          }
        }
        class gu {
          constructor(t2 = [], e2 = xu) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
              for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (this.length === 0)
              return;
            let t2 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            let { data: e2, compare: r2 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              let i2 = t2 - 1 >> 1, a2 = e2[i2];
              if (r2(n2, a2) >= 0)
                break;
              e2[t2] = a2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            let { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1), a2 = e2[n3], s2 = n3 + 1;
              if (s2 < this.length && r2(e2[s2], a2) < 0 && (n3 = s2, a2 = e2[s2]), r2(a2, i2) >= 0)
                break;
              e2[t2] = a2, t2 = n3;
            }
            e2[t2] = i2;
          }
        }
        function xu(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function vu(t2, e2 = 1, r2 = !1) {
          let n2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0, o2 = t2[0];
          for (let t3 = 0; t3 < o2.length; t3++) {
            let e3 = o2[t3];
            (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > a2) && (a2 = e3.x), (!t3 || e3.y > s2) && (s2 = e3.y);
          }
          let l2 = Math.min(a2 - n2, s2 - i2), u2 = l2 / 2, c2 = new gu([], bu);
          if (l2 === 0)
            return new S(n2, i2);
          for (let e3 = n2; e3 < a2; e3 += l2)
            for (let r3 = i2; r3 < s2; r3 += l2)
              c2.push(new wu(e3 + u2, r3 + u2, u2, t2));
          let h2 = function(t3) {
            let e3 = 0, r3 = 0, n3 = 0, i3 = t3[0];
            for (let t4 = 0, a3 = i3.length, s3 = a3 - 1; t4 < a3; s3 = t4++) {
              let a4 = i3[t4], o3 = i3[s3], l3 = a4.x * o3.y - o3.x * a4.y;
              r3 += (a4.x + o3.x) * l3, n3 += (a4.y + o3.y) * l3, e3 += 3 * l3;
            }
            return new wu(r3 / e3, n3 / e3, 0, t3);
          }(t2), p2 = c2.length;
          for (; c2.length; ) {
            let n3 = c2.pop();
            (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e2 || (u2 = n3.h / 2, c2.push(new wu(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new wu(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new wu(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new wu(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
          }
          return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
        }
        function bu(t2, e2) {
          return e2.max - t2.max;
        }
        function wu(t2, e2, r2, n2) {
          this.p = new S(t2, e2), this.h = r2, this.d = function(t3, e3) {
            let r3 = !1, n3 = 1 / 0;
            for (let i2 = 0; i2 < e3.length; i2++) {
              let a2 = e3[i2];
              for (let e4 = 0, i3 = a2.length, s2 = i3 - 1; e4 < i3; s2 = e4++) {
                let i4 = a2[e4], o2 = a2[s2];
                i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, rs(t3, i4, o2));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        let _u = Number.POSITIVE_INFINITY;
        function Au(t2, e2) {
          return e2[1] !== _u ? function(t3, e3, r2) {
            let n2 = 0, i2 = 0;
            switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = 7 - r2;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e3;
            }
            return [n2, i2];
          }(t2, e2[0], e2[1]) : function(t3, e3) {
            let r2 = 0, n2 = 0;
            e3 < 0 && (e3 = 0);
            let i2 = e3 / Math.sqrt(2);
            switch (t3) {
              case "top-right":
              case "top-left":
                n2 = i2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = 7 - i2;
                break;
              case "bottom":
                n2 = 7 - e3;
                break;
              case "top":
                n2 = e3 - 7;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                r2 = -i2;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i2;
                break;
              case "left":
                r2 = e3;
                break;
              case "right":
                r2 = -e3;
            }
            return [r2, n2];
          }(t2, e2[0]);
        }
        function ku(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Su(e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2) {
          let p2 = s2.textMaxSize.evaluate(r2, {});
          p2 === void 0 && (p2 = o2);
          let f2 = e2.layers[0].layout, y2 = f2.get("icon-offset").evaluate(r2, {}, h2), m2 = zu(n2.horizontal), g2 = o2 / 24, x2 = e2.tilePixelRatio * g2, v2 = e2.tilePixelRatio * p2 / 24, b2 = e2.tilePixelRatio * l2, w2 = e2.tilePixelRatio * f2.get("symbol-spacing"), _2 = f2.get("text-padding") * e2.tilePixelRatio, A2 = function(t2, e3, r3, n3 = 1) {
            let i3 = t2.get("icon-padding").evaluate(e3, {}, r3), a3 = i3 && i3.values;
            return [a3[0] * n3, a3[1] * n3, a3[2] * n3, a3[3] * n3];
          }(f2, r2, h2, e2.tilePixelRatio), k2 = f2.get("text-max-angle") / 180 * Math.PI, S2 = f2.get("text-rotation-alignment") !== "viewport" && f2.get("symbol-placement") !== "point", I2 = f2.get("icon-rotation-alignment") === "map" && f2.get("symbol-placement") !== "point", M2 = f2.get("symbol-placement"), z2 = w2 / 2, B2 = f2.get("icon-text-fit"), C2;
          i2 && B2 !== "none" && (e2.allowVerticalPlacement && n2.vertical && (C2 = Ql(i2, n2.vertical, B2, f2.get("icon-text-fit-padding"), y2, g2)), m2 && (i2 = Ql(i2, m2, B2, f2.get("icon-text-fit-padding"), y2, g2)));
          let P2 = (l3, p3) => {
            p3.x < 0 || p3.x >= qa || p3.y < 0 || p3.y >= qa || function(e3, r3, n3, i3, a3, s3, o3, l4, u3, c3, h3, p4, f3, y3, m3, g3, x3, v3, b3, w3, _3, A3, k3, S3, I3) {
              let M3 = e3.addToLineVertexArray(r3, n3), z3, B3, C3, P3, V2 = 0, E2 = 0, F2 = 0, T2 = 0, L2 = -1, D2 = -1, $2 = {}, R2 = xa.exports(""), O2 = 0, U2 = 0;
              if (l4._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [O2, U2] = l4.layout.get("text-offset").evaluate(_3, {}, S3).map((t2) => t2 * ll) : (O2 = l4.layout.get("text-radial-offset").evaluate(_3, {}, S3) * ll, U2 = _u), e3.allowVerticalPlacement && i3.vertical) {
                let t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3) + 90;
                C3 = new mu(u3, r3, c3, h3, p4, i3.vertical, f3, y3, m3, t2), o3 && (P3 = new mu(u3, r3, c3, h3, p4, o3, x3, v3, m3, t2));
              }
              if (a3) {
                let n4 = l4.layout.get("icon-rotate").evaluate(_3, {}), i4 = l4.layout.get("icon-text-fit") !== "none", s4 = hu(a3, n4, k3, i4), f4 = o3 ? hu(o3, n4, k3, i4) : void 0;
                B3 = new mu(u3, r3, c3, h3, p4, a3, x3, v3, !1, n4), V2 = 4 * s4.length;
                let y4 = e3.iconSizeData, m4 = null;
                y4.kind === "source" ? (m4 = [tu * l4.layout.get("icon-size").evaluate(_3, {})], m4[0] > Iu && d(`${e3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : y4.kind === "composite" && (m4 = [tu * A3.compositeIconSizes[0].evaluate(_3, {}, S3), tu * A3.compositeIconSizes[1].evaluate(_3, {}, S3)], (m4[0] > Iu || m4[1] > Iu) && d(`${e3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, s4, m4, w3, b3, _3, t.WritingMode.none, r3, M3.lineStartIndex, M3.lineLength, -1, S3), L2 = e3.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e3.addSymbols(e3.icon, f4, m4, w3, b3, _3, t.WritingMode.vertical, r3, M3.lineStartIndex, M3.lineLength, -1, S3), D2 = e3.icon.placedSymbolArray.length - 1);
              }
              let q2 = Object.keys(i3.horizontal);
              for (let n4 of q2) {
                let a4 = i3.horizontal[n4];
                if (!z3) {
                  R2 = xa.exports(a4.text);
                  let t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3);
                  z3 = new mu(u3, r3, c3, h3, p4, a4, f3, y3, m3, t2);
                }
                let o4 = a4.positionedLines.length === 1;
                if (F2 += Mu(e3, r3, a4, s3, l4, m3, _3, g3, M3, i3.vertical ? t.WritingMode.horizontal : t.WritingMode.horizontalOnly, o4 ? q2 : [n4], $2, L2, A3, S3), o4)
                  break;
              }
              i3.vertical && (T2 += Mu(e3, r3, i3.vertical, s3, l4, m3, _3, g3, M3, t.WritingMode.vertical, ["vertical"], $2, D2, A3, S3));
              let j2 = z3 ? z3.boxStartIndex : e3.collisionBoxArray.length, N2 = z3 ? z3.boxEndIndex : e3.collisionBoxArray.length, Z2 = C3 ? C3.boxStartIndex : e3.collisionBoxArray.length, K2 = C3 ? C3.boxEndIndex : e3.collisionBoxArray.length, G2 = B3 ? B3.boxStartIndex : e3.collisionBoxArray.length, J2 = B3 ? B3.boxEndIndex : e3.collisionBoxArray.length, X2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, Y2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length, H2 = -1, W2 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
              H2 = W2(z3, H2), H2 = W2(C3, H2), H2 = W2(B3, H2), H2 = W2(P3, H2);
              let Q2 = H2 > -1 ? 1 : 0;
              Q2 && (H2 *= I3 / ll), e3.glyphOffsetArray.length >= Du.MAX_GLYPHS && d("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), _3.sortKey !== void 0 && e3.addToSortKeyRanges(e3.symbolInstances.length, _3.sortKey), e3.symbolInstances.emplaceBack(r3.x, r3.y, $2.right >= 0 ? $2.right : -1, $2.center >= 0 ? $2.center : -1, $2.left >= 0 ? $2.left : -1, $2.vertical || -1, L2, D2, R2, j2, N2, Z2, K2, G2, J2, X2, Y2, c3, F2, T2, V2, E2, Q2, 0, f3, O2, U2, H2);
            }(e2, p3, l3, n2, i2, a2, C2, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, x2, [_2, _2, _2, _2], S2, u2, b2, A2, I2, y2, r2, s2, c2, h2, o2);
          };
          if (M2 === "line")
            for (let t2 of cu(r2.geometry, 0, 0, qa, qa)) {
              let r3 = lu(t2, w2, k2, n2.vertical || m2, i2, 24, v2, e2.overscaling, qa);
              for (let n3 of r3) {
                let r4 = m2;
                r4 && Bu(e2, r4.text, z2, n3) || P2(t2, n3);
              }
            }
          else if (M2 === "line-center") {
            for (let t2 of r2.geometry)
              if (t2.length > 1) {
                let e3 = ou(t2, k2, n2.vertical || m2, i2, 24, v2);
                e3 && P2(t2, e3);
              }
          } else if (r2.type === "Polygon")
            for (let t2 of ho(r2.geometry, 0)) {
              let e3 = vu(t2, 16);
              P2(t2[0], new ru(e3.x, e3.y, 0));
            }
          else if (r2.type === "LineString")
            for (let t2 of r2.geometry)
              P2(t2, new ru(t2[0].x, t2[0].y, 0));
          else if (r2.type === "Point")
            for (let t2 of r2.geometry)
              for (let e3 of t2)
                P2([e3], new ru(e3.x, e3.y, 0));
        }
        let Iu = 32640;
        function Mu(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, y2) {
          let m2 = function(t3, e3, r3, n3, i3, a3, s3, o3) {
            let l3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, u3 = [];
            for (let t4 of e3.positionedLines)
              for (let n4 of t4.positionedGlyphs) {
                if (!n4.rect)
                  continue;
                let a4 = n4.rect || {}, c3 = 4, h3 = !0, p3 = 1, f3 = 0, d2 = (i3 || o3) && n4.vertical, y3 = n4.metrics.advance * n4.scale / 2;
                if (o3 && e3.verticalizable) {
                  let e4 = (n4.scale - 1) * ll, r4 = (ll - n4.metrics.width * n4.scale) / 2;
                  f3 = t4.lineOffset / 2 - (n4.imageName ? -r4 : e4);
                }
                if (n4.imageName) {
                  let t5 = s3[n4.imageName];
                  h3 = t5.sdf, p3 = t5.pixelRatio, c3 = 1 / p3;
                }
                let m3 = i3 ? [n4.x + y3, n4.y] : [0, 0], g3 = i3 ? [0, 0] : [n4.x + y3 + r3[0], n4.y + r3[1] - f3], x3 = [0, 0];
                d2 && (x3 = g3, g3 = [0, 0]);
                let v2 = (n4.metrics.left - c3) * n4.scale - y3 + g3[0], b2 = (-n4.metrics.top - c3) * n4.scale + g3[1], w2 = v2 + a4.w * n4.scale / p3, _2 = b2 + a4.h * n4.scale / p3, A2 = new S(v2, b2), k2 = new S(w2, b2), I2 = new S(v2, _2), M2 = new S(w2, _2);
                if (d2) {
                  let t5 = new S(-y3, y3 - $l), e4 = -Math.PI / 2, r4 = 12 - y3, i4 = new S(22 - r4, -(n4.imageName ? r4 : 0)), a5 = new S(...x3);
                  A2._rotateAround(e4, t5)._add(i4)._add(a5), k2._rotateAround(e4, t5)._add(i4)._add(a5), I2._rotateAround(e4, t5)._add(i4)._add(a5), M2._rotateAround(e4, t5)._add(i4)._add(a5);
                }
                if (l3) {
                  let t5 = Math.sin(l3), e4 = Math.cos(l3), r4 = [e4, -t5, t5, e4];
                  A2._matMult(r4), k2._matMult(r4), I2._matMult(r4), M2._matMult(r4);
                }
                let z2 = new S(0, 0), B2 = new S(0, 0);
                u3.push({ tl: A2, tr: k2, bl: I2, br: M2, tex: a4, writingMode: e3.writingMode, glyphOffset: m3, sectionIndex: n4.sectionIndex, isSDF: h3, pixelOffsetTL: z2, pixelOffsetBR: B2, minFontScaleX: 0, minFontScaleY: 0 });
              }
            return u3;
          }(0, r2, o2, i2, a2, s2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData, x2 = null;
          g2.kind === "source" ? (x2 = [tu * i2.layout.get("text-size").evaluate(s2, {})], x2[0] > Iu && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : g2.kind === "composite" && (x2 = [tu * f2.compositeTextSizes[0].evaluate(s2, {}, y2), tu * f2.compositeTextSizes[1].evaluate(s2, {}, y2)], (x2[0] > Iu || x2[1] > Iu) && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, o2, a2, s2, u2, e2, l2.lineStartIndex, l2.lineLength, p2, y2);
          for (let e3 of c2)
            h2[e3] = t2.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function zu(t2) {
          for (let e2 in t2)
            return t2[e2];
          return null;
        }
        function Bu(t2, e2, r2, n2) {
          let i2 = t2.compareText;
          if (e2 in i2) {
            let t3 = i2[e2];
            for (let e3 = t3.length - 1; e3 >= 0; e3--)
              if (n2.dist(t3[e3]) < r2)
                return !0;
          } else
            i2[e2] = [];
          return i2[e2].push(n2), !1;
        }
        let Cu = _o.VectorTileFeature.types, Pu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Vu(t2, e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2) {
          let f2 = o2 ? Math.min(Iu, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Iu, Math.round(o2[1])) : 0;
          t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), a2, s2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function Eu(t2, e2, r2) {
          t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
        }
        function Fu(t2) {
          for (let e2 of t2.sections)
            if (On(e2.text))
              return !0;
          return !1;
        }
        class Tu {
          constructor(t2) {
            this.layoutVertexArray = new sa(), this.indexArray = new ha(), this.programConfigurations = t2, this.segments = new ya(), this.dynamicLayoutVertexArray = new oa(), this.opacityVertexArray = new la(), this.placedSymbolArray = new Ki();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t2, e2, r2, n2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, el.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, rl.members, !0), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Pu, !0), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Mn("SymbolBuffers", Tu);
        class Lu {
          constructor(t2, e2, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new ya(), this.collisionVertexArray = new ca();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, nl.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Mn("CollisionBuffers", Lu);
        class Du {
          constructor(e2) {
            this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ds([]), this.placementViewportMatrix = ds([]);
            let r2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = eu(this.zoom, r2["text-size"]), this.iconSizeData = eu(this.zoom, r2["icon-size"]);
            let n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), a2 = n2.get("symbol-z-order");
            this.canOverlap = qu(n2, "text-overlap", "text-allow-overlap") !== "never" || qu(n2, "icon-overlap", "icon-allow-overlap") !== "never" || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = a2 !== "viewport-y" && !i2.isConstant(), this.sortFeaturesByY = (a2 === "viewport-y" || a2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n2.get("symbol-placement") === "point" && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.WritingMode[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
          }
          createArrays() {
            this.text = new Tu(new Ra(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new Tu(new Ra(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Xi(), this.lineVertexArray = new Yi(), this.symbolInstances = new Ji();
          }
          calculateGlyphDependencies(t2, e2, r2, n2, i2) {
            for (let a2 = 0; a2 < t2.length; a2++)
              if (e2[t2.charCodeAt(a2)] = !0, (r2 || n2) && i2) {
                let r3 = ol[t2.charAt(a2)];
                r3 && (e2[r3.charCodeAt(0)] = !0);
              }
          }
          populate(e2, r2, n2) {
            let i2 = this.layers[0], a2 = i2.layout, s2 = a2.get("text-font"), o2 = a2.get("text-field"), l2 = a2.get("icon-image"), u2 = (o2.value.kind !== "constant" || o2.value.value instanceof Dt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && (s2.value.kind !== "constant" || s2.value.value.length > 0), c2 = l2.value.kind !== "constant" || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = a2.get("symbol-sort-key");
            if (this.features = [], !u2 && !c2)
              return;
            let p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y2 = new Qn(this.zoom);
            for (let { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
              let e3 = i2._featureFilter.needGeometry, g2 = Ka(r3, e3);
              if (!i2._featureFilter.filter(y2, g2, n2))
                continue;
              let x2, v2;
              if (e3 || (g2.geometry = Za(r3)), u2) {
                let t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Dt.factory(t2);
                Fu(e4) && (this.hasRTLText = !0), (!this.hasRTLText || Yn() === "unavailable" || this.hasRTLText && Wn.isParsed()) && (x2 = sl(e4, i2, g2));
              }
              if (c2) {
                let t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
                v2 = t2 instanceof Rt ? t2 : Rt.fromString(t2);
              }
              if (!x2 && !v2)
                continue;
              let b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
              if (this.features.push({ id: o3, text: x2, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: Cu[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = !0), x2) {
                let e4 = s2.evaluate(g2, {}, n2).join(","), r4 = a2.get("text-rotation-alignment") !== "viewport" && a2.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.WritingMode.vertical) >= 0;
                for (let t2 of x2.sections)
                  if (t2.image)
                    p2[t2.image.name] = !0;
                  else {
                    let n3 = En(x2.toString()), i3 = t2.fontStack || e4, a3 = f2[i3] = f2[i3] || {};
                    this.calculateGlyphDependencies(t2.text, a3, r4, this.allowVerticalPlacement, n3);
                  }
              }
            }
            a2.get("symbol-placement") === "line" && (this.features = function(t2) {
              let e3 = {}, r3 = {}, n3 = [], i3 = 0;
              function a3(e4) {
                n3.push(t2[e4]), i3++;
              }
              function s3(t3, e4, i4) {
                let a4 = r3[t3];
                return delete r3[t3], r3[e4] = a4, n3[a4].geometry[0].pop(), n3[a4].geometry[0] = n3[a4].geometry[0].concat(i4[0]), a4;
              }
              function o3(t3, r4, i4) {
                let a4 = e3[r4];
                return delete e3[r4], e3[t3] = a4, n3[a4].geometry[0].shift(), n3[a4].geometry[0] = i4[0].concat(n3[a4].geometry[0]), a4;
              }
              function l3(t3, e4, r4) {
                let n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t3}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t2.length; u3++) {
                let c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  a3(u3);
                  continue;
                }
                let f3 = l3(p3, h3), d3 = l3(p3, h3, !0);
                if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                  let t3 = o3(f3, d3, h3), i4 = s3(f3, d3, n3[t3].geometry);
                  delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, !0)] = i4, n3[t3].geometry = null;
                } else
                  f3 in r3 ? s3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (a3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
              }
              return n3.filter((t3) => t3.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e2) {
            let r2 = this.lineVertexArray.length;
            if (t2.segment !== void 0) {
              let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]), i2 = {};
              for (let n3 = t2.segment + 1; n3 < e2.length; n3++)
                i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
              for (let r4 = t2.segment || 0; r4 >= 0; r4--)
                i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
              for (let t3 = 0; t3 < e2.length; t3++) {
                let e3 = i2[t3];
                this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(e2, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2) {
            let f2 = e2.indexArray, d2 = e2.layoutVertexArray, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? s2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.WritingMode.vertical ? Math.PI / 2 : 0, v2 = s2.text && s2.text.sections;
            for (let t2 = 0; t2 < r2.length; t2++) {
              let { tl: i3, tr: a3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t2], k2 = y2.vertexLength, S2 = w2[1];
              Vu(d2, l2.x, l2.y, i3.x, S2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), Vu(d2, l2.x, l2.y, a3.x, S2 + a3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), Vu(d2, l2.x, l2.y, o3.x, S2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), Vu(d2, l2.x, l2.y, u3.x, S2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), Eu(e2.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(k2, k2 + 1, k2 + 2), f2.emplaceBack(k2 + 1, k2 + 2, k2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, s2, s2.index, {}, p2, v2 && v2[A2]);
            }
            e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, !1, 0, h2);
          }
          _addCollisionDebugVertex(t2, e2, r2, n2, i2, a2) {
            return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(a2.x), Math.round(a2.y));
          }
          addCollisionDebugVertices(t2, e2, r2, n2, i2, a2, s2) {
            let o2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), l2 = o2.vertexLength, u2 = i2.layoutVertexArray, c2 = i2.collisionVertexArray, h2 = s2.anchorX, p2 = s2.anchorY;
            this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(t2, e2)), this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(r2, e2)), this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(r2, n2)), this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(t2, n2)), o2.vertexLength += 4;
            let f2 = i2.indexArray;
            f2.emplaceBack(l2, l2 + 1), f2.emplaceBack(l2 + 1, l2 + 2), f2.emplaceBack(l2 + 2, l2 + 3), f2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t2, e2, r2, n2) {
            for (let i2 = t2; i2 < e2; i2++) {
              let t3 = this.collisionBoxArray.get(i2);
              this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Lu(ua, il.members, pa), this.iconCollisionBox = new Lu(ua, il.members, pa);
            for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
              let e2 = this.symbolInstances.get(t2);
              this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, !0), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, !0), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, !1), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, a2, s2, o2, l2) {
            let u2 = {};
            for (let n3 = e2; n3 < r2; n3++) {
              let e3 = t2.get(n3);
              u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
              break;
            }
            for (let e3 = n2; e3 < i2; e3++) {
              let r3 = t2.get(e3);
              u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = a2; e3 < s2; e3++) {
              let r3 = t2.get(e3);
              u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = o2; e3 < l2; e3++) {
              let r3 = t2.get(e3);
              u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
              break;
            }
            return u2;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              let r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t2, e2) {
            let r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
              t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && this.symbolInstanceIndexes !== void 0)
              return this.symbolInstanceIndexes;
            let e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], a2 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              a2.push(t3);
              let s2 = this.symbolInstances.get(t3);
              n2.push(0 | Math.round(e2 * s2.anchorX + r2 * s2.anchorY)), i2.push(s2.featureIndex);
            }
            return a2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), a2;
          }
          addToSortKeyRanges(t2, e2) {
            let r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (let t3 of this.symbolInstanceIndexes) {
                let e2 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                  t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
                }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        Mn("SymbolBucket", Du, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Du.MAX_GLYPHS = 65535, Du.addDynamicAttributes = Eu;
        let $u = new fi({ "symbol-placement": new li(nt.layout_symbol["symbol-placement"]), "symbol-spacing": new li(nt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new li(nt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ui(nt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new li(nt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new li(nt.layout_symbol["icon-allow-overlap"]), "icon-overlap": new li(nt.layout_symbol["icon-overlap"]), "icon-ignore-placement": new li(nt.layout_symbol["icon-ignore-placement"]), "icon-optional": new li(nt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new li(nt.layout_symbol["icon-rotation-alignment"]), "icon-size": new ui(nt.layout_symbol["icon-size"]), "icon-text-fit": new li(nt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new li(nt.layout_symbol["icon-text-fit-padding"]), "icon-image": new ui(nt.layout_symbol["icon-image"]), "icon-rotate": new ui(nt.layout_symbol["icon-rotate"]), "icon-padding": new ui(nt.layout_symbol["icon-padding"]), "icon-keep-upright": new li(nt.layout_symbol["icon-keep-upright"]), "icon-offset": new ui(nt.layout_symbol["icon-offset"]), "icon-anchor": new ui(nt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new li(nt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new li(nt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new li(nt.layout_symbol["text-rotation-alignment"]), "text-field": new ui(nt.layout_symbol["text-field"]), "text-font": new ui(nt.layout_symbol["text-font"]), "text-size": new ui(nt.layout_symbol["text-size"]), "text-max-width": new ui(nt.layout_symbol["text-max-width"]), "text-line-height": new li(nt.layout_symbol["text-line-height"]), "text-letter-spacing": new ui(nt.layout_symbol["text-letter-spacing"]), "text-justify": new ui(nt.layout_symbol["text-justify"]), "text-radial-offset": new ui(nt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new li(nt.layout_symbol["text-variable-anchor"]), "text-anchor": new ui(nt.layout_symbol["text-anchor"]), "text-max-angle": new li(nt.layout_symbol["text-max-angle"]), "text-writing-mode": new li(nt.layout_symbol["text-writing-mode"]), "text-rotate": new ui(nt.layout_symbol["text-rotate"]), "text-padding": new li(nt.layout_symbol["text-padding"]), "text-keep-upright": new li(nt.layout_symbol["text-keep-upright"]), "text-transform": new ui(nt.layout_symbol["text-transform"]), "text-offset": new ui(nt.layout_symbol["text-offset"]), "text-allow-overlap": new li(nt.layout_symbol["text-allow-overlap"]), "text-overlap": new li(nt.layout_symbol["text-overlap"]), "text-ignore-placement": new li(nt.layout_symbol["text-ignore-placement"]), "text-optional": new li(nt.layout_symbol["text-optional"]) });
        var Ru = { paint: new fi({ "icon-opacity": new ui(nt.paint_symbol["icon-opacity"]), "icon-color": new ui(nt.paint_symbol["icon-color"]), "icon-halo-color": new ui(nt.paint_symbol["icon-halo-color"]), "icon-halo-width": new ui(nt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ui(nt.paint_symbol["icon-halo-blur"]), "icon-translate": new li(nt.paint_symbol["icon-translate"]), "icon-translate-anchor": new li(nt.paint_symbol["icon-translate-anchor"]), "text-opacity": new ui(nt.paint_symbol["text-opacity"]), "text-color": new ui(nt.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new ui(nt.paint_symbol["text-halo-color"]), "text-halo-width": new ui(nt.paint_symbol["text-halo-width"]), "text-halo-blur": new ui(nt.paint_symbol["text-halo-blur"]), "text-translate": new li(nt.paint_symbol["text-translate"]), "text-translate-anchor": new li(nt.paint_symbol["text-translate-anchor"]) }), layout: $u };
        class Ou {
          constructor(t2) {
            if (t2.property.overrides === void 0)
              throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ht, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              let e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection))
                return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        Mn("FormatSectionOverride", Ou, { omit: ["defaultValue"] });
        class Uu extends yi {
          constructor(t2) {
            super(t2, Ru);
          }
          recalculate(t2, e2) {
            if (super.recalculate(t2, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              let t3 = this.layout.get("text-writing-mode");
              if (t3) {
                let e3 = [];
                for (let r2 of t3)
                  e3.indexOf(r2) < 0 && e3.push(r2);
                this.layout._values["text-writing-mode"] = e3;
              } else
                this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t2, e2, r2, n2) {
            let i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), a2 = this._unevaluatedLayout._values[t2];
            return a2.isDataDriven() || Er(a2.value) || !i2 ? i2 : function(t3, e3) {
              return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
            }(e2.properties, i2);
          }
          createBucket(t2) {
            return new Du(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (let t2 of Ru.paint.overridableProperties) {
              if (!Uu.hasPaintOverride(this.layout, t2))
                continue;
              let e2 = this.paint.get(t2), r2 = new Ou(e2), n2 = new Vr(r2, e2.property.specification), i2 = null;
              i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new Tr("source", n2) : new Lr("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new si(e2.property, i2, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && Uu.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e2) {
            let r2 = t2.get("text-field"), n2 = Ru.paint.properties[e2], i2 = !1, a2 = (t3) => {
              for (let e3 of t3)
                if (n2.overrides && n2.overrides.hasOverride(e3))
                  return void (i2 = !0);
            };
            if (r2.value.kind === "constant" && r2.value.value instanceof Dt)
              a2(r2.value.value.sections);
            else if (r2.value.kind === "source") {
              let t3 = (e4) => {
                i2 || (e4 instanceof Nt && qt(e4.value) === vt ? a2(e4.value.sections) : e4 instanceof cr ? a2(e4.sections) : e4.eachChild(t3));
              }, e3 = r2.value;
              e3._styleExpression && t3(e3._styleExpression.expression);
            }
            return i2;
          }
        }
        function qu(t2, e2, r2) {
          let n2 = "never", i2 = t2.get(e2);
          return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
        }
        var ju = { paint: new fi({ "background-color": new li(nt.paint_background["background-color"]), "background-pattern": new hi(nt.paint_background["background-pattern"]), "background-opacity": new li(nt.paint_background["background-opacity"]) }) }, Nu = { paint: new fi({ "raster-opacity": new li(nt.paint_raster["raster-opacity"]), "raster-hue-rotate": new li(nt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new li(nt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new li(nt.paint_raster["raster-brightness-max"]), "raster-saturation": new li(nt.paint_raster["raster-saturation"]), "raster-contrast": new li(nt.paint_raster["raster-contrast"]), "raster-resampling": new li(nt.paint_raster["raster-resampling"]), "raster-fade-duration": new li(nt.paint_raster["raster-fade-duration"]) }) };
        class Zu extends yi {
          constructor(t2) {
            super(t2, {}), this.onAdd = (t3) => {
              this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
            }, this.onRemove = (t3) => {
              this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
            }, this.implementation = t2;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        let Ku = { circle: class extends yi {
          constructor(t2) {
            super(t2, cs);
          }
          createBucket(t2) {
            return new Ja(t2);
          }
          queryRadius(t2) {
            let e2 = t2;
            return ss("circle-radius", this, e2) + ss("circle-stroke-width", this, e2) + os(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, s2, o2) {
            let l2 = ls(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a2.angle, s2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = this.paint.get("circle-pitch-alignment") === "map", h2 = c2 ? l2 : function(t3, e3) {
              return t3.map((t4) => _s(t4, e3));
            }(l2, o2), p2 = c2 ? u2 * s2 : u2;
            for (let t3 of n2)
              for (let e3 of t3) {
                let t4 = c2 ? e3 : _s(e3, o2), r3 = p2, n3 = bs([], [e3.x, e3.y, 0, 1], o2);
                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? r3 *= n3[3] / a2.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (r3 *= a2.cameraToCenterDistance / n3[3]), Ya(h2, t4, r3))
                  return !0;
              }
            return !1;
          }
        }, heatmap: class extends yi {
          constructor(t2) {
            super(t2, ks), this._updateColorRamp();
          }
          createBucket(t2) {
            return new As(t2);
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            t2 === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Cs({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }, hillshade: class extends yi {
          constructor(t2) {
            super(t2, Ps);
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }, fill: class extends yi {
          constructor(t2) {
            super(t2, xo);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
            let r2 = this.paint._values["fill-outline-color"];
            r2.value.kind === "constant" && r2.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new mo(t2);
          }
          queryRadius() {
            return os(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, s2) {
            return Ha(ls(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a2.angle, s2), n2);
          }
          isTileClipped() {
            return !0;
          }
        }, "fill-extrusion": class extends yi {
          constructor(t2) {
            super(t2, Oo);
          }
          createBucket(t2) {
            return new Do(t2);
          }
          queryRadius() {
            return os(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, s2, o2) {
            let l2 = ls(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, s2), u2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), h2 = function(t3, e3, r3, n3) {
              let i3 = [];
              for (let r4 of t3) {
                let t4 = [r4.x, r4.y, 0, 1];
                bs(t4, t4, e3), i3.push(new S(t4[0] / t4[3], t4[1] / t4[3]));
              }
              return i3;
            }(l2, o2), p2 = function(t3, e3, r3, n3) {
              let i3 = [], a3 = [], s3 = n3[8] * e3, o3 = n3[9] * e3, l3 = n3[10] * e3, u3 = n3[11] * e3, c3 = n3[8] * r3, h3 = n3[9] * r3, p3 = n3[10] * r3, f2 = n3[11] * r3;
              for (let e4 of t3) {
                let t4 = [], r4 = [];
                for (let i4 of e4) {
                  let e5 = i4.x, a4 = i4.y, d2 = n3[0] * e5 + n3[4] * a4 + n3[12], y2 = n3[1] * e5 + n3[5] * a4 + n3[13], m2 = n3[2] * e5 + n3[6] * a4 + n3[14], g2 = n3[3] * e5 + n3[7] * a4 + n3[15], x2 = m2 + l3, v2 = g2 + u3, b2 = d2 + c3, w2 = y2 + h3, _2 = m2 + p3, A2 = g2 + f2, k2 = new S((d2 + s3) / v2, (y2 + o3) / v2);
                  k2.z = x2 / v2, t4.push(k2);
                  let I2 = new S(b2 / A2, w2 / A2);
                  I2.z = _2 / A2, r4.push(I2);
                }
                i3.push(t4), a3.push(r4);
              }
              return [i3, a3];
            }(n2, c2, u2, o2);
            return function(t3, e3, r3) {
              let n3 = 1 / 0;
              Ha(r3, e3) && (n3 = qo(r3, e3[0]));
              for (let i3 = 0; i3 < e3.length; i3++) {
                let a3 = e3[i3], s3 = t3[i3];
                for (let t4 = 0; t4 < a3.length - 1; t4++) {
                  let e4 = a3[t4], i4 = [e4, a3[t4 + 1], s3[t4 + 1], s3[t4], e4];
                  Xa(r3, i4) && (n3 = Math.min(n3, qo(r3, i4)));
                }
              }
              return n3 !== 1 / 0 && n3;
            }(p2[0], p2[1], h2);
          }
        }, line: class extends yi {
          constructor(t2) {
            super(t2, Wo), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            t2 === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof ke, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Qo.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new Yo(t2);
          }
          queryRadius(t2) {
            let e2 = t2, r2 = tl(ss("line-width", this, e2), ss("line-gap-width", this, e2)), n2 = ss("line-offset", this, e2);
            return r2 / 2 + Math.abs(n2) + os(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, s2) {
            let o2 = ls(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, s2), l2 = s2 / 2 * tl(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), u2 = this.paint.get("line-offset").evaluate(e2, r2);
            return u2 && (n2 = function(t3, e3) {
              let r3 = [];
              for (let n3 = 0; n3 < t3.length; n3++) {
                let i3 = t3[n3], a3 = [];
                for (let t4 = 0; t4 < i3.length; t4++) {
                  let r4 = i3[t4 - 1], n4 = i3[t4], s3 = i3[t4 + 1], o3 = t4 === 0 ? new S(0, 0) : n4.sub(r4)._unit()._perp(), l3 = t4 === i3.length - 1 ? new S(0, 0) : s3.sub(n4)._unit()._perp(), u3 = o3._add(l3)._unit(), c2 = u3.x * l3.x + u3.y * l3.y;
                  c2 !== 0 && u3._mult(1 / c2), a3.push(u3._mult(e3)._add(n4));
                }
                r3.push(a3);
              }
              return r3;
            }(n2, u2 * s2)), function(t3, e3, r3) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                let i3 = e3[n3];
                if (t3.length >= 3) {
                  for (let e4 = 0; e4 < i3.length; e4++)
                    if (is(t3, i3[e4]))
                      return !0;
                }
                if (Wa(t3, i3, r3))
                  return !0;
              }
              return !1;
            }(o2, n2, l2);
          }
          isTileClipped() {
            return !0;
          }
        }, symbol: Uu, background: class extends yi {
          constructor(t2) {
            super(t2, ju);
          }
        }, raster: class extends yi {
          constructor(t2) {
            super(t2, Nu);
          }
        } };
        class Gu {
          constructor(t2) {
            this._callback = t2, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._callback();
            }, 0));
          }
          remove() {
            delete this._channel, this._callback = () => {
            };
          }
        }
        let Ju = 63710088e-1;
        class Xu {
          constructor(t2, e2) {
            if (isNaN(t2) || isNaN(e2))
              throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Xu(s(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t2) {
            let e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
            return Ju * Math.acos(Math.min(i2, 1));
          }
          toBounds(t2 = 0) {
            let e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
            return new Yu(new Xu(this.lng - r2, this.lat - e2), new Xu(this.lng + r2, this.lat + e2));
          }
          static convert(t2) {
            if (t2 instanceof Xu)
              return t2;
            if (Array.isArray(t2) && (t2.length === 2 || t2.length === 3))
              return new Xu(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && typeof t2 == "object" && t2 !== null)
              return new Xu(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        class Yu {
          constructor(t2, e2) {
            t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : t2.length === 4 ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
          }
          setNorthEast(t2) {
            return this._ne = t2 instanceof Xu ? new Xu(t2.lng, t2.lat) : Xu.convert(t2), this;
          }
          setSouthWest(t2) {
            return this._sw = t2 instanceof Xu ? new Xu(t2.lng, t2.lat) : Xu.convert(t2), this;
          }
          extend(t2) {
            let e2 = this._sw, r2 = this._ne, n2, i2;
            if (t2 instanceof Xu)
              n2 = t2, i2 = t2;
            else {
              if (!(t2 instanceof Yu))
                return Array.isArray(t2) ? t2.length === 4 || t2.every(Array.isArray) ? this.extend(Yu.convert(t2)) : this.extend(Xu.convert(t2)) : this;
              if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
                return this;
            }
            return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Xu(n2.lng, n2.lat), this._ne = new Xu(i2.lng, i2.lat)), this;
          }
          getCenter() {
            return new Xu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new Xu(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new Xu(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t2) {
            let { lng: e2, lat: r2 } = Xu.convert(t2), n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
          }
          static convert(t2) {
            return t2 instanceof Yu ? t2 : t2 && new Yu(t2);
          }
        }
        let Hu = 2 * Math.PI * Ju;
        function Wu(t2) {
          return Hu * Math.cos(t2 * Math.PI / 180);
        }
        function Qu(t2) {
          return (180 + t2) / 360;
        }
        function tc(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function ec(t2, e2) {
          return t2 / Wu(e2);
        }
        function rc(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        class nc {
          constructor(t2, e2, r2 = 0) {
            this.x = +t2, this.y = +e2, this.z = +r2;
          }
          static fromLngLat(t2, e2 = 0) {
            let r2 = Xu.convert(t2);
            return new nc(Qu(r2.lng), tc(r2.lat), ec(e2, r2.lat));
          }
          toLngLat() {
            return new Xu(360 * this.x - 180, rc(this.y));
          }
          toAltitude() {
            return this.z * Wu(rc(this.y));
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Hu * (t2 = rc(this.y), 1 / Math.cos(t2 * Math.PI / 180));
            var t2;
          }
        }
        function ic(t2, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class ac {
          constructor(t2, e2, r2) {
            if (t2 < 0 || t2 > 25 || r2 < 0 || r2 >= Math.pow(2, t2) || e2 < 0 || e2 >= Math.pow(2, t2))
              throw new Error(`x=${e2}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
            this.z = t2, this.x = e2, this.y = r2, this.key = lc(0, t2, t2, e2, r2);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          url(t2, e2, r2) {
            let n2 = (a2 = this.y, s2 = this.z, o2 = ic(256 * (i2 = this.x), 256 * (a2 = Math.pow(2, s2) - a2 - 1), s2), l2 = ic(256 * (i2 + 1), 256 * (a2 + 1), s2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
            var i2, a2, s2, o2, l2;
            let u2 = function(t3, e3, r3) {
              let n3, i3 = "";
              for (let a3 = t3; a3 > 0; a3--)
                n3 = 1 << a3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(r2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
          }
          isChildOf(t2) {
            let e2 = this.z - t2.z;
            return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
          }
          getTilePoint(t2) {
            let e2 = Math.pow(2, this.z);
            return new S((t2.x * e2 - this.x) * qa, (t2.y * e2 - this.y) * qa);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class sc {
          constructor(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = lc(t2, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class oc {
          constructor(t2, e2, r2, n2, i2) {
            if (t2 < r2)
              throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new ac(r2, +n2, +i2), this.key = lc(e2, t2, r2, n2, i2);
          }
          clone() {
            return new oc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            if (t2 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
            let e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new oc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new oc(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t2, e2) {
            if (t2 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
            let r2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? lc(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : lc(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap)
              return !1;
            let e2 = this.canonical.z - t2.canonical.z;
            return t2.overscaledZ === 0 || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }
          children(t2) {
            if (this.overscaledZ >= t2)
              return [new oc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            let e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new oc(e2, this.wrap, e2, r2, n2), new oc(e2, this.wrap, e2, r2 + 1, n2), new oc(e2, this.wrap, e2, r2, n2 + 1), new oc(e2, this.wrap, e2, r2 + 1, n2 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new oc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new oc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new sc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t2) {
            return this.canonical.getTilePoint(new nc(t2.x - this.wrap, t2.y));
          }
        }
        function lc(t2, e2, r2, n2, i2) {
          (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
          let a2 = 1 << r2;
          return (a2 * a2 * t2 + a2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
        }
        Mn("CanonicalTileID", ac), Mn("OverscaledTileID", oc, { omit: ["posMatrix"] });
        class uc {
          constructor(t2, e2, r2) {
            if (this.uid = t2, e2.height !== e2.width)
              throw new RangeError("DEM tiles must be square");
            if (r2 && r2 !== "mapbox" && r2 !== "terrarium")
              return void d(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e2.height;
            let n2 = this.dim = e2.height - 2;
            this.data = new Uint32Array(e2.data.buffer), this.encoding = r2 || "mapbox";
            for (let t3 = 0; t3 < n2; t3++)
              this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(n2, t3)] = this.data[this._idx(n2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, n2)] = this.data[this._idx(t3, n2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t3 = 0; t3 < n2; t3++)
              for (let e3 = 0; e3 < n2; e3++) {
                let r3 = this.get(t3, e3);
                r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
              }
          }
          get(t2, e2) {
            let r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
            return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
          }
          getUnpackVector() {
            return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
          }
          _idx(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t2 + 1);
          }
          _unpackMapbox(t2, e2, r2) {
            return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
          }
          _unpackTerrarium(t2, e2, r2) {
            return 256 * t2 + e2 + r2 / 256 - 32768;
          }
          getPixels() {
            return new Bs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t2, e2, r2) {
            if (this.dim !== t2.dim)
              throw new Error("dem dimension mismatch");
            let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, a2 = r2 * this.dim, s2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r2) {
              case -1:
                a2 = s2 - 1;
                break;
              case 1:
                s2 = a2 + 1;
            }
            let o2 = -e2 * this.dim, l2 = -r2 * this.dim;
            for (let e3 = a2; e3 < s2; e3++)
              for (let r3 = n2; r3 < i2; r3++)
                this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
          }
        }
        Mn("DEMData", uc);
        class cc {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t2.length; e2++) {
              let r2 = t2[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            if (t2 >= this._numberToString.length)
              throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t2];
          }
        }
        class hc {
          constructor(t2, e2, r2, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            let t2 = { geometry: this.geometry };
            for (let e2 in this)
              e2 !== "_geometry" && e2 !== "_vectorTileFeature" && (t2[e2] = this[e2]);
            return t2;
          }
        }
        class pc {
          constructor(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Sn(qa, 16, 0), this.grid3D = new Sn(qa, 16, 0), this.featureIndexArray = new Wi(), this.promoteId = e2;
          }
          insert(t2, e2, r2, n2, i2, a2) {
            let s2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i2);
            let o2 = a2 ? this.grid3D : this.grid;
            for (let t3 = 0; t3 < e2.length; t3++) {
              let r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r3.length; t4++) {
                let e3 = r3[t4];
                n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
              }
              n3[0] < qa && n3[1] < qa && n3[2] >= 0 && n3[3] >= 0 && o2.insert(s2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new _o.VectorTile(new ul(this.rawTileData)).layers, this.sourceLayerCoder = new cc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t2, e2, r2, n2) {
            this.loadVTLayers();
            let i2 = t2.params || {}, a2 = qa / t2.tileSize / t2.scale, s2 = Jr(i2.filter), o2 = t2.queryGeometry, l2 = t2.queryPadding * a2, u2 = dc(o2), c2 = this.grid.query(u2.minX - l2, u2.minY - l2, u2.maxX + l2, u2.maxY + l2), h2 = dc(t2.cameraQueryGeometry), p2 = this.grid3D.query(h2.minX - l2, h2.minY - l2, h2.maxX + l2, h2.maxY + l2, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
              for (let a4 of t3)
                if (e4 <= a4.x && r4 <= a4.y && n4 >= a4.x && i4 >= a4.y)
                  return !0;
              let a3 = [new S(e4, r4), new S(e4, i4), new S(n4, i4), new S(n4, r4)];
              if (t3.length > 2) {
                for (let e5 of a3)
                  if (is(t3, e5))
                    return !0;
              }
              for (let e5 = 0; e5 < t3.length - 1; e5++)
                if (as(t3[e5], t3[e5 + 1], a3))
                  return !0;
              return !1;
            }(t2.cameraQueryGeometry, e3 - l2, r3 - l2, n3 + l2, i3 + l2));
            for (let t3 of p2)
              c2.push(t3);
            c2.sort(yc);
            let f2 = {}, d2;
            for (let l3 = 0; l3 < c2.length; l3++) {
              let u3 = c2[l3];
              if (u3 === d2)
                continue;
              d2 = u3;
              let h3 = this.featureIndexArray.get(u3), p3 = null;
              this.loadMatchingFeature(f2, h3.bucketIndex, h3.sourceLayerIndex, h3.featureIndex, s2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Za(e3)), r3.queryIntersectsFeature(o2, e3, n3, p3, this.z, t2.transform, a2, t2.pixelPosMatrix)));
            }
            return f2;
          }
          loadMatchingFeature(t2, e2, r2, n2, i2, a2, s2, l2, u2, c2, h2) {
            let p2 = this.bucketLayerIDs[e2];
            if (a2 && !function(t3, e3) {
              for (let r3 = 0; r3 < t3.length; r3++)
                if (e3.indexOf(t3[r3]) >= 0)
                  return !0;
              return !1;
            }(a2, p2))
              return;
            let f2 = this.sourceLayerCoder.decode(r2), d2 = this.vtLayers[f2].feature(n2);
            if (i2.needGeometry) {
              let t3 = Ka(d2, !0);
              if (!i2.filter(new Qn(this.tileID.overscaledZ), t3, this.tileID.canonical))
                return;
            } else if (!i2.filter(new Qn(this.tileID.overscaledZ), d2))
              return;
            let y2 = this.getId(d2, f2);
            for (let e3 = 0; e3 < p2.length; e3++) {
              let r3 = p2[e3];
              if (a2 && a2.indexOf(r3) < 0)
                continue;
              let i3 = l2[r3];
              if (!i3)
                continue;
              let f3 = {};
              y2 && c2 && (f3 = c2.getState(i3.sourceLayer || "_geojsonTileLayer", y2));
              let m2 = o({}, u2[r3]);
              m2.paint = fc(m2.paint, i3.paint, d2, f3, s2), m2.layout = fc(m2.layout, i3.layout, d2, f3, s2);
              let g2 = !h2 || h2(d2, i3, f3);
              if (!g2)
                continue;
              let x2 = new hc(d2, this.z, this.x, this.y, y2);
              x2.layer = m2;
              let v2 = t2[r3];
              v2 === void 0 && (v2 = t2[r3] = []), v2.push({ featureIndex: n2, feature: x2, intersectionZ: g2 });
            }
          }
          lookupSymbolFeatures(t2, e2, r2, n2, i2, a2, s2, o2) {
            let l2 = {};
            this.loadVTLayers();
            let u2 = Jr(i2);
            for (let i3 of t2)
              this.loadMatchingFeature(l2, r2, n2, i3, u2, a2, s2, o2, e2);
            return l2;
          }
          hasLayer(t2) {
            for (let e2 of this.bucketLayerIDs)
              for (let r2 of e2)
                if (t2 === r2)
                  return !0;
            return !1;
          }
          getId(t2, e2) {
            let r2 = t2.id;
            return this.promoteId && (r2 = t2.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2]], typeof r2 == "boolean" && (r2 = Number(r2))), r2;
          }
        }
        function fc(t2, e2, r2, n2, i2) {
          return c(t2, (t3, a2) => {
            let s2 = e2 instanceof oi ? e2.get(a2) : null;
            return s2 && s2.evaluate ? s2.evaluate(r2, n2, i2) : s2;
          });
        }
        function dc(t2) {
          let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (let a2 of t2)
            e2 = Math.min(e2, a2.x), r2 = Math.min(r2, a2.y), n2 = Math.max(n2, a2.x), i2 = Math.max(i2, a2.y);
          return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
        }
        function yc(t2, e2) {
          return e2 - t2;
        }
        var mc;
        Mn("FeatureIndex", pc, { omit: ["rawTileData", "sourceLayerCoder"] }), t.PerformanceMarkers = void 0, (mc = t.PerformanceMarkers || (t.PerformanceMarkers = {})).create = "create", mc.load = "load", mc.fullLoad = "fullLoad";
        let gc = null, xc = [], vc = 1e3 / 30, bc = { mark(t2) {
          performance.mark(t2);
        }, frame(t2) {
          let e2 = t2;
          gc != null && xc.push(e2 - gc), gc = e2;
        }, clearMetrics() {
          gc = null, xc = [], performance.clearMeasures("loadTime"), performance.clearMeasures("fullLoadTime");
          for (let e2 in t.PerformanceMarkers)
            performance.clearMarks(t.PerformanceMarkers[e2]);
        }, getPerformanceMetrics() {
          performance.measure("loadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.load), performance.measure("fullLoadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.fullLoad);
          let e2 = performance.getEntriesByName("loadTime")[0].duration, r2 = performance.getEntriesByName("fullLoadTime")[0].duration, n2 = xc.length, i2 = 1 / (xc.reduce((t2, e3) => t2 + e3, 0) / n2 / 1e3), a2 = xc.filter((t2) => t2 > vc).reduce((t2, e3) => t2 + (e3 - vc) / vc, 0);
          return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: a2 / (n2 + a2) * 100 };
        } };
        t.AJAXError = q, t.ARRAY_TYPE = ps, t.Actor = class {
          constructor(t2, e2, r2) {
            this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, u(["receive", "process"], this), this.invoker = new Gu(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = g() ? t2 : window;
          }
          send(t2, e2, r2, n2, i2 = !1) {
            let a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r2 && (this.callbacks[a2] = r2);
            let s2 = _(this.globalScope) ? void 0 : [];
            return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: Bn(e2, s2) }, s2), { cancel: () => {
              r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
            } };
          }
          receive(t2) {
            let e2 = t2.data, r2 = e2.id;
            if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
              if (e2.type === "<cancel>") {
                delete this.tasks[r2];
                let t3 = this.cancelCallbacks[r2];
                delete this.cancelCallbacks[r2], t3 && t3();
              } else
                g() || e2.mustQueue ? (this.tasks[r2] = e2, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e2);
          }
          process() {
            if (!this.taskQueue.length)
              return;
            let t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
            delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), e2 && this.processTask(t2, e2);
          }
          processTask(t2, e2) {
            if (e2.type === "<response>") {
              let r2 = this.callbacks[t2];
              delete this.callbacks[t2], r2 && (e2.error ? r2(Cn(e2.error)) : r2(null, Cn(e2.data)));
            } else {
              let r2 = !1, n2 = _(this.globalScope) ? void 0 : [], i2 = e2.hasCallback ? (e3, i3) => {
                r2 = !0, delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? Bn(e3) : null, data: Bn(i3, n2) }, n2);
              } : (t3) => {
                r2 = !0;
              }, a2 = null, s2 = Cn(e2.data);
              if (this.parent[e2.type])
                a2 = this.parent[e2.type](e2.sourceMapId, s2, i2);
              else if (this.parent.getWorkerSource) {
                let t3 = e2.type.split(".");
                a2 = this.parent.getWorkerSource(e2.sourceMapId, t3[0], s2.source)[t3[1]](s2, i2);
              } else
                i2(new Error(`Could not find function ${e2.type}`));
              !r2 && a2 && a2.cancel && (this.cancelCallbacks[t2] = a2.cancel);
            }
          }
          remove() {
            this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
          }
        }, t.AlphaImage = zs, t.CanonicalTileID = ac, t.CollisionBoxArray = Ni, t.CollisionCircleLayoutArray = class extends Vi {
        }, t.Color = Ft, t.DEMData = uc, t.DataConstantProperty = li, t.DictionaryCoder = cc, t.EXTENT = qa, t.ErrorEvent = et, t.EvaluationParameters = Qn, t.Event = tt, t.Evented = rt, t.FeatureIndex = pc, t.FillBucket = mo, t.FillExtrusionBucket = Do, t.GeoJSONFeature = hc, t.ImageAtlas = Dl, t.ImagePosition = Ll, t.LineBucket = Yo, t.LineStripIndexArray = class extends Ui {
        }, t.LngLat = Xu, t.LngLatBounds = Yu, t.MercatorCoordinate = nc, t.ONE_EM = ll, t.OverscaledTileID = oc, t.PerformanceUtils = bc, t.PosArray = Qi, t.Properties = fi, t.QuadTriangleArray = class extends Fi {
        }, t.RGBAImage = Bs, t.RasterBoundsArray = class extends _i {
        }, t.RequestPerformance = class {
          constructor(t2) {
            this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t2 = performance.getEntriesByName(this._marks.measure);
            return t2.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
          }
        }, t.ResourceType = U, t.SegmentVector = ya, t.SymbolBucket = Du, t.Transitionable = ri, t.TriangleIndexArray = ha, t.Uniform1f = za, t.Uniform1i = class extends Ma {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
          }
        }, t.Uniform2f = class extends Ma {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
          }
        }, t.Uniform3f = class extends Ma {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
          }
        }, t.Uniform4f = Ba, t.UniformColor = Ca, t.UniformMatrix4f = class extends Ma {
          constructor(t2, e2) {
            super(t2, e2), this.current = Pa;
          }
          set(t2) {
            if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
              return this.current = t2, void this.gl.uniformMatrix4fv(this.location, !1, t2);
            for (let e2 = 1; e2 < 16; e2++)
              if (t2[e2] !== this.current[e2]) {
                this.current = t2, this.gl.uniformMatrix4fv(this.location, !1, t2);
                break;
              }
          }
        }, t.UnwrappedTileID = sc, t.ValidationError = it, t.ZoomHistory = Pn, t.add = function(t2, e2, r2) {
          return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
        }, t.addDynamicAttributes = Eu, t.asyncAll = function(t2, e2, r2) {
          if (!t2.length)
            return r2(null, []);
          let n2 = t2.length, i2 = new Array(t2.length), a2 = null;
          t2.forEach((t3, s2) => {
            e2(t3, (t4, e3) => {
              t4 && (a2 = t4), i2[s2] = e3, --n2 == 0 && r2(a2, i2);
            });
          });
        }, t.bezier = n, t.bindAll = u, t.cacheEntryPossiblyAdded = function(t2) {
          F++, F > V && (t2.getActor().send("enforceCacheSizeLimit", P), F = 0);
        }, t.clamp = a, t.clearTileCache = function(t2) {
          let e2 = caches.delete(z);
          t2 && e2.catch(t2).then(() => t2());
        }, t.clipLine = cu, t.clone = function(t2) {
          var e2 = new ps(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }, t.clone$1 = p, t.clone$2 = function(t2) {
          var e2 = new ps(3);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
        }, t.collisionCircleLayout = al, t.config = M, t.copy = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.create = function() {
          var t2 = new ps(16);
          return ps != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.create$1 = fs, t.createExpression = Fr, t.createFilter = Jr, t.createLayout = vi, t.createStyleLayer = function(t2) {
          return t2.type === "custom" ? new Zu(t2) : new Ku[t2.type](t2);
        }, t.cross = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2], s2 = r2[0], o2 = r2[1], l2 = r2[2];
          return t2[0] = i2 * l2 - a2 * o2, t2[1] = a2 * s2 - n2 * l2, t2[2] = n2 * o2 - i2 * s2, t2;
        }, t.dot = function(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
        }, t.dot$1 = function(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
        }, t.ease = i, t.emitValidationErrors = kn, t.enforceCacheSizeLimit = function(t2) {
          E(), B && B.then((e2) => {
            e2.keys().then((r2) => {
              for (let n2 = 0; n2 < r2.length - t2; n2++)
                e2.delete(r2[n2]);
            });
          });
        }, t.equals = function(t2, e2) {
          var r2 = t2[0], n2 = t2[1], i2 = t2[2], a2 = t2[3], s2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y2 = t2[13], m2 = t2[14], g2 = t2[15], x2 = e2[0], v2 = e2[1], b2 = e2[2], w2 = e2[3], _2 = e2[4], A2 = e2[5], k2 = e2[6], S2 = e2[7], I2 = e2[8], M2 = e2[9], z2 = e2[10], B2 = e2[11], C2 = e2[12], P2 = e2[13], V2 = e2[14], E2 = e2[15];
          return Math.abs(r2 - x2) <= hs * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n2 - v2) <= hs * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i2 - b2) <= hs * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(a2 - w2) <= hs * Math.max(1, Math.abs(a2), Math.abs(w2)) && Math.abs(s2 - _2) <= hs * Math.max(1, Math.abs(s2), Math.abs(_2)) && Math.abs(o2 - A2) <= hs * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - k2) <= hs * Math.max(1, Math.abs(l2), Math.abs(k2)) && Math.abs(u2 - S2) <= hs * Math.max(1, Math.abs(u2), Math.abs(S2)) && Math.abs(c2 - I2) <= hs * Math.max(1, Math.abs(c2), Math.abs(I2)) && Math.abs(h2 - M2) <= hs * Math.max(1, Math.abs(h2), Math.abs(M2)) && Math.abs(p2 - z2) <= hs * Math.max(1, Math.abs(p2), Math.abs(z2)) && Math.abs(f2 - B2) <= hs * Math.max(1, Math.abs(f2), Math.abs(B2)) && Math.abs(d2 - C2) <= hs * Math.max(1, Math.abs(d2), Math.abs(C2)) && Math.abs(y2 - P2) <= hs * Math.max(1, Math.abs(y2), Math.abs(P2)) && Math.abs(m2 - V2) <= hs * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E2) <= hs * Math.max(1, Math.abs(g2), Math.abs(E2));
        }, t.evaluateSizeForFeature = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
          return t2.kind === "source" ? n2 / tu : t2.kind === "composite" ? Se(n2 / tu, i2 / tu, r2) : e2;
        }, t.evaluateSizeForZoom = function(t2, e2) {
          let r2 = 0, n2 = 0;
          if (t2.kind === "constant")
            n2 = t2.layoutSize;
          else if (t2.kind !== "source") {
            let { interpolationType: i2, minZoom: s2, maxZoom: o2 } = t2, l2 = i2 ? a(Ne.interpolationFactor(i2, e2, s2, o2), 0, 1) : 0;
            t2.kind === "camera" ? n2 = Se(t2.minSize, t2.maxSize, l2) : r2 = l2;
          }
          return { uSizeT: r2, uSize: n2 };
        }, t.evaluateVariableOffset = Au, t.evented = Xn, t.exported = k, t.exported$1 = T, t.extend = o, t.filterObject = h, t.fromRotation = function(t2, e2) {
          var r2 = Math.sin(e2), n2 = Math.cos(e2);
          return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, t.fromScaling = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, t.getAnchorAlignment = Yl, t.getAnchorJustification = ku, t.getArrayBuffer = K, t.getImage = H, t.getJSON = function(t2, e2) {
          return Z(o(t2, { type: "json" }), e2);
        }, t.getOverlapMode = qu, t.getRTLTextPluginStatus = Yn, t.getReferrer = j, t.getVideo = function(t2, e2) {
          let r2 = window.document.createElement("video");
          r2.muted = !0, r2.onloadstart = function() {
            e2(null, r2);
          };
          for (let e3 = 0; e3 < t2.length; e3++) {
            let n2 = window.document.createElement("source");
            G(t2[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e3], r2.appendChild(n2);
          }
          return { cancel: () => {
          } };
        }, t.identity = ds, t.invert = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3], s2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * s2, v2 = r2 * l2 - i2 * s2, b2 = r2 * u2 - a2 * s2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - a2 * o2, A2 = i2 * u2 - a2 * l2, k2 = c2 * y2 - h2 * d2, S2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, M2 = h2 * m2 - p2 * y2, z2 = h2 * g2 - f2 * y2, B2 = p2 * g2 - f2 * m2, C2 = x2 * B2 - v2 * z2 + b2 * M2 + w2 * I2 - _2 * S2 + A2 * k2;
          return C2 ? (t2[0] = (o2 * B2 - l2 * z2 + u2 * M2) * (C2 = 1 / C2), t2[1] = (i2 * z2 - n2 * B2 - a2 * M2) * C2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * C2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C2, t2[4] = (l2 * I2 - s2 * B2 - u2 * S2) * C2, t2[5] = (r2 * B2 - i2 * I2 + a2 * S2) * C2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * C2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * C2, t2[8] = (s2 * z2 - o2 * I2 + u2 * k2) * C2, t2[9] = (n2 * I2 - r2 * z2 - a2 * k2) * C2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * C2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C2, t2[12] = (o2 * S2 - s2 * M2 - l2 * k2) * C2, t2[13] = (r2 * M2 - n2 * S2 + i2 * k2) * C2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * C2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * C2, t2) : null;
        }, t.isImageBitmap = A, t.isSafari = _, t.isWorker = g, t.keysDifference = function(t2, e2) {
          let r2 = [];
          for (let n2 in t2)
            n2 in e2 || r2.push(n2);
          return r2;
        }, t.lazyLoadRTLTextPlugin = function() {
          Wn.isLoading() || Wn.isLoaded() || Yn() !== "deferred" || Hn();
        }, t.makeRequest = Z, t.mapObject = c, t.mercatorXfromLng = Qu, t.mercatorYfromLat = tc, t.mercatorZfromAltitude = ec, t.mul = gs, t.mul$1 = function(t2, e2, r2) {
          return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
        }, t.multiply = ys, t.nextPowerOfTwo = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
        }, t.normalize = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = r2 * r2 + n2 * n2 + i2 * i2;
          return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = e2[0] * a2, t2[1] = e2[1] * a2, t2[2] = e2[2] * a2, t2;
        }, t.number = Se, t.ortho = function(t2, e2, r2, n2, i2, a2, s2) {
          var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (a2 - s2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (s2 + a2) * u2, t2[15] = 1, t2;
        }, t.parseCacheControl = x, t.parseGlyphPbf = function(t2) {
          return new ul(t2).readFields(Vl, []);
        }, t.pbf = ul, t.performSymbolLayout = function(e2) {
          e2.bucket.createArrays(), e2.bucket.tilePixelRatio = qa / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = !1;
          let r2 = e2.bucket.layers[0].layout, n2 = e2.bucket.layers[0]._unevaluatedLayout._values, i2 = { layoutIconSize: n2["icon-size"].possiblyEvaluate(new Qn(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: n2["text-size"].possiblyEvaluate(new Qn(e2.bucket.zoom + 1), e2.canonical), textMaxSize: n2["text-size"].possiblyEvaluate(new Qn(18)) };
          if (e2.bucket.textSizeData.kind === "composite") {
            let { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
            i2.compositeTextSizes = [n2["text-size"].possiblyEvaluate(new Qn(t2), e2.canonical), n2["text-size"].possiblyEvaluate(new Qn(r3), e2.canonical)];
          }
          if (e2.bucket.iconSizeData.kind === "composite") {
            let { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
            i2.compositeIconSizes = [n2["icon-size"].possiblyEvaluate(new Qn(t2), e2.canonical), n2["icon-size"].possiblyEvaluate(new Qn(r3), e2.canonical)];
          }
          let a2 = r2.get("text-line-height") * ll, s2 = r2.get("text-rotation-alignment") !== "viewport" && r2.get("symbol-placement") !== "point", o2 = r2.get("text-keep-upright"), l2 = r2.get("text-size");
          for (let n3 of e2.bucket.features) {
            let u2 = r2.get("text-font").evaluate(n3, {}, e2.canonical).join(","), c2 = l2.evaluate(n3, {}, e2.canonical), h2 = i2.layoutTextSize.evaluate(n3, {}, e2.canonical), p2 = i2.layoutIconSize.evaluate(n3, {}, e2.canonical), f2 = { horizontal: {}, vertical: void 0 }, y2 = n3.text, m2, g2 = [0, 0];
            if (y2) {
              let i3 = y2.toString(), l3 = r2.get("text-letter-spacing").evaluate(n3, {}, e2.canonical) * ll, p3 = Fn(i3) ? l3 : 0, d2 = r2.get("text-anchor").evaluate(n3, {}, e2.canonical), m3 = r2.get("text-variable-anchor");
              if (!m3) {
                let t2 = r2.get("text-radial-offset").evaluate(n3, {}, e2.canonical);
                g2 = t2 ? Au(d2, [t2 * ll, _u]) : r2.get("text-offset").evaluate(n3, {}, e2.canonical).map((t3) => t3 * ll);
              }
              let x3 = s2 ? "center" : r2.get("text-justify").evaluate(n3, {}, e2.canonical), v3 = r2.get("symbol-placement"), b2 = v3 === "point" ? r2.get("text-max-width").evaluate(n3, {}, e2.canonical) * ll : 0, w2 = () => {
                e2.bucket.allowVerticalPlacement && En(i3) && (f2.vertical = Ul(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, u2, b2, a2, d2, "left", p3, g2, t.WritingMode.vertical, !0, v3, h2, c2));
              };
              if (!s2 && m3) {
                let r3 = x3 === "auto" ? m3.map((t2) => ku(t2)) : [x3], n4 = !1;
                for (let i4 = 0; i4 < r3.length; i4++) {
                  let s3 = r3[i4];
                  if (!f2.horizontal[s3])
                    if (n4)
                      f2.horizontal[s3] = f2.horizontal[0];
                    else {
                      let r4 = Ul(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, u2, b2, a2, "center", s3, p3, g2, t.WritingMode.horizontal, !1, v3, h2, c2);
                      r4 && (f2.horizontal[s3] = r4, n4 = r4.positionedLines.length === 1);
                    }
                }
                w2();
              } else {
                x3 === "auto" && (x3 = ku(d2));
                let r3 = Ul(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, u2, b2, a2, d2, x3, p3, g2, t.WritingMode.horizontal, !1, v3, h2, c2);
                r3 && (f2.horizontal[x3] = r3), w2(), En(i3) && s2 && o2 && (f2.vertical = Ul(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, u2, b2, a2, d2, x3, p3, g2, t.WritingMode.vertical, !1, v3, h2, c2));
              }
            }
            let x2 = !1;
            if (n3.icon && n3.icon.name) {
              let t2 = e2.imageMap[n3.icon.name];
              t2 && (m2 = Wl(e2.imagePositions[n3.icon.name], r2.get("icon-offset").evaluate(n3, {}, e2.canonical), r2.get("icon-anchor").evaluate(n3, {}, e2.canonical)), x2 = !!t2.sdf, e2.bucket.sdfIcons === void 0 ? e2.bucket.sdfIcons = x2 : e2.bucket.sdfIcons !== x2 && d("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || r2.get("icon-rotate").constantOr(1) !== 0) && (e2.bucket.iconsNeedLinear = !0));
            }
            let v2 = zu(f2.horizontal) || f2.vertical;
            e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && Su(e2.bucket, n3, f2, m2, e2.imageMap, i2, h2, p2, g2, x2, e2.canonical);
          }
          e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
        }, t.perspective = function(t2, e2, r2, n2, i2) {
          var a2, s2 = 1 / Math.tan(e2 / 2);
          return t2[0] = s2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = s2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, i2 != null && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (a2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * a2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
        }, t.pick = function(t2, e2) {
          let r2 = {};
          for (let n2 = 0; n2 < e2.length; n2++) {
            let i2 = e2[n2];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.plugin = Wn, t.pointGeometry = S, t.polygonIntersectsPolygon = Xa, t.potpack = Tl, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = Mn, t.registerForPluginStateChange = function(t2) {
          return t2({ pluginStatus: Zn, pluginURL: Kn }), Xn.on("pluginStateChange", t2), t2;
        }, t.renderColorRamp = Cs, t.rotateX = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[4], s2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = a2 * i2 + u2 * n2, t2[5] = s2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - a2 * n2, t2[9] = c2 * i2 - s2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
        }, t.rotateZ = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[0], s2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = a2 * i2 + u2 * n2, t2[1] = s2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - a2 * n2, t2[5] = c2 * i2 - s2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
        }, t.scale = function(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], a2 = r2[2];
          return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * a2, t2[9] = e2[9] * a2, t2[10] = e2[10] * a2, t2[11] = e2[11] * a2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.scale$1 = function(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
        }, t.setCacheLimits = function(t2, e2) {
          P = t2, V = e2;
        }, t.setRTLTextPlugin = function(t2, e2, r2 = !1) {
          if (Zn === Un || Zn === qn || Zn === jn)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          Kn = k.resolveURL(t2), Zn = Un, Nn = e2, Jn(), r2 || Hn();
        }, t.spec = nt, t.sphericalToCartesian = function([t2, e2, r2]) {
          return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
        }, t.sqrLen = function(t2) {
          var e2 = t2[0], r2 = t2[1];
          return e2 * e2 + r2 * r2;
        }, t.sub = function(t2, e2, r2) {
          return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
        }, t.toEvaluationFeature = Ka, t.transformMat3 = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], a2 = e2[2];
          return t2[0] = n2 * r2[0] + i2 * r2[3] + a2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + a2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + a2 * r2[8], t2;
        }, t.transformMat4 = bs, t.transformMat4$1 = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[12], t2[1] = r2[1] * n2 + r2[5] * i2 + r2[13], t2;
        }, t.translate = function(t2, e2, r2) {
          var n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
          return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], a2 = e2[2], s2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = a2, t2[3] = s2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = a2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = s2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
        }, t.triggerPluginCompletionEvent = Gn, t.unicodeBlockLookup = Vn, t.uniqueId = function() {
          return l++;
        }, t.validateCustomStyleLayer = function(t2) {
          let e2 = [], r2 = t2.id;
          return r2 === void 0 && e2.push({ message: `layers.${r2}: missing required property "id"` }), t2.render === void 0 && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && t2.renderingMode !== "2d" && t2.renderingMode !== "3d" && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t.validateLight = wn, t.validateStyle = bn, t.vectorTile = _o, t.warnOnce = d, t.wrap = s;
      }), define2(["./shared"], function(e) {
        "use strict";
        function t(e2) {
          let o2 = typeof e2;
          if (o2 === "number" || o2 === "boolean" || o2 === "string" || e2 == null)
            return JSON.stringify(e2);
          if (Array.isArray(e2)) {
            let o3 = "[";
            for (let i3 of e2)
              o3 += `${t(i3)},`;
            return `${o3}]`;
          }
          let i2 = Object.keys(e2).sort(), r2 = "{";
          for (let o3 = 0; o3 < i2.length; o3++)
            r2 += `${JSON.stringify(i2[o3])}:${t(e2[i2[o3]])},`;
          return `${r2}}`;
        }
        function o(o2) {
          let i2 = "";
          for (let r2 of e.refProperties)
            i2 += `/${t(o2[r2])}`;
          return i2;
        }
        class i {
          constructor(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          }
          replace(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }
          update(t2, i2) {
            for (let o2 of t2) {
              this._layerConfigs[o2.id] = o2;
              let t3 = this._layers[o2.id] = e.createStyleLayer(o2);
              t3._featureFilter = e.createFilter(t3.filter), this.keyCache[o2.id] && delete this.keyCache[o2.id];
            }
            for (let e2 of i2)
              delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            let r2 = function(e2, t3) {
              let i3 = {};
              for (let r4 = 0; r4 < e2.length; r4++) {
                let n2 = t3 && t3[e2[r4].id] || o(e2[r4]);
                t3 && (t3[e2[r4].id] = n2);
                let s2 = i3[n2];
                s2 || (s2 = i3[n2] = []), s2.push(e2[r4]);
              }
              let r3 = [];
              for (let e3 in i3)
                r3.push(i3[e3]);
              return r3;
            }(Object.values(this._layerConfigs), this.keyCache);
            for (let e2 of r2) {
              let t3 = e2.map((e3) => this._layers[e3.id]), o2 = t3[0];
              if (o2.visibility === "none")
                continue;
              let i3 = o2.source || "", r3 = this.familiesBySource[i3];
              r3 || (r3 = this.familiesBySource[i3] = {});
              let n2 = o2.sourceLayer || "_geojsonTileLayer", s2 = r3[n2];
              s2 || (s2 = r3[n2] = []), s2.push(t3);
            }
          }
        }
        class r {
          constructor(t2) {
            let o2 = {}, i2 = [];
            for (let e2 in t2) {
              let r3 = t2[e2], n3 = o2[e2] = {};
              for (let e3 in r3) {
                let t3 = r3[+e3];
                if (!t3 || t3.bitmap.width === 0 || t3.bitmap.height === 0)
                  continue;
                let o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                i2.push(o3), n3[e3] = { rect: o3, metrics: t3.metrics };
              }
            }
            let { w: r2, h: n2 } = e.potpack(i2), s2 = new e.AlphaImage({ width: r2 || 1, height: n2 || 1 });
            for (let i3 in t2) {
              let r3 = t2[i3];
              for (let t3 in r3) {
                let n3 = r3[+t3];
                if (!n3 || n3.bitmap.width === 0 || n3.bitmap.height === 0)
                  continue;
                let a2 = o2[i3][t3].rect;
                e.AlphaImage.copy(n3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, n3.bitmap);
              }
            }
            this.image = s2, this.positions = o2;
          }
        }
        e.register("GlyphAtlas", r);
        class n {
          constructor(t2) {
            this.tileID = new e.OverscaledTileID(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId;
          }
          parse(t2, o2, i2, n2, a2) {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.CollisionBoxArray();
            let l2 = new e.DictionaryCoder(Object.keys(t2.layers).sort()), c2 = new e.FeatureIndex(this.tileID, this.promoteId);
            c2.bucketLayerIDs = [];
            let u2 = {}, h2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i2 }, p2 = o2.familiesBySource[this.source];
            for (let o3 in p2) {
              let r2 = t2.layers[o3];
              if (!r2)
                continue;
              r2.version === 1 && e.warnOnce(`Vector tile source "${this.source}" layer "${o3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              let n3 = l2.encode(o3), a3 = [];
              for (let e2 = 0; e2 < r2.length; e2++) {
                let t3 = r2.feature(e2), i3 = c2.getId(t3, o3);
                a3.push({ feature: t3, id: i3, index: e2, sourceLayerIndex: n3 });
              }
              for (let t3 of p2[o3]) {
                let o4 = t3[0];
                o4.source !== this.source && e.warnOnce(`layer.source = ${o4.source} does not equal this.source = ${this.source}`), o4.minzoom && this.zoom < Math.floor(o4.minzoom) || o4.maxzoom && this.zoom >= o4.maxzoom || o4.visibility !== "none" && (s(t3, this.zoom, i2), (u2[o4.id] = o4.createBucket({ index: c2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(a3, h2, this.tileID.canonical), c2.bucketLayerIDs.push(t3.map((e2) => e2.id)));
              }
            }
            let f2, d2, g2, m2, y2 = e.mapObject(h2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
            Object.keys(y2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: y2 }, (e2, t3) => {
              f2 || (f2 = e2, d2 = t3, w2.call(this));
            }) : d2 = {};
            let v2 = Object.keys(h2.iconDependencies);
            v2.length ? n2.send("getImages", { icons: v2, source: this.source, tileID: this.tileID, type: "icons" }, (e2, t3) => {
              f2 || (f2 = e2, g2 = t3, w2.call(this));
            }) : g2 = {};
            let x2 = Object.keys(h2.patternDependencies);
            function w2() {
              if (f2)
                return a2(f2);
              if (d2 && g2 && m2) {
                let t3 = new r(d2), o3 = new e.ImageAtlas(g2, m2);
                for (let r2 in u2) {
                  let n3 = u2[r2];
                  n3 instanceof e.SymbolBucket ? (s(n3.layers, this.zoom, i2), e.performSymbolLayout({ bucket: n3, glyphMap: d2, glyphPositions: t3.positions, imageMap: g2, imagePositions: o3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : n3.hasPattern && (n3 instanceof e.LineBucket || n3 instanceof e.FillBucket || n3 instanceof e.FillExtrusionBucket) && (s(n3.layers, this.zoom, i2), n3.addFeatures(h2, this.tileID.canonical, o3.patternPositions));
                }
                this.status = "done", a2(null, { buckets: Object.values(u2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, imageAtlas: o3, glyphMap: this.returnDependencies ? d2 : null, iconMap: this.returnDependencies ? g2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
              }
            }
            x2.length ? n2.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "patterns" }, (e2, t3) => {
              f2 || (f2 = e2, m2 = t3, w2.call(this));
            }) : m2 = {}, w2.call(this);
          }
        }
        function s(t2, o2, i2) {
          let r2 = new e.EvaluationParameters(o2);
          for (let e2 of t2)
            e2.recalculate(r2, i2);
        }
        function a(t2, o2) {
          let i2 = e.getArrayBuffer(t2.request, (t3, i3, r2, n2) => {
            t3 ? o2(t3) : i3 && o2(null, { vectorTile: new e.vectorTile.VectorTile(new e.pbf(i3)), rawData: i3, cacheControl: r2, expires: n2 });
          });
          return () => {
            i2.cancel(), o2();
          };
        }
        class l {
          constructor(e2, t2, o2, i2) {
            this.actor = e2, this.layerIndex = t2, this.availableImages = o2, this.loadVectorData = i2 || a, this.loading = {}, this.loaded = {};
          }
          loadTile(t2, o2) {
            let i2 = t2.uid;
            this.loading || (this.loading = {});
            let r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request), s2 = this.loading[i2] = new n(t2);
            s2.abort = this.loadVectorData(t2, (t3, n2) => {
              if (delete this.loading[i2], t3 || !n2)
                return s2.status = "done", this.loaded[i2] = s2, o2(t3);
              let a2 = n2.rawData, l2 = {};
              n2.expires && (l2.expires = n2.expires), n2.cacheControl && (l2.cacheControl = n2.cacheControl);
              let c2 = {};
              if (r2) {
                let e2 = r2.finish();
                e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
              }
              s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, i3) => {
                if (t4 || !i3)
                  return o2(t4);
                o2(null, e.extend({ rawTileData: a2.slice(0) }, i3, l2, c2));
              }), this.loaded = this.loaded || {}, this.loaded[i2] = s2;
            });
          }
          reloadTile(e2, t2) {
            let o2 = this.loaded, i2 = e2.uid, r2 = this;
            if (o2 && o2[i2]) {
              let n2 = o2[i2];
              n2.showCollisionBoxes = e2.showCollisionBoxes;
              let s2 = (e3, o3) => {
                let i3 = n2.reloadCallback;
                i3 && (delete n2.reloadCallback, n2.parse(n2.vectorTile, r2.layerIndex, this.availableImages, r2.actor, i3)), t2(e3, o3);
              };
              n2.status === "parsing" ? n2.reloadCallback = s2 : n2.status === "done" && (n2.vectorTile ? n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
            }
          }
          abortTile(e2, t2) {
            let o2 = this.loading, i2 = e2.uid;
            o2 && o2[i2] && o2[i2].abort && (o2[i2].abort(), delete o2[i2]), t2();
          }
          removeTile(e2, t2) {
            let o2 = this.loaded, i2 = e2.uid;
            o2 && o2[i2] && delete o2[i2], t2();
          }
        }
        class c {
          constructor() {
            this.loaded = {};
          }
          loadTile(t2, o2) {
            let { uid: i2, encoding: r2, rawImageData: n2 } = t2, s2 = e.isImageBitmap(n2) ? this.getImageData(n2) : n2, a2 = new e.DEMData(i2, s2, r2);
            this.loaded = this.loaded || {}, this.loaded[i2] = a2, o2(null, a2);
          }
          getImageData(t2) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
            let o2 = this.offscreenCanvasContext.getImageData(-1, -1, t2.width + 2, t2.height + 2);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
          }
          removeTile(e2) {
            let t2 = this.loaded, o2 = e2.uid;
            t2 && t2[o2] && delete t2[o2];
          }
        }
        var u = function e2(t2, o2) {
          var i2, r2 = t2 && t2.type;
          if (r2 === "FeatureCollection")
            for (i2 = 0; i2 < t2.features.length; i2++)
              e2(t2.features[i2], o2);
          else if (r2 === "GeometryCollection")
            for (i2 = 0; i2 < t2.geometries.length; i2++)
              e2(t2.geometries[i2], o2);
          else if (r2 === "Feature")
            e2(t2.geometry, o2);
          else if (r2 === "Polygon")
            h(t2.coordinates, o2);
          else if (r2 === "MultiPolygon")
            for (i2 = 0; i2 < t2.coordinates.length; i2++)
              h(t2.coordinates[i2], o2);
          return t2;
        };
        function h(e2, t2) {
          if (e2.length !== 0) {
            p(e2[0], t2);
            for (var o2 = 1; o2 < e2.length; o2++)
              p(e2[o2], !t2);
          }
        }
        function p(e2, t2) {
          for (var o2 = 0, i2 = 0, r2 = 0, n2 = e2.length, s2 = n2 - 1; r2 < n2; s2 = r2++) {
            var a2 = (e2[r2][0] - e2[s2][0]) * (e2[s2][1] + e2[r2][1]), l2 = o2 + a2;
            i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
          }
          o2 + i2 >= 0 != !!t2 && e2.reverse();
        }
        let f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;
        class d {
          constructor(t2) {
            this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              let t2 = [];
              for (let o2 of this._feature.geometry)
                t2.push([new e.pointGeometry(o2[0], o2[1])]);
              return t2;
            }
            {
              let t2 = [];
              for (let o2 of this._feature.geometry) {
                let i2 = [];
                for (let t3 of o2)
                  i2.push(new e.pointGeometry(t3[0], t3[1]));
                t2.push(i2);
              }
              return t2;
            }
          }
          toGeoJSON(e2, t2, o2) {
            return f.call(this, e2, t2, o2);
          }
        }
        class g {
          constructor(t2) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
          }
          feature(e2) {
            return new d(this._features[e2]);
          }
        }
        var m = { exports: {} }, y = e.pointGeometry, v = e.vectorTile.VectorTileFeature, x = w;
        function w(e2, t2) {
          this.options = t2 || {}, this.features = e2, this.length = e2.length;
        }
        function S(e2, t2) {
          this.id = typeof e2.id == "number" ? e2.id : void 0, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
        }
        w.prototype.feature = function(e2) {
          return new S(this.features[e2], this.options.extent);
        }, S.prototype.loadGeometry = function() {
          var e2 = this.rawGeometry;
          this.geometry = [];
          for (var t2 = 0; t2 < e2.length; t2++) {
            for (var o2 = e2[t2], i2 = [], r2 = 0; r2 < o2.length; r2++)
              i2.push(new y(o2[r2][0], o2[r2][1]));
            this.geometry.push(i2);
          }
          return this.geometry;
        }, S.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t2 = 1 / 0, o2 = -1 / 0, i2 = 1 / 0, r2 = -1 / 0, n2 = 0; n2 < e2.length; n2++)
            for (var s2 = e2[n2], a2 = 0; a2 < s2.length; a2++) {
              var l2 = s2[a2];
              t2 = Math.min(t2, l2.x), o2 = Math.max(o2, l2.x), i2 = Math.min(i2, l2.y), r2 = Math.max(r2, l2.y);
            }
          return [t2, i2, o2, r2];
        }, S.prototype.toGeoJSON = v.prototype.toGeoJSON;
        var M = e.pbf, I = x;
        function b(e2) {
          var t2 = new M();
          return function(e3, t3) {
            for (var o2 in e3.layers)
              t3.writeMessage(3, k, e3.layers[o2]);
          }(e2, t2), t2.finish();
        }
        function k(e2, t2) {
          var o2;
          t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
          var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (o2 = 0; o2 < e2.length; o2++)
            i2.feature = e2.feature(o2), t2.writeMessage(2, P, i2);
          var r2 = i2.keys;
          for (o2 = 0; o2 < r2.length; o2++)
            t2.writeStringField(3, r2[o2]);
          var n2 = i2.values;
          for (o2 = 0; o2 < n2.length; o2++)
            t2.writeMessage(4, L, n2[o2]);
        }
        function P(e2, t2) {
          var o2 = e2.feature;
          o2.id !== void 0 && t2.writeVarintField(1, o2.id), t2.writeMessage(2, T, e2), t2.writeVarintField(3, o2.type), t2.writeMessage(4, D, o2);
        }
        function T(e2, t2) {
          var o2 = e2.feature, i2 = e2.keys, r2 = e2.values, n2 = e2.keycache, s2 = e2.valuecache;
          for (var a2 in o2.properties) {
            var l2 = o2.properties[a2], c2 = n2[a2];
            if (l2 !== null) {
              c2 === void 0 && (i2.push(a2), n2[a2] = c2 = i2.length - 1), t2.writeVarint(c2);
              var u2 = typeof l2;
              u2 !== "string" && u2 !== "boolean" && u2 !== "number" && (l2 = JSON.stringify(l2));
              var h2 = u2 + ":" + l2, p2 = s2[h2];
              p2 === void 0 && (r2.push(l2), s2[h2] = p2 = r2.length - 1), t2.writeVarint(p2);
            }
          }
        }
        function C(e2, t2) {
          return (t2 << 3) + (7 & e2);
        }
        function _(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function D(e2, t2) {
          for (var o2 = e2.loadGeometry(), i2 = e2.type, r2 = 0, n2 = 0, s2 = o2.length, a2 = 0; a2 < s2; a2++) {
            var l2 = o2[a2], c2 = 1;
            i2 === 1 && (c2 = l2.length), t2.writeVarint(C(1, c2));
            for (var u2 = i2 === 3 ? l2.length - 1 : l2.length, h2 = 0; h2 < u2; h2++) {
              h2 === 1 && i2 !== 1 && t2.writeVarint(C(2, u2 - 1));
              var p2 = l2[h2].x - r2, f2 = l2[h2].y - n2;
              t2.writeVarint(_(p2)), t2.writeVarint(_(f2)), r2 += p2, n2 += f2;
            }
            i2 === 3 && t2.writeVarint(C(7, 1));
          }
        }
        function L(e2, t2) {
          var o2 = typeof e2;
          o2 === "string" ? t2.writeStringField(1, e2) : o2 === "boolean" ? t2.writeBooleanField(7, e2) : o2 === "number" && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
        }
        function z(e2, t2, o2, i2, r2, n2) {
          if (r2 - i2 <= o2)
            return;
          let s2 = i2 + r2 >> 1;
          O(e2, t2, s2, i2, r2, n2 % 2), z(e2, t2, o2, i2, s2 - 1, n2 + 1), z(e2, t2, o2, s2 + 1, r2, n2 + 1);
        }
        function O(e2, t2, o2, i2, r2, n2) {
          for (; r2 > i2; ) {
            if (r2 - i2 > 600) {
              let s3 = r2 - i2 + 1, a3 = o2 - i2 + 1, l3 = Math.log(s3), c2 = 0.5 * Math.exp(2 * l3 / 3), u2 = 0.5 * Math.sqrt(l3 * c2 * (s3 - c2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
              O(e2, t2, o2, Math.max(i2, Math.floor(o2 - a3 * c2 / s3 + u2)), Math.min(r2, Math.floor(o2 + (s3 - a3) * c2 / s3 + u2)), n2);
            }
            let s2 = t2[2 * o2 + n2], a2 = i2, l2 = r2;
            for (E(e2, t2, i2, o2), t2[2 * r2 + n2] > s2 && E(e2, t2, i2, r2); a2 < l2; ) {
              for (E(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + n2] < s2; )
                a2++;
              for (; t2[2 * l2 + n2] > s2; )
                l2--;
            }
            t2[2 * i2 + n2] === s2 ? E(e2, t2, i2, l2) : (l2++, E(e2, t2, l2, r2)), l2 <= o2 && (i2 = l2 + 1), o2 <= l2 && (r2 = l2 - 1);
          }
        }
        function E(e2, t2, o2, i2) {
          F(e2, o2, i2), F(t2, 2 * o2, 2 * i2), F(t2, 2 * o2 + 1, 2 * i2 + 1);
        }
        function F(e2, t2, o2) {
          let i2 = e2[t2];
          e2[t2] = e2[o2], e2[o2] = i2;
        }
        function N(e2, t2, o2, i2) {
          let r2 = e2 - o2, n2 = t2 - i2;
          return r2 * r2 + n2 * n2;
        }
        m.exports = b, m.exports.fromVectorTileJs = b, m.exports.fromGeojsonVt = function(e2, t2) {
          t2 = t2 || {};
          var o2 = {};
          for (var i2 in e2)
            o2[i2] = new I(e2[i2].features, t2), o2[i2].name = i2, o2[i2].version = t2.version, o2[i2].extent = t2.extent;
          return b({ layers: o2 });
        }, m.exports.GeoJSONWrapper = I;
        let A = (e2) => e2[0], B = (e2) => e2[1];
        class J {
          constructor(e2, t2 = A, o2 = B, i2 = 64, r2 = Float64Array) {
            this.nodeSize = i2, this.points = e2;
            let n2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new n2(e2.length), a2 = this.coords = new r2(2 * e2.length);
            for (let i3 = 0; i3 < e2.length; i3++)
              s2[i3] = i3, a2[2 * i3] = t2(e2[i3]), a2[2 * i3 + 1] = o2(e2[i3]);
            z(s2, a2, i2, 0, s2.length - 1, 0);
          }
          range(e2, t2, o2, i2) {
            return function(e3, t3, o3, i3, r2, n2, s2) {
              let a2 = [0, e3.length - 1, 0], l2 = [], c2, u2;
              for (; a2.length; ) {
                let h2 = a2.pop(), p2 = a2.pop(), f2 = a2.pop();
                if (p2 - f2 <= s2) {
                  for (let s3 = f2; s3 <= p2; s3++)
                    c2 = t3[2 * s3], u2 = t3[2 * s3 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e3[s3]);
                  continue;
                }
                let d2 = Math.floor((f2 + p2) / 2);
                c2 = t3[2 * d2], u2 = t3[2 * d2 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e3[d2]);
                let g2 = (h2 + 1) % 2;
                (h2 === 0 ? o3 <= c2 : i3 <= u2) && (a2.push(f2), a2.push(d2 - 1), a2.push(g2)), (h2 === 0 ? r2 >= c2 : n2 >= u2) && (a2.push(d2 + 1), a2.push(p2), a2.push(g2));
              }
              return l2;
            }(this.ids, this.coords, e2, t2, o2, i2, this.nodeSize);
          }
          within(e2, t2, o2) {
            return function(e3, t3, o3, i2, r2, n2) {
              let s2 = [0, e3.length - 1, 0], a2 = [], l2 = r2 * r2;
              for (; s2.length; ) {
                let c2 = s2.pop(), u2 = s2.pop(), h2 = s2.pop();
                if (u2 - h2 <= n2) {
                  for (let r3 = h2; r3 <= u2; r3++)
                    N(t3[2 * r3], t3[2 * r3 + 1], o3, i2) <= l2 && a2.push(e3[r3]);
                  continue;
                }
                let p2 = Math.floor((h2 + u2) / 2), f2 = t3[2 * p2], d2 = t3[2 * p2 + 1];
                N(f2, d2, o3, i2) <= l2 && a2.push(e3[p2]);
                let g2 = (c2 + 1) % 2;
                (c2 === 0 ? o3 - r2 <= f2 : i2 - r2 <= d2) && (s2.push(h2), s2.push(p2 - 1), s2.push(g2)), (c2 === 0 ? o3 + r2 >= f2 : i2 + r2 >= d2) && (s2.push(p2 + 1), s2.push(u2), s2.push(g2));
              }
              return a2;
            }(this.ids, this.coords, e2, t2, o2, this.nodeSize);
          }
        }
        let Z = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (e2) => e2 }, G = Math.fround || (j = new Float32Array(1), (e2) => (j[0] = +e2, j[0]));
        var j;
        class Y {
          constructor(e2) {
            this.options = H(Object.create(Z), e2), this.trees = new Array(this.options.maxZoom + 1);
          }
          load(e2) {
            let { log: t2, minZoom: o2, maxZoom: i2, nodeSize: r2 } = this.options;
            t2 && console.time("total time");
            let n2 = `prepare ${e2.length} points`;
            t2 && console.time(n2), this.points = e2;
            let s2 = [];
            for (let t3 = 0; t3 < e2.length; t3++)
              e2[t3].geometry && s2.push(X(e2[t3], t3));
            this.trees[i2 + 1] = new J(s2, K, Q, r2, Float32Array), t2 && console.timeEnd(n2);
            for (let e3 = i2; e3 >= o2; e3--) {
              let o3 = +Date.now();
              s2 = this._cluster(s2, e3), this.trees[e3] = new J(s2, K, Q, r2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - o3);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t2) {
            let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180, i2 = Math.max(-90, Math.min(90, e2[1])), r2 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180, n2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360)
              o2 = -180, r2 = 180;
            else if (o2 > r2) {
              let e3 = this.getClusters([o2, i2, 180, n2], t2), s3 = this.getClusters([-180, i2, r2, n2], t2);
              return e3.concat(s3);
            }
            let s2 = this.trees[this._limitZoom(t2)], a2 = s2.range($(o2), q(n2), $(r2), q(i2)), l2 = [];
            for (let e3 of a2) {
              let t3 = s2.points[e3];
              l2.push(t3.numPoints ? R(t3) : this.points[t3.index]);
            }
            return l2;
          }
          getChildren(e2) {
            let t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", r2 = this.trees[o2];
            if (!r2)
              throw new Error(i2);
            let n2 = r2.points[t2];
            if (!n2)
              throw new Error(i2);
            let s2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = r2.within(n2.x, n2.y, s2), l2 = [];
            for (let t3 of a2) {
              let o3 = r2.points[t3];
              o3.parentId === e2 && l2.push(o3.numPoints ? R(o3) : this.points[o3.index]);
            }
            if (l2.length === 0)
              throw new Error(i2);
            return l2;
          }
          getLeaves(e2, t2, o2) {
            let i2 = [];
            return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
          }
          getTile(e2, t2, o2) {
            let i2 = this.trees[this._limitZoom(e2)], r2 = Math.pow(2, e2), { extent: n2, radius: s2 } = this.options, a2 = s2 / n2, l2 = (o2 - a2) / r2, c2 = (o2 + 1 + a2) / r2, u2 = { features: [] };
            return this._addTileFeatures(i2.range((t2 - a2) / r2, l2, (t2 + 1 + a2) / r2, c2), i2.points, t2, o2, r2, u2), t2 === 0 && this._addTileFeatures(i2.range(1 - a2 / r2, l2, 1, c2), i2.points, r2, o2, r2, u2), t2 === r2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / r2, c2), i2.points, -1, o2, r2, u2), u2.features.length ? u2 : null;
          }
          getClusterExpansionZoom(e2) {
            let t2 = this._getOriginZoom(e2) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              let o2 = this.getChildren(e2);
              if (t2++, o2.length !== 1)
                break;
              e2 = o2[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e2, t2, o2, i2, r2) {
            let n2 = this.getChildren(t2);
            for (let t3 of n2) {
              let n3 = t3.properties;
              if (n3 && n3.cluster ? r2 + n3.point_count <= i2 ? r2 += n3.point_count : r2 = this._appendLeaves(e2, n3.cluster_id, o2, i2, r2) : r2 < i2 ? r2++ : e2.push(t3), e2.length === o2)
                break;
            }
            return r2;
          }
          _addTileFeatures(e2, t2, o2, i2, r2, n2) {
            for (let s2 of e2) {
              let e3 = t2[s2], a2 = e3.numPoints, l2, c2, u2;
              if (a2)
                l2 = W(e3), c2 = e3.x, u2 = e3.y;
              else {
                let t3 = this.points[e3.index];
                l2 = t3.properties, c2 = $(t3.geometry.coordinates[0]), u2 = q(t3.geometry.coordinates[1]);
              }
              let h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * r2 - o2)), Math.round(this.options.extent * (u2 * r2 - i2))]], tags: l2 }, p2;
              a2 ? p2 = e3.id : this.options.generateId ? p2 = e3.index : this.points[e3.index].id && (p2 = this.points[e3.index].id), p2 !== void 0 && (h2.id = p2), n2.features.push(h2);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t2) {
            let o2 = [], { radius: i2, extent: r2, reduce: n2, minPoints: s2 } = this.options, a2 = i2 / (r2 * Math.pow(2, t2));
            for (let i3 = 0; i3 < e2.length; i3++) {
              let r3 = e2[i3];
              if (r3.zoom <= t2)
                continue;
              r3.zoom = t2;
              let l2 = this.trees[t2 + 1], c2 = l2.within(r3.x, r3.y, a2), u2 = r3.numPoints || 1, h2 = u2;
              for (let e3 of c2) {
                let o3 = l2.points[e3];
                o3.zoom > t2 && (h2 += o3.numPoints || 1);
              }
              if (h2 > u2 && h2 >= s2) {
                let e3 = r3.x * u2, s3 = r3.y * u2, a3 = n2 && u2 > 1 ? this._map(r3, !0) : null, p2 = (i3 << 5) + (t2 + 1) + this.points.length;
                for (let o3 of c2) {
                  let i4 = l2.points[o3];
                  if (i4.zoom <= t2)
                    continue;
                  i4.zoom = t2;
                  let c3 = i4.numPoints || 1;
                  e3 += i4.x * c3, s3 += i4.y * c3, i4.parentId = p2, n2 && (a3 || (a3 = this._map(r3, !0)), n2(a3, this._map(i4)));
                }
                r3.parentId = p2, o2.push(V(e3 / h2, s3 / h2, p2, h2, a3));
              } else if (o2.push(r3), h2 > 1)
                for (let e3 of c2) {
                  let i4 = l2.points[e3];
                  i4.zoom <= t2 || (i4.zoom = t2, o2.push(i4));
                }
            }
            return o2;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t2) {
            if (e2.numPoints)
              return t2 ? H({}, e2.properties) : e2.properties;
            let o2 = this.points[e2.index].properties, i2 = this.options.map(o2);
            return t2 && i2 === o2 ? H({}, i2) : i2;
          }
        }
        function V(e2, t2, o2, i2, r2) {
          return { x: G(e2), y: G(t2), zoom: 1 / 0, id: o2, parentId: -1, numPoints: i2, properties: r2 };
        }
        function X(e2, t2) {
          let [o2, i2] = e2.geometry.coordinates;
          return { x: G($(o2)), y: G(q(i2)), zoom: 1 / 0, index: t2, parentId: -1 };
        }
        function R(e2) {
          return { type: "Feature", id: e2.id, properties: W(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), U(e2.y)] } };
          var t2;
        }
        function W(e2) {
          let t2 = e2.numPoints, o2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
          return H(H({}, e2.properties), { cluster: !0, cluster_id: e2.id, point_count: t2, point_count_abbreviated: o2 });
        }
        function $(e2) {
          return e2 / 360 + 0.5;
        }
        function q(e2) {
          let t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function U(e2) {
          let t2 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function H(e2, t2) {
          for (let o2 in t2)
            e2[o2] = t2[o2];
          return e2;
        }
        function K(e2) {
          return e2.x;
        }
        function Q(e2) {
          return e2.y;
        }
        function ee(e2, t2, o2, i2) {
          for (var r2, n2 = i2, s2 = o2 - t2 >> 1, a2 = o2 - t2, l2 = e2[t2], c2 = e2[t2 + 1], u2 = e2[o2], h2 = e2[o2 + 1], p2 = t2 + 3; p2 < o2; p2 += 3) {
            var f2 = te(e2[p2], e2[p2 + 1], l2, c2, u2, h2);
            if (f2 > n2)
              r2 = p2, n2 = f2;
            else if (f2 === n2) {
              var d2 = Math.abs(p2 - s2);
              d2 < a2 && (r2 = p2, a2 = d2);
            }
          }
          n2 > i2 && (r2 - t2 > 3 && ee(e2, t2, r2, i2), e2[r2 + 2] = n2, o2 - r2 > 3 && ee(e2, r2, o2, i2));
        }
        function te(e2, t2, o2, i2, r2, n2) {
          var s2 = r2 - o2, a2 = n2 - i2;
          if (s2 !== 0 || a2 !== 0) {
            var l2 = ((e2 - o2) * s2 + (t2 - i2) * a2) / (s2 * s2 + a2 * a2);
            l2 > 1 ? (o2 = r2, i2 = n2) : l2 > 0 && (o2 += s2 * l2, i2 += a2 * l2);
          }
          return (s2 = e2 - o2) * s2 + (a2 = t2 - i2) * a2;
        }
        function oe(e2, t2, o2, i2) {
          var r2 = { id: e2 === void 0 ? null : e2, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t3 = e3.geometry, o3 = e3.type;
            if (o3 === "Point" || o3 === "MultiPoint" || o3 === "LineString")
              ie(e3, t3);
            else if (o3 === "Polygon" || o3 === "MultiLineString")
              for (var i3 = 0; i3 < t3.length; i3++)
                ie(e3, t3[i3]);
            else if (o3 === "MultiPolygon")
              for (i3 = 0; i3 < t3.length; i3++)
                for (var r3 = 0; r3 < t3[i3].length; r3++)
                  ie(e3, t3[i3][r3]);
          }(r2), r2;
        }
        function ie(e2, t2) {
          for (var o2 = 0; o2 < t2.length; o2 += 3)
            e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
        }
        function re(e2, t2, o2, i2) {
          if (t2.geometry) {
            var r2 = t2.geometry.coordinates, n2 = t2.geometry.type, s2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2), a2 = [], l2 = t2.id;
            if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), n2 === "Point")
              ne(r2, a2);
            else if (n2 === "MultiPoint")
              for (var c2 = 0; c2 < r2.length; c2++)
                ne(r2[c2], a2);
            else if (n2 === "LineString")
              se(r2, a2, s2, !1);
            else if (n2 === "MultiLineString") {
              if (o2.lineMetrics) {
                for (c2 = 0; c2 < r2.length; c2++)
                  se(r2[c2], a2 = [], s2, !1), e2.push(oe(l2, "LineString", a2, t2.properties));
                return;
              }
              ae(r2, a2, s2, !1);
            } else if (n2 === "Polygon")
              ae(r2, a2, s2, !0);
            else {
              if (n2 !== "MultiPolygon") {
                if (n2 === "GeometryCollection") {
                  for (c2 = 0; c2 < t2.geometry.geometries.length; c2++)
                    re(e2, { id: l2, geometry: t2.geometry.geometries[c2], properties: t2.properties }, o2, i2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (c2 = 0; c2 < r2.length; c2++) {
                var u2 = [];
                ae(r2[c2], u2, s2, !0), a2.push(u2);
              }
            }
            e2.push(oe(l2, n2, a2, t2.properties));
          }
        }
        function ne(e2, t2) {
          t2.push(le(e2[0])), t2.push(ce(e2[1])), t2.push(0);
        }
        function se(e2, t2, o2, i2) {
          for (var r2, n2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
            var l2 = le(e2[a2][0]), c2 = ce(e2[a2][1]);
            t2.push(l2), t2.push(c2), t2.push(0), a2 > 0 && (s2 += i2 ? (r2 * c2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - r2, 2) + Math.pow(c2 - n2, 2))), r2 = l2, n2 = c2;
          }
          var u2 = t2.length - 3;
          t2[2] = 1, ee(t2, 0, u2, o2), t2[u2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
        }
        function ae(e2, t2, o2, i2) {
          for (var r2 = 0; r2 < e2.length; r2++) {
            var n2 = [];
            se(e2[r2], n2, o2, i2), t2.push(n2);
          }
        }
        function le(e2) {
          return e2 / 360 + 0.5;
        }
        function ce(e2) {
          var t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function ue(e2, t2, o2, i2, r2, n2, s2, a2) {
          if (i2 /= t2, n2 >= (o2 /= t2) && s2 < i2)
            return e2;
          if (s2 < o2 || n2 >= i2)
            return null;
          for (var l2 = [], c2 = 0; c2 < e2.length; c2++) {
            var u2 = e2[c2], h2 = u2.geometry, p2 = u2.type, f2 = r2 === 0 ? u2.minX : u2.minY, d2 = r2 === 0 ? u2.maxX : u2.maxY;
            if (f2 >= o2 && d2 < i2)
              l2.push(u2);
            else if (!(d2 < o2 || f2 >= i2)) {
              var g2 = [];
              if (p2 === "Point" || p2 === "MultiPoint")
                he(h2, g2, o2, i2, r2);
              else if (p2 === "LineString")
                pe(h2, g2, o2, i2, r2, !1, a2.lineMetrics);
              else if (p2 === "MultiLineString")
                de(h2, g2, o2, i2, r2, !1);
              else if (p2 === "Polygon")
                de(h2, g2, o2, i2, r2, !0);
              else if (p2 === "MultiPolygon")
                for (var m2 = 0; m2 < h2.length; m2++) {
                  var y2 = [];
                  de(h2[m2], y2, o2, i2, r2, !0), y2.length && g2.push(y2);
                }
              if (g2.length) {
                if (a2.lineMetrics && p2 === "LineString") {
                  for (m2 = 0; m2 < g2.length; m2++)
                    l2.push(oe(u2.id, p2, g2[m2], u2.tags));
                  continue;
                }
                p2 !== "LineString" && p2 !== "MultiLineString" || (g2.length === 1 ? (p2 = "LineString", g2 = g2[0]) : p2 = "MultiLineString"), p2 !== "Point" && p2 !== "MultiPoint" || (p2 = g2.length === 3 ? "Point" : "MultiPoint"), l2.push(oe(u2.id, p2, g2, u2.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function he(e2, t2, o2, i2, r2) {
          for (var n2 = 0; n2 < e2.length; n2 += 3) {
            var s2 = e2[n2 + r2];
            s2 >= o2 && s2 <= i2 && (t2.push(e2[n2]), t2.push(e2[n2 + 1]), t2.push(e2[n2 + 2]));
          }
        }
        function pe(e2, t2, o2, i2, r2, n2, s2) {
          for (var a2, l2, c2 = fe(e2), u2 = r2 === 0 ? me : ye, h2 = e2.start, p2 = 0; p2 < e2.length - 3; p2 += 3) {
            var f2 = e2[p2], d2 = e2[p2 + 1], g2 = e2[p2 + 2], m2 = e2[p2 + 3], y2 = e2[p2 + 4], v2 = r2 === 0 ? f2 : d2, x2 = r2 === 0 ? m2 : y2, w2 = !1;
            s2 && (a2 = Math.sqrt(Math.pow(f2 - m2, 2) + Math.pow(d2 - y2, 2))), v2 < o2 ? x2 > o2 && (l2 = u2(c2, f2, d2, m2, y2, o2), s2 && (c2.start = h2 + a2 * l2)) : v2 > i2 ? x2 < i2 && (l2 = u2(c2, f2, d2, m2, y2, i2), s2 && (c2.start = h2 + a2 * l2)) : ge(c2, f2, d2, g2), x2 < o2 && v2 >= o2 && (l2 = u2(c2, f2, d2, m2, y2, o2), w2 = !0), x2 > i2 && v2 <= i2 && (l2 = u2(c2, f2, d2, m2, y2, i2), w2 = !0), !n2 && w2 && (s2 && (c2.end = h2 + a2 * l2), t2.push(c2), c2 = fe(e2)), s2 && (h2 += a2);
          }
          var S2 = e2.length - 3;
          f2 = e2[S2], d2 = e2[S2 + 1], g2 = e2[S2 + 2], (v2 = r2 === 0 ? f2 : d2) >= o2 && v2 <= i2 && ge(c2, f2, d2, g2), S2 = c2.length - 3, n2 && S2 >= 3 && (c2[S2] !== c2[0] || c2[S2 + 1] !== c2[1]) && ge(c2, c2[0], c2[1], c2[2]), c2.length && t2.push(c2);
        }
        function fe(e2) {
          var t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function de(e2, t2, o2, i2, r2, n2) {
          for (var s2 = 0; s2 < e2.length; s2++)
            pe(e2[s2], t2, o2, i2, r2, n2, !1);
        }
        function ge(e2, t2, o2, i2) {
          e2.push(t2), e2.push(o2), e2.push(i2);
        }
        function me(e2, t2, o2, i2, r2, n2) {
          var s2 = (n2 - t2) / (i2 - t2);
          return e2.push(n2), e2.push(o2 + (r2 - o2) * s2), e2.push(1), s2;
        }
        function ye(e2, t2, o2, i2, r2, n2) {
          var s2 = (n2 - o2) / (r2 - o2);
          return e2.push(t2 + (i2 - t2) * s2), e2.push(n2), e2.push(1), s2;
        }
        function ve(e2, t2) {
          for (var o2 = [], i2 = 0; i2 < e2.length; i2++) {
            var r2, n2 = e2[i2], s2 = n2.type;
            if (s2 === "Point" || s2 === "MultiPoint" || s2 === "LineString")
              r2 = xe(n2.geometry, t2);
            else if (s2 === "MultiLineString" || s2 === "Polygon") {
              r2 = [];
              for (var a2 = 0; a2 < n2.geometry.length; a2++)
                r2.push(xe(n2.geometry[a2], t2));
            } else if (s2 === "MultiPolygon")
              for (r2 = [], a2 = 0; a2 < n2.geometry.length; a2++) {
                for (var l2 = [], c2 = 0; c2 < n2.geometry[a2].length; c2++)
                  l2.push(xe(n2.geometry[a2][c2], t2));
                r2.push(l2);
              }
            o2.push(oe(n2.id, s2, r2, n2.tags));
          }
          return o2;
        }
        function xe(e2, t2) {
          var o2 = [];
          o2.size = e2.size, e2.start !== void 0 && (o2.start = e2.start, o2.end = e2.end);
          for (var i2 = 0; i2 < e2.length; i2 += 3)
            o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
          return o2;
        }
        function we(e2, t2) {
          if (e2.transformed)
            return e2;
          var o2, i2, r2, n2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
          for (o2 = 0; o2 < e2.features.length; o2++) {
            var l2 = e2.features[o2], c2 = l2.geometry, u2 = l2.type;
            if (l2.geometry = [], u2 === 1)
              for (i2 = 0; i2 < c2.length; i2 += 2)
                l2.geometry.push(Se(c2[i2], c2[i2 + 1], t2, n2, s2, a2));
            else
              for (i2 = 0; i2 < c2.length; i2++) {
                var h2 = [];
                for (r2 = 0; r2 < c2[i2].length; r2 += 2)
                  h2.push(Se(c2[i2][r2], c2[i2][r2 + 1], t2, n2, s2, a2));
                l2.geometry.push(h2);
              }
          }
          return e2.transformed = !0, e2;
        }
        function Se(e2, t2, o2, i2, r2, n2) {
          return [Math.round(o2 * (e2 * i2 - r2)), Math.round(o2 * (t2 * i2 - n2))];
        }
        function Me(e2, t2, o2, i2, r2) {
          for (var n2 = t2 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t2) * r2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: o2, y: i2, z: t2, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
            s2.numFeatures++, Ie(s2, e2[a2], n2, r2);
            var l2 = e2[a2].minX, c2 = e2[a2].minY, u2 = e2[a2].maxX, h2 = e2[a2].maxY;
            l2 < s2.minX && (s2.minX = l2), c2 < s2.minY && (s2.minY = c2), u2 > s2.maxX && (s2.maxX = u2), h2 > s2.maxY && (s2.maxY = h2);
          }
          return s2;
        }
        function Ie(e2, t2, o2, i2) {
          var r2 = t2.geometry, n2 = t2.type, s2 = [];
          if (n2 === "Point" || n2 === "MultiPoint")
            for (var a2 = 0; a2 < r2.length; a2 += 3)
              s2.push(r2[a2]), s2.push(r2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
          else if (n2 === "LineString")
            be(s2, r2, e2, o2, !1, !1);
          else if (n2 === "MultiLineString" || n2 === "Polygon")
            for (a2 = 0; a2 < r2.length; a2++)
              be(s2, r2[a2], e2, o2, n2 === "Polygon", a2 === 0);
          else if (n2 === "MultiPolygon")
            for (var l2 = 0; l2 < r2.length; l2++) {
              var c2 = r2[l2];
              for (a2 = 0; a2 < c2.length; a2++)
                be(s2, c2[a2], e2, o2, !0, a2 === 0);
            }
          if (s2.length) {
            var u2 = t2.tags || null;
            if (n2 === "LineString" && i2.lineMetrics) {
              for (var h2 in u2 = {}, t2.tags)
                u2[h2] = t2.tags[h2];
              u2.mapbox_clip_start = r2.start / r2.size, u2.mapbox_clip_end = r2.end / r2.size;
            }
            var p2 = { geometry: s2, type: n2 === "Polygon" || n2 === "MultiPolygon" ? 3 : n2 === "LineString" || n2 === "MultiLineString" ? 2 : 1, tags: u2 };
            t2.id !== null && (p2.id = t2.id), e2.features.push(p2);
          }
        }
        function be(e2, t2, o2, i2, r2, n2) {
          var s2 = i2 * i2;
          if (i2 > 0 && t2.size < (r2 ? s2 : i2))
            o2.numPoints += t2.length / 3;
          else {
            for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
              (i2 === 0 || t2[l2 + 2] > s2) && (o2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), o2.numPoints++;
            r2 && function(e3, t3) {
              for (var o3 = 0, i3 = 0, r3 = e3.length, n3 = r3 - 2; i3 < r3; n3 = i3, i3 += 2)
                o3 += (e3[i3] - e3[n3]) * (e3[i3 + 1] + e3[n3 + 1]);
              if (o3 > 0 === t3)
                for (i3 = 0, r3 = e3.length; i3 < r3 / 2; i3 += 2) {
                  var s3 = e3[i3], a3 = e3[i3 + 1];
                  e3[i3] = e3[r3 - 2 - i3], e3[i3 + 1] = e3[r3 - 1 - i3], e3[r3 - 2 - i3] = s3, e3[r3 - 1 - i3] = a3;
                }
            }(a2, n2), e2.push(a2);
          }
        }
        function ke(e2, t2) {
          var o2 = (t2 = this.options = function(e3, t3) {
            for (var o3 in t3)
              e3[o3] = t3[o3];
            return e3;
          }(Object.create(this.options), t2)).debug;
          if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var i2 = function(e3, t3) {
            var o3 = [];
            if (e3.type === "FeatureCollection")
              for (var i3 = 0; i3 < e3.features.length; i3++)
                re(o3, e3.features[i3], t3, i3);
            else
              re(o3, e3.type === "Feature" ? e3 : { geometry: e3 }, t3);
            return o3;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
            var o3 = t3.buffer / t3.extent, i3 = e3, r2 = ue(e3, 1, -1 - o3, o3, 0, -1, 2, t3), n2 = ue(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
            return (r2 || n2) && (i3 = ue(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], r2 && (i3 = ve(r2, 1).concat(i3)), n2 && (i3 = i3.concat(ve(n2, -1)))), i3;
          }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Pe(e2, t2, o2) {
          return 32 * ((1 << e2) * o2 + t2) + e2;
        }
        function Te(e2, t2) {
          let o2 = e2.tileID.canonical;
          if (!this._geoJSONIndex)
            return t2(null, null);
          let i2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
          if (!i2)
            return t2(null, null);
          let r2 = new g(i2.features), n2 = m.exports(r2);
          n2.byteOffset === 0 && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: r2, rawData: n2.buffer });
        }
        ke.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, ke.prototype.splitTile = function(e2, t2, o2, i2, r2, n2, s2) {
          for (var a2 = [e2, t2, o2, i2], l2 = this.options, c2 = l2.debug; a2.length; ) {
            i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
            var u2 = 1 << t2, h2 = Pe(t2, o2, i2), p2 = this.tiles[h2];
            if (!p2 && (c2 > 1 && console.time("creation"), p2 = this.tiles[h2] = Me(e2, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
              c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, p2.numFeatures, p2.numPoints, p2.numSimplified), console.timeEnd("creation"));
              var f2 = "z" + t2;
              this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
            }
            if (p2.source = e2, r2) {
              if (t2 === l2.maxZoom || t2 === r2)
                continue;
              var d2 = 1 << r2 - t2;
              if (o2 !== Math.floor(n2 / d2) || i2 !== Math.floor(s2 / d2))
                continue;
            } else if (t2 === l2.indexMaxZoom || p2.numPoints <= l2.indexMaxPoints)
              continue;
            if (p2.source = null, e2.length !== 0) {
              c2 > 1 && console.time("clipping");
              var g2, m2, y2, v2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, I2 = 0.5 + S2, b2 = 1 + S2;
              g2 = m2 = y2 = v2 = null, x2 = ue(e2, u2, o2 - S2, o2 + I2, 0, p2.minX, p2.maxX, l2), w2 = ue(e2, u2, o2 + M2, o2 + b2, 0, p2.minX, p2.maxX, l2), e2 = null, x2 && (g2 = ue(x2, u2, i2 - S2, i2 + I2, 1, p2.minY, p2.maxY, l2), m2 = ue(x2, u2, i2 + M2, i2 + b2, 1, p2.minY, p2.maxY, l2), x2 = null), w2 && (y2 = ue(w2, u2, i2 - S2, i2 + I2, 1, p2.minY, p2.maxY, l2), v2 = ue(w2, u2, i2 + M2, i2 + b2, 1, p2.minY, p2.maxY, l2), w2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(g2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(m2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(y2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
            }
          }
        }, ke.prototype.getTile = function(e2, t2, o2) {
          var i2 = this.options, r2 = i2.extent, n2 = i2.debug;
          if (e2 < 0 || e2 > 24)
            return null;
          var s2 = 1 << e2, a2 = Pe(e2, t2 = (t2 % s2 + s2) % s2, o2);
          if (this.tiles[a2])
            return we(this.tiles[a2], r2);
          n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
          for (var l2, c2 = e2, u2 = t2, h2 = o2; !l2 && c2 > 0; )
            c2--, u2 = Math.floor(u2 / 2), h2 = Math.floor(h2 / 2), l2 = this.tiles[Pe(c2, u2, h2)];
          return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", c2, u2, h2), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, c2, u2, h2, e2, t2, o2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? we(this.tiles[a2], r2) : null) : null;
        };
        class Ce extends l {
          constructor(e2, t2, o2, i2) {
            super(e2, t2, o2, Te), i2 && (this.loadGeoJSON = i2);
          }
          loadData(t2, o2) {
            var i2;
            (i2 = this._pendingRequest) === null || i2 === void 0 || i2.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: !0 });
            let r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request);
            this._pendingCallback = o2, this._pendingRequest = this.loadGeoJSON(t2, (i3, n2) => {
              if (delete this._pendingCallback, delete this._pendingRequest, i3 || !n2)
                return o2(i3);
              if (typeof n2 != "object")
                return o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              {
                u(n2, !0);
                try {
                  if (t2.filter) {
                    let o3 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                    if (o3.result === "error")
                      throw new Error(o3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                    n2 = { type: "FeatureCollection", features: n2.features.filter((e2) => o3.value.evaluate({ zoom: 0 }, e2)) };
                  }
                  this._geoJSONIndex = t2.cluster ? new Y(function({ superclusterOptions: t3, clusterProperties: o3 }) {
                    if (!o3 || !t3)
                      return t3;
                    let i4 = {}, r3 = {}, n3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a2 = Object.keys(o3);
                    for (let t4 of a2) {
                      let [n4, s4] = o3[t4], a3 = e.createExpression(s4), l2 = e.createExpression(typeof n4 == "string" ? [n4, ["accumulated"], ["get", t4]] : n4);
                      i4[t4] = a3.value, r3[t4] = l2.value;
                    }
                    return t3.map = (e2) => {
                      s3.properties = e2;
                      let t4 = {};
                      for (let e3 of a2)
                        t4[e3] = i4[e3].evaluate(n3, s3);
                      return t4;
                    }, t3.reduce = (e2, t4) => {
                      s3.properties = t4;
                      for (let t5 of a2)
                        n3.accumulated = e2[t5], e2[t5] = r3[t5].evaluate(n3, s3);
                    }, t3;
                  }(t2)).load(n2.features) : function(e2, t3) {
                    return new ke(e2, t3);
                  }(n2, t2.geojsonVtOptions);
                } catch (i4) {
                  return o2(i4);
                }
                this.loaded = {};
                let s2 = {};
                if (r2) {
                  let e2 = r2.finish();
                  e2 && (s2.resourceTiming = {}, s2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
                }
                o2(null, s2);
              }
            });
          }
          reloadTile(e2, t2) {
            let o2 = this.loaded;
            return o2 && o2[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
          }
          loadGeoJSON(t2, o2) {
            if (t2.request)
              return e.getJSON(t2.request, o2);
            if (typeof t2.data == "string")
              try {
                o2(null, JSON.parse(t2.data));
              } catch {
                o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              }
            else
              o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            return { cancel: () => {
            } };
          }
          removeSource(e2, t2) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), t2();
          }
          getClusterExpansionZoom(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterChildren(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterLeaves(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
            } catch (e3) {
              t2(e3);
            }
          }
        }
        class _e {
          constructor(t2) {
            this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: Ce }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
              if (this.workerSourceTypes[e2])
                throw new Error(`Worker source with name "${e2}" already registered.`);
              this.workerSourceTypes[e2] = t3;
            }, this.self.registerRTLTextPlugin = (t3) => {
              if (e.plugin.isParsed())
                throw new Error("RTL text plugin already registered.");
              e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
            };
          }
          setReferrer(e2, t2) {
            this.referrer = t2;
          }
          setImages(e2, t2, o2) {
            this.availableImages[e2] = t2;
            for (let o3 in this.workerSources[e2]) {
              let i2 = this.workerSources[e2][o3];
              for (let e3 in i2)
                i2[e3].availableImages = t2;
            }
            o2();
          }
          setLayers(e2, t2, o2) {
            this.getLayerIndex(e2).replace(t2), o2();
          }
          updateLayers(e2, t2, o2) {
            this.getLayerIndex(e2).update(t2.layers, t2.removedIds), o2();
          }
          loadTile(e2, t2, o2) {
            this.getWorkerSource(e2, t2.type, t2.source).loadTile(t2, o2);
          }
          loadDEMTile(e2, t2, o2) {
            this.getDEMWorkerSource(e2, t2.source).loadTile(t2, o2);
          }
          reloadTile(e2, t2, o2) {
            this.getWorkerSource(e2, t2.type, t2.source).reloadTile(t2, o2);
          }
          abortTile(e2, t2, o2) {
            this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, o2);
          }
          removeTile(e2, t2, o2) {
            this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, o2);
          }
          removeDEMTile(e2, t2) {
            this.getDEMWorkerSource(e2, t2.source).removeTile(t2);
          }
          removeSource(e2, t2, o2) {
            if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source])
              return;
            let i2 = this.workerSources[e2][t2.type][t2.source];
            delete this.workerSources[e2][t2.type][t2.source], i2.removeSource !== void 0 ? i2.removeSource(t2, o2) : o2();
          }
          loadWorkerSource(e2, t2, o2) {
            try {
              this.self.importScripts(t2.url), o2();
            } catch (e3) {
              o2(e3.toString());
            }
          }
          syncRTLPluginState(t2, o2, i2) {
            try {
              e.plugin.setState(o2);
              let t3 = e.plugin.getPluginURL();
              if (e.plugin.isLoaded() && !e.plugin.isParsed() && t3 != null) {
                this.self.importScripts(t3);
                let o3 = e.plugin.isParsed();
                i2(o3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), o3);
              }
            } catch (e2) {
              i2(e2.toString());
            }
          }
          getAvailableImages(e2) {
            let t2 = this.availableImages[e2];
            return t2 || (t2 = []), t2;
          }
          getLayerIndex(e2) {
            let t2 = this.layerIndexes[e2];
            return t2 || (t2 = this.layerIndexes[e2] = new i()), t2;
          }
          getWorkerSource(e2, t2, o2) {
            if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
              let i2 = { send: (t3, o3, i3) => {
                this.actor.send(t3, o3, i3, e2);
              } };
              this.workerSources[e2][t2][o2] = new this.workerSourceTypes[t2](i2, this.getLayerIndex(e2), this.getAvailableImages(e2));
            }
            return this.workerSources[e2][t2][o2];
          }
          getDEMWorkerSource(e2, t2) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new c()), this.demWorkerSources[e2][t2];
          }
          enforceCacheSizeLimit(t2, o2) {
            e.enforceCacheSizeLimit(o2);
          }
        }
        return e.isWorker() && (self.worker = new _e(self)), _e;
      }), define2(["./shared"], function(t) {
        "use strict";
        var e = i;
        function i(t2) {
          return !function(t3) {
            return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return !1;
              var t4, e3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
              try {
                e3 = new Worker(o2), t4 = !0;
              } catch {
                t4 = !1;
              }
              return e3 && e3.terminate(), URL.revokeObjectURL(o2), t4;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var t4 = document.createElement("canvas");
              t4.width = t4.height = 1;
              var e3 = t4.getContext("2d");
              if (!e3)
                return !1;
              var i2 = e3.getImageData(0, 0, 1, 1);
              return i2 && i2.width === t4.width;
            }() ? (o[e2 = t3 && t3.failIfMajorPerformanceCaveat] === void 0 && (o[e2] = function(t4) {
              var e3, o2 = function(t5) {
                var e4 = document.createElement("canvas"), o3 = Object.create(i.webGLContextAttributes);
                return o3.failIfMajorPerformanceCaveat = t5, e4.getContext("webgl", o3) || e4.getContext("experimental-webgl", o3);
              }(t4);
              if (!o2)
                return !1;
              try {
                e3 = o2.createShader(o2.VERTEX_SHADER);
              } catch {
                return !1;
              }
              return !(!e3 || o2.isContextLost()) && (o2.shaderSource(e3, "void main() {}"), o2.compileShader(e3), o2.getShaderParameter(e3, o2.COMPILE_STATUS) === !0);
            }(e2)), o[e2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var e2;
          }(t2);
        }
        var o = {};
        function a(t2, e2) {
          if (Array.isArray(t2)) {
            if (!Array.isArray(e2) || t2.length !== e2.length)
              return !1;
            for (let i2 = 0; i2 < t2.length; i2++)
              if (!a(t2[i2], e2[i2]))
                return !1;
            return !0;
          }
          if (typeof t2 == "object" && t2 !== null && e2 !== null) {
            if (typeof e2 != "object" || Object.keys(t2).length !== Object.keys(e2).length)
              return !1;
            for (let i2 in t2)
              if (!a(t2[i2], e2[i2]))
                return !1;
            return !0;
          }
          return t2 === e2;
        }
        i.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
        class r {
          static testProp(t2) {
            if (!r.docStyle)
              return t2[0];
            for (let e2 = 0; e2 < t2.length; e2++)
              if (t2[e2] in r.docStyle)
                return t2[e2];
            return t2[0];
          }
          static create(t2, e2, i2) {
            let o2 = window.document.createElement(t2);
            return e2 !== void 0 && (o2.className = e2), i2 && i2.appendChild(o2), o2;
          }
          static createNS(t2, e2) {
            return window.document.createElementNS(t2, e2);
          }
          static disableDrag() {
            r.docStyle && r.selectProp && (r.userSelect = r.docStyle[r.selectProp], r.docStyle[r.selectProp] = "none");
          }
          static enableDrag() {
            r.docStyle && r.selectProp && (r.docStyle[r.selectProp] = r.userSelect);
          }
          static setTransform(t2, e2) {
            t2.style[r.transformProp] = e2;
          }
          static addEventListener(t2, e2, i2, o2 = {}) {
            t2.addEventListener(e2, i2, "passive" in o2 ? o2 : o2.capture);
          }
          static removeEventListener(t2, e2, i2, o2 = {}) {
            t2.removeEventListener(e2, i2, "passive" in o2 ? o2 : o2.capture);
          }
          static suppressClickInternal(t2) {
            t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", r.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", r.suppressClickInternal, !0), window.setTimeout(() => {
              window.removeEventListener("click", r.suppressClickInternal, !0);
            }, 0);
          }
          static mousePos(e2, i2) {
            let o2 = e2.getBoundingClientRect();
            return new t.pointGeometry(i2.clientX - o2.left - e2.clientLeft, i2.clientY - o2.top - e2.clientTop);
          }
          static touchPos(e2, i2) {
            let o2 = e2.getBoundingClientRect(), a2 = [];
            for (let r2 = 0; r2 < i2.length; r2++)
              a2.push(new t.pointGeometry(i2[r2].clientX - o2.left - e2.clientLeft, i2[r2].clientY - o2.top - e2.clientTop));
            return a2;
          }
          static mouseButton(t2) {
            return t2.button;
          }
          static remove(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          }
        }
        r.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, r.selectProp = r.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), r.transformProp = r.testProp(["transform", "WebkitTransform"]);
        class s {
          constructor(t2) {
            this._transformRequestFn = t2;
          }
          transformRequest(t2, e2) {
            return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
          }
          normalizeSpriteURL(t2, e2, i2) {
            let o2 = function(t3) {
              let e3 = t3.match(n);
              if (!e3)
                throw new Error(`Unable to parse URL "${t3}"`);
              return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
            }(t2);
            return o2.path += `${e2}${i2}`, function(t3) {
              let e3 = t3.params.length ? `?${t3.params.join("&")}` : "";
              return `${t3.protocol}://${t3.authority}${t3.path}${e3}`;
            }(o2);
          }
          setTransformRequest(t2) {
            this._transformRequestFn = t2;
          }
        }
        let n = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        class l {
          constructor(t2, e2, i2, o2) {
            this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e2, o2);
          }
          update(e2, i2, o2) {
            let { width: a2, height: r2 } = e2, s2 = !(this.size && this.size[0] === a2 && this.size[1] === r2 || o2), { context: n2 } = this, { gl: l2 } = n2;
            if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(!1), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || i2.premultiply !== !1)), s2)
              this.size = [a2, r2], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.isImageBitmap(e2) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, e2) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, a2, r2, 0, this.format, l2.UNSIGNED_BYTE, e2.data);
            else {
              let { x: i3, y: s3 } = o2 || { x: 0, y: 0 };
              e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.isImageBitmap(e2) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, s3, l2.RGBA, l2.UNSIGNED_BYTE, e2) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, s3, a2, r2, l2.RGBA, l2.UNSIGNED_BYTE, e2.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
          }
          bind(t2, e2, i2) {
            let { context: o2 } = this, { gl: a2 } = o2;
            a2.bindTexture(a2.TEXTURE_2D, this.texture), i2 !== a2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = a2.LINEAR), t2 !== this.filter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, t2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e2 !== this.wrap && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, e2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            let { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        function c(t2) {
          let { userImage: e2 } = t2;
          return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), !0);
        }
        class h extends t.Evented {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t2) {
            if (this.loaded !== t2 && (this.loaded = t2, t2)) {
              for (let { ids: t3, callback: e2 } of this.requestors)
                this._notify(t3, e2);
              this.requestors = [];
            }
          }
          getImage(t2) {
            return this.images[t2];
          }
          addImage(t2, e2) {
            if (this.images[t2])
              throw new Error(`Image id ${t2} already exist, use updateImage instead`);
            this._validate(t2, e2) && (this.images[t2] = e2);
          }
          _validate(e2, i2) {
            let o2 = !0;
            return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "stretchX" value`))), o2 = !1), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "stretchY" value`))), o2 = !1), this._validateContent(i2.content, i2) || (this.fire(new t.ErrorEvent(new Error(`Image "${e2}" has invalid "content" value`))), o2 = !1), o2;
          }
          _validateStretch(t2, e2) {
            if (!t2)
              return !0;
            let i2 = 0;
            for (let o2 of t2) {
              if (o2[0] < i2 || o2[1] < o2[0] || e2 < o2[1])
                return !1;
              i2 = o2[1];
            }
            return !0;
          }
          _validateContent(t2, e2) {
            return !(t2 && (t2.length !== 4 || t2[0] < 0 || e2.data.width < t2[0] || t2[1] < 0 || e2.data.height < t2[1] || t2[2] < 0 || e2.data.width < t2[2] || t2[3] < 0 || e2.data.height < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]));
          }
          updateImage(t2, e2) {
            let i2 = this.images[t2];
            if (i2.data.width !== e2.data.width || i2.data.height !== e2.data.height)
              throw new Error(`size mismatch between old image (${i2.data.width}x${i2.data.height}) and new image (${e2.data.width}x${e2.data.height}).`);
            e2.version = i2.version + 1, this.images[t2] = e2, this.updatedImages[t2] = !0;
          }
          removeImage(t2) {
            let e2 = this.images[t2];
            delete this.images[t2], delete this.patterns[t2], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t2, e2) {
            let i2 = !0;
            if (!this.isLoaded())
              for (let e3 of t2)
                this.images[e3] || (i2 = !1);
            this.isLoaded() || i2 ? this._notify(t2, e2) : this.requestors.push({ ids: t2, callback: e2 });
          }
          _notify(e2, i2) {
            let o2 = {};
            for (let i3 of e2) {
              this.images[i3] || this.fire(new t.Event("styleimagemissing", { id: i3 }));
              let e3 = this.images[i3];
              e3 ? o2[i3] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i2(null, o2);
          }
          getPixelSize() {
            let { width: t2, height: e2 } = this.atlasImage;
            return { width: t2, height: e2 };
          }
          getPattern(e2) {
            let i2 = this.patterns[e2], o2 = this.getImage(e2);
            if (!o2)
              return null;
            if (i2 && i2.position.version === o2.version)
              return i2.position;
            if (i2)
              i2.position.version = o2.version;
            else {
              let i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(i3, o2);
              this.patterns[e2] = { bin: i3, position: a2 };
            }
            return this._updatePatternAtlas(), this.patterns[e2].position;
          }
          bind(t2) {
            let e2 = t2.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new l(t2, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            let e2 = [];
            for (let t2 in this.patterns)
              e2.push(this.patterns[t2].bin);
            let { w: i2, h: o2 } = t.potpack(e2), a2 = this.atlasImage;
            a2.resize({ width: i2 || 1, height: o2 || 1 });
            for (let e3 in this.patterns) {
              let { bin: i3 } = this.patterns[e3], o3 = i3.x + 1, r2 = i3.y + 1, s2 = this.images[e3].data, n2 = s2.width, l2 = s2.height;
              t.RGBAImage.copy(s2, a2, { x: 0, y: 0 }, { x: o3, y: r2 }, { width: n2, height: l2 }), t.RGBAImage.copy(s2, a2, { x: 0, y: l2 - 1 }, { x: o3, y: r2 - 1 }, { width: n2, height: 1 }), t.RGBAImage.copy(s2, a2, { x: 0, y: 0 }, { x: o3, y: r2 + l2 }, { width: n2, height: 1 }), t.RGBAImage.copy(s2, a2, { x: n2 - 1, y: 0 }, { x: o3 - 1, y: r2 }, { width: 1, height: l2 }), t.RGBAImage.copy(s2, a2, { x: 0, y: 0 }, { x: o3 + n2, y: r2 }, { width: 1, height: l2 });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e2) {
            for (let i2 of e2) {
              if (this.callbackDispatchedThisFrame[i2])
                continue;
              this.callbackDispatchedThisFrame[i2] = !0;
              let e3 = this.images[i2];
              e3 || t.warnOnce(`Image with ID: "${i2}" was not found`), c(e3) && this.updateImage(i2, e3);
            }
          }
        }
        let u = 1e20;
        function d(t2, e2, i2, o2, a2, r2, s2, n2, l2) {
          for (let c2 = e2; c2 < e2 + o2; c2++)
            m(t2, i2 * r2 + c2, r2, a2, s2, n2, l2);
          for (let c2 = i2; c2 < i2 + a2; c2++)
            m(t2, c2 * r2 + e2, 1, o2, s2, n2, l2);
        }
        function m(t2, e2, i2, o2, a2, r2, s2) {
          r2[0] = 0, s2[0] = -u, s2[1] = u, a2[0] = t2[e2];
          for (let n2 = 1, l2 = 0, c2 = 0; n2 < o2; n2++) {
            a2[n2] = t2[e2 + n2 * i2];
            let o3 = n2 * n2;
            do {
              let t3 = r2[l2];
              c2 = (a2[n2] - a2[t3] + o3 - t3 * t3) / (n2 - t3) / 2;
            } while (c2 <= s2[l2] && --l2 > -1);
            l2++, r2[l2] = n2, s2[l2] = c2, s2[l2 + 1] = u;
          }
          for (let n2 = 0, l2 = 0; n2 < o2; n2++) {
            for (; s2[l2 + 1] < n2; )
              l2++;
            let o3 = r2[l2], c2 = n2 - o3;
            t2[e2 + n2 * i2] = a2[o3] + c2 * c2;
          }
        }
        class _ {
          constructor(t2, e2) {
            this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
          }
          setURL(t2) {
            this.url = t2;
          }
          getGlyphs(e2, i2) {
            let o2 = [];
            for (let t2 in e2)
              for (let i3 of e2[t2])
                o2.push({ stack: t2, id: i3 });
            t.asyncAll(o2, ({ stack: t2, id: e3 }, i3) => {
              let o3 = this.entries[t2];
              o3 || (o3 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
              let a2 = o3.glyphs[e3];
              if (a2 !== void 0)
                return void i3(null, { stack: t2, id: e3, glyph: a2 });
              if (a2 = this._tinySDF(o3, t2, e3), a2)
                return o3.glyphs[e3] = a2, void i3(null, { stack: t2, id: e3, glyph: a2 });
              let r2 = Math.floor(e3 / 256);
              if (256 * r2 > 65535)
                return void i3(new Error("glyphs > 65535 not supported"));
              if (o3.ranges[r2])
                return void i3(null, { stack: t2, id: e3, glyph: a2 });
              let s2 = o3.requests[r2];
              s2 || (s2 = o3.requests[r2] = [], _.loadGlyphRange(t2, r2, this.url, this.requestManager, (t3, e4) => {
                if (e4) {
                  for (let t4 in e4)
                    this._doesCharSupportLocalGlyph(+t4) || (o3.glyphs[+t4] = e4[+t4]);
                  o3.ranges[r2] = !0;
                }
                for (let i4 of s2)
                  i4(t3, e4);
                delete o3.requests[r2];
              })), s2.push((o4, a3) => {
                o4 ? i3(o4) : a3 && i3(null, { stack: t2, id: e3, glyph: a3[e3] || null });
              });
            }, (t2, e3) => {
              if (t2)
                i2(t2);
              else if (e3) {
                let t3 = {};
                for (let { stack: i3, id: o3, glyph: a2 } of e3)
                  (t3[i3] || (t3[i3] = {}))[o3] = a2 && { id: a2.id, bitmap: a2.bitmap.clone(), metrics: a2.metrics };
                i2(null, t3);
              }
            });
          }
          _doesCharSupportLocalGlyph(e2) {
            return !!this.localIdeographFontFamily && (t.unicodeBlockLookup["CJK Unified Ideographs"](e2) || t.unicodeBlockLookup["Hangul Syllables"](e2) || t.unicodeBlockLookup.Hiragana(e2) || t.unicodeBlockLookup.Katakana(e2));
          }
          _tinySDF(e2, i2, o2) {
            let a2 = this.localIdeographFontFamily;
            if (!a2 || !this._doesCharSupportLocalGlyph(o2))
              return;
            let r2 = e2.tinySDF;
            if (!r2) {
              let t2 = "400";
              /bold/i.test(i2) ? t2 = "900" : /medium/i.test(i2) ? t2 = "500" : /light/i.test(i2) && (t2 = "200"), r2 = e2.tinySDF = new _.TinySDF({ fontSize: 24, buffer: 3, radius: 8, cutoff: 0.25, fontFamily: a2, fontWeight: t2 });
            }
            let s2 = r2.draw(String.fromCharCode(o2));
            return { id: o2, bitmap: new t.AlphaImage({ width: s2.width || 30, height: s2.height || 30 }, s2.data), metrics: { width: s2.glyphWidth || 24, height: s2.glyphHeight || 24, left: s2.glyphLeft || 0, top: s2.glyphTop - 27 || -8, advance: s2.glyphAdvance || 24 } };
          }
        }
        _.loadGlyphRange = function(e2, i2, o2, a2, r2) {
          let s2 = 256 * i2, n2 = s2 + 255, l2 = a2.transformRequest(o2.replace("{fontstack}", e2).replace("{range}", `${s2}-${n2}`), t.ResourceType.Glyphs);
          t.getArrayBuffer(l2, (e3, i3) => {
            if (e3)
              r2(e3);
            else if (i3) {
              let e4 = {};
              for (let o3 of t.parseGlyphPbf(i3))
                e4[o3.id] = o3;
              r2(null, e4);
            }
          });
        }, _.TinySDF = class {
          constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: i2 = 8, cutoff: o2 = 0.25, fontFamily: a2 = "sans-serif", fontWeight: r2 = "normal", fontStyle: s2 = "normal" } = {}) {
            this.buffer = e2, this.cutoff = o2, this.radius = i2;
            let n2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(n2), c2 = this.ctx = l2.getContext("2d", { willReadFrequently: !0 });
            c2.font = `${s2} ${r2} ${t2}px ${a2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
          }
          _createCanvas(t2) {
            let e2 = document.createElement("canvas");
            return e2.width = e2.height = t2, e2;
          }
          draw(t2) {
            let { width: e2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: o2, actualBoundingBoxLeft: a2, actualBoundingBoxRight: r2 } = this.ctx.measureText(t2), s2 = Math.ceil(i2), n2 = Math.min(this.size - this.buffer, Math.ceil(r2 - a2)), l2 = Math.min(this.size - this.buffer, s2 + Math.ceil(o2)), c2 = n2 + 2 * this.buffer, h2 = l2 + 2 * this.buffer, m2 = Math.max(c2 * h2, 0), _2 = new Uint8ClampedArray(m2), p2 = { data: _2, width: c2, height: h2, glyphWidth: n2, glyphHeight: l2, glyphTop: s2, glyphLeft: 0, glyphAdvance: e2 };
            if (n2 === 0 || l2 === 0)
              return p2;
            let { ctx: f2, buffer: g2, gridInner: x2, gridOuter: v2 } = this;
            f2.clearRect(g2, g2, n2, l2), f2.fillText(t2, g2, g2 + s2);
            let y2 = f2.getImageData(g2, g2, n2, l2);
            v2.fill(u, 0, m2), x2.fill(0, 0, m2);
            for (let t3 = 0; t3 < l2; t3++)
              for (let e3 = 0; e3 < n2; e3++) {
                let i3 = y2.data[4 * (t3 * n2 + e3) + 3] / 255;
                if (i3 === 0)
                  continue;
                let o3 = (t3 + g2) * c2 + e3 + g2;
                if (i3 === 1)
                  v2[o3] = 0, x2[o3] = u;
                else {
                  let t4 = 0.5 - i3;
                  v2[o3] = t4 > 0 ? t4 * t4 : 0, x2[o3] = t4 < 0 ? t4 * t4 : 0;
                }
              }
            d(v2, 0, 0, c2, h2, c2, this.f, this.v, this.z), d(x2, g2, g2, n2, l2, c2, this.f, this.v, this.z);
            for (let t3 = 0; t3 < m2; t3++) {
              let e3 = Math.sqrt(v2[t3]) - Math.sqrt(x2[t3]);
              _2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return p2;
          }
        };
        let p = new t.Properties({ anchor: new t.DataConstantProperty(t.spec.light.anchor), position: new class {
          constructor() {
            this.specification = t.spec.light.position;
          }
          possiblyEvaluate(e2, i2) {
            return t.sphericalToCartesian(e2.expression.evaluate(i2));
          }
          interpolate(e2, i2, o2) {
            return { x: t.number(e2.x, i2.x, o2), y: t.number(e2.y, i2.y, o2), z: t.number(e2.z, i2.z, o2) };
          }
        }(), color: new t.DataConstantProperty(t.spec.light.color), intensity: new t.DataConstantProperty(t.spec.light.intensity) }), f = "-transition";
        class g extends t.Evented {
          constructor(e2) {
            super(), this._transitionable = new t.Transitionable(p), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e2, i2 = {}) {
            if (!this._validate(t.validateLight, e2, i2))
              for (let t2 in e2) {
                let i3 = e2[t2];
                t2.endsWith(f) ? this._transitionable.setTransition(t2.slice(0, -f.length), i3) : this._transitionable.setValue(t2, i3);
              }
          }
          updateTransitions(t2) {
            this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t2) {
            this.properties = this._transitioning.possiblyEvaluate(t2);
          }
          _validate(e2, i2, o2) {
            return (!o2 || o2.validate !== !1) && t.emitValidationErrors(this, e2.call(t.validateStyle, t.extend({ value: i2, style: { glyphs: !0, sprite: !0 }, styleSpec: t.spec })));
          }
        }
        class x {
          constructor(t2, e2) {
            this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t2, e2) {
            let i2 = t2.join(",") + String(e2);
            return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
          }
          getDashRanges(t2, e2, i2) {
            let o2 = [], a2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, r2 = t2[0] * i2, s2 = !0;
            o2.push({ left: a2, right: r2, isDash: s2, zeroLength: t2[0] === 0 });
            let n2 = t2[0];
            for (let e3 = 1; e3 < t2.length; e3++) {
              s2 = !s2;
              let l2 = t2[e3];
              a2 = n2 * i2, n2 += l2, r2 = n2 * i2, o2.push({ left: a2, right: r2, isDash: s2, zeroLength: l2 === 0 });
            }
            return o2;
          }
          addRoundDash(t2, e2, i2) {
            let o2 = e2 / 2;
            for (let e3 = -i2; e3 <= i2; e3++) {
              let a2 = this.width * (this.nextRow + i2 + e3), r2 = 0, s2 = t2[r2];
              for (let n2 = 0; n2 < this.width; n2++) {
                n2 / s2.right > 1 && (s2 = t2[++r2]);
                let l2 = Math.abs(n2 - s2.left), c2 = Math.abs(n2 - s2.right), h2 = Math.min(l2, c2), u2, d2 = e3 / i2 * (o2 + 1);
                if (s2.isDash) {
                  let t3 = o2 - Math.abs(d2);
                  u2 = Math.sqrt(h2 * h2 + t3 * t3);
                } else
                  u2 = o2 - Math.sqrt(h2 * h2 + d2 * d2);
                this.data[a2 + n2] = Math.max(0, Math.min(255, u2 + 128));
              }
            }
          }
          addRegularDash(t2) {
            for (let e3 = t2.length - 1; e3 >= 0; --e3) {
              let i3 = t2[e3], o3 = t2[e3 + 1];
              i3.zeroLength ? t2.splice(e3, 1) : o3 && o3.isDash === i3.isDash && (o3.left = i3.left, t2.splice(e3, 1));
            }
            let e2 = t2[0], i2 = t2[t2.length - 1];
            e2.isDash === i2.isDash && (e2.left = i2.left - this.width, i2.right = e2.right + this.width);
            let o2 = this.width * this.nextRow, a2 = 0, r2 = t2[a2];
            for (let e3 = 0; e3 < this.width; e3++) {
              e3 / r2.right > 1 && (r2 = t2[++a2]);
              let i3 = Math.abs(e3 - r2.left), s2 = Math.abs(e3 - r2.right), n2 = Math.min(i3, s2);
              this.data[o2 + e3] = Math.max(0, Math.min(255, (r2.isDash ? n2 : -n2) + 128));
            }
          }
          addDash(e2, i2) {
            let o2 = i2 ? 7 : 0, a2 = 2 * o2 + 1;
            if (this.nextRow + a2 > this.height)
              return t.warnOnce("LineAtlas out of space"), null;
            let r2 = 0;
            for (let t2 = 0; t2 < e2.length; t2++)
              r2 += e2[t2];
            if (r2 !== 0) {
              let t2 = this.width / r2, a3 = this.getDashRanges(e2, this.width, t2);
              i2 ? this.addRoundDash(a3, t2, o2) : this.addRegularDash(a3);
            }
            let s2 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: r2 };
            return this.nextRow += a2, this.dirty = !0, s2;
          }
          bind(t2) {
            let e2 = t2.gl;
            this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
          }
        }
        class v {
          constructor(e2, i2) {
            this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
            let o2 = this.workerPool.acquire(this.id);
            for (let t2 = 0; t2 < o2.length; t2++) {
              let e3 = new v.Actor(o2[t2], i2, this.id);
              e3.name = `Worker ${t2}`, this.actors.push(e3);
            }
            if (!this.actors.length)
              throw new Error("No actors found");
          }
          broadcast(e2, i2, o2) {
            t.asyncAll(this.actors, (t2, o3) => {
              t2.send(e2, i2, o3);
            }, o2 = o2 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((t2) => {
              t2.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        function y(e2, i2, o2) {
          let a2 = function(i3, a3) {
            if (i3)
              return o2(i3);
            if (a3) {
              let i4 = t.pick(t.extend(a3, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
              a3.vector_layers && (i4.vectorLayers = a3.vector_layers, i4.vectorLayerIds = i4.vectorLayers.map((t2) => t2.id)), o2(null, i4);
            }
          };
          return e2.url ? t.getJSON(i2.transformRequest(e2.url, t.ResourceType.Source), a2) : t.exported.frame(() => a2(null, e2));
        }
        v.Actor = t.Actor;
        class b {
          constructor(e2, i2, o2) {
            this.bounds = t.LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
          }
          validateBounds(t2) {
            return Array.isArray(t2) && t2.length === 4 ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
          }
          contains(e2) {
            let i2 = Math.pow(2, e2.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), a2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), r2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), s2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
            return e2.x >= o2 && e2.x < r2 && e2.y >= a2 && e2.y < s2;
          }
        }
        class w extends t.Evented {
          constructor(e2, i2, o2, a2) {
            if (super(), this.id = e2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.extend(this, t.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a2);
          }
          load() {
            this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = y(this._options, this.map._requestManager, (e2, i2) => {
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e2 ? this.fire(new t.ErrorEvent(e2)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new b(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setSourceProperty(t2) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), t2(), this.load();
          }
          setTiles(t2) {
            return this.setSourceProperty(() => {
              this._options.tiles = t2;
            }), this;
          }
          setUrl(t2) {
            return this.setSourceProperty(() => {
              this.url = t2, this._options.url = t2;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          serialize() {
            return t.extend({}, this._options);
          }
          loadTile(e2, i2) {
            let o2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            function r2(o3, a3) {
              return delete e2.request, e2.aborted ? i2(null) : o3 && o3.status !== 404 ? i2(o3) : (a3 && a3.resourceTiming && (e2.resourceTiming = a3.resourceTiming), this.map._refreshExpiredTiles && a3 && e2.setExpiryData(a3), e2.loadVectorData(a3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (e2.reloadCallback && (this.loadTile(e2, e2.reloadCallback), e2.reloadCallback = null)));
            }
            a2.request.collectResourceTiming = this._collectResourceTiming, e2.actor && e2.state !== "expired" ? e2.state === "loading" ? e2.reloadCallback = i2 : e2.request = e2.actor.send("reloadTile", a2, r2.bind(this)) : (e2.actor = this.dispatcher.getActor(), e2.request = e2.actor.send("loadTile", a2, r2.bind(this)));
          }
          abortTile(t2) {
            t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
          }
          unloadTile(t2) {
            t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
          }
          hasTransition() {
            return !1;
          }
        }
        class T extends t.Evented {
          constructor(e2, i2, o2, a2) {
            super(), this.id = e2, this.dispatcher = o2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.extend({ type: "raster" }, i2), t.extend(this, t.pick(i2, ["url", "scheme", "tileSize"]));
          }
          load() {
            this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = y(this._options, this.map._requestManager, (e2, i2) => {
              this._tileJSONRequest = null, this._loaded = !0, e2 ? this.fire(new t.ErrorEvent(e2)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new b(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          serialize() {
            return t.extend({}, this._options);
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          loadTile(e2, i2) {
            let o2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            e2.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), (o3, a2, r2) => {
              if (delete e2.request, e2.aborted)
                e2.state = "unloaded", i2(null);
              else if (o3)
                e2.state = "errored", i2(o3);
              else if (a2) {
                this.map._refreshExpiredTiles && e2.setExpiryData(r2);
                let o4 = this.map.painter.context, s2 = o4.gl;
                e2.texture = this.map.painter.getTileTexture(a2.width), e2.texture ? e2.texture.update(a2, { useMipmap: !0 }) : (e2.texture = new l(o4, a2, s2.RGBA, { useMipmap: !0 }), e2.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), o4.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, o4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o4.extTextureFilterAnisotropicMax)), e2.state = "loaded", t.cacheEntryPossiblyAdded(this.dispatcher), i2(null);
              }
            });
          }
          abortTile(t2, e2) {
            t2.request && (t2.request.cancel(), delete t2.request), e2();
          }
          unloadTile(t2, e2) {
            t2.texture && this.map.painter.saveTileTexture(t2.texture), e2();
          }
          hasTransition() {
            return !1;
          }
        }
        let E;
        class I extends T {
          constructor(e2, i2, o2, a2) {
            super(e2, i2, o2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
          }
          serialize() {
            return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
          }
          loadTile(e2, i2) {
            let o2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            function a2(t2, o3) {
              t2 && (e2.state = "errored", i2(t2)), o3 && (e2.dem = o3, e2.needsHillshadePrepare = !0, e2.needsTerrainPrepare = !0, e2.state = "loaded", i2(null));
            }
            e2.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), function(o3, r2) {
              if (delete e2.request, e2.aborted)
                e2.state = "unloaded", i2(null);
              else if (o3)
                e2.state = "errored", i2(o3);
              else if (r2) {
                this.map._refreshExpiredTiles && e2.setExpiryData(r2), delete r2.cacheControl, delete r2.expires;
                let i3 = t.isImageBitmap(r2) && (E == null && (E = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), E) ? r2 : t.exported.getImageData(r2, 1), o4 = { uid: e2.uid, coord: e2.tileID, source: this.id, rawImageData: i3, encoding: this.encoding };
                e2.actor && e2.state !== "expired" || (e2.actor = this.dispatcher.getActor(), e2.actor.send("loadDEMTile", o4, a2.bind(this)));
              }
            }.bind(this)), e2.neighboringTiles = this._getNeighboringTiles(e2.tileID);
          }
          _getNeighboringTiles(e2) {
            let i2 = e2.canonical, o2 = Math.pow(2, i2.z), a2 = (i2.x - 1 + o2) % o2, r2 = i2.x === 0 ? e2.wrap - 1 : e2.wrap, s2 = (i2.x + 1 + o2) % o2, n2 = i2.x + 1 === o2 ? e2.wrap + 1 : e2.wrap, l2 = {};
            return l2[new t.OverscaledTileID(e2.overscaledZ, r2, i2.z, a2, i2.y).key] = { backfilled: !1 }, l2[new t.OverscaledTileID(e2.overscaledZ, n2, i2.z, s2, i2.y).key] = { backfilled: !1 }, i2.y > 0 && (l2[new t.OverscaledTileID(e2.overscaledZ, r2, i2.z, a2, i2.y - 1).key] = { backfilled: !1 }, l2[new t.OverscaledTileID(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: !1 }, l2[new t.OverscaledTileID(e2.overscaledZ, n2, i2.z, s2, i2.y - 1).key] = { backfilled: !1 }), i2.y + 1 < o2 && (l2[new t.OverscaledTileID(e2.overscaledZ, r2, i2.z, a2, i2.y + 1).key] = { backfilled: !1 }, l2[new t.OverscaledTileID(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: !1 }, l2[new t.OverscaledTileID(e2.overscaledZ, n2, i2.z, s2, i2.y + 1).key] = { backfilled: !1 }), l2;
          }
          unloadTile(t2) {
            t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && t2.actor.send("removeDEMTile", { uid: t2.uid, source: this.id });
          }
        }
        class C extends t.Evented {
          constructor(e2, i2, o2, a2) {
            super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = o2.getActor(), this.setEventedParent(a2), this._data = i2.data, this._options = t.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== void 0 && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
            let r2 = t.EXTENT / this.tileSize;
            this.workerOptions = t.extend({ source: this.id, cluster: i2.cluster || !1, geojsonVtOptions: { buffer: (i2.buffer !== void 0 ? i2.buffer : 128) * r2, tolerance: (i2.tolerance !== void 0 ? i2.tolerance : 0.375) * r2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || !1, generateId: i2.generateId || !1 }, superclusterOptions: { maxZoom: i2.clusterMaxZoom !== void 0 ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.EXTENT, radius: (i2.clusterRadius || 50) * r2, log: !1, generateId: i2.generateId || !1 }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
          }
          load() {
            this._updateWorkerData("metadata");
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setData(t2) {
            return this._data = t2, this._updateWorkerData("content"), this;
          }
          getClusterExpansionZoom(t2, e2) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e2), this;
          }
          getClusterChildren(t2, e2) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e2), this;
          }
          getClusterLeaves(t2, e2, i2, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e2, offset: i2 }, o2), this;
          }
          _updateWorkerData(e2) {
            let i2 = t.extend({}, this.workerOptions), o2 = this._data;
            typeof o2 == "string" ? (i2.request = this.map._requestManager.transformRequest(t.exported.resolveURL(o2), t.ResourceType.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoads++, this.fire(new t.Event("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i2, (i3, o3) => {
              if (this._pendingLoads--, this._removed || o3 && o3.abandoned)
                return void this.fire(new t.Event("dataabort", { dataType: "source", sourceDataType: e2 }));
              let a2 = null;
              if (o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (a2 = o3.resourceTiming[this.id].slice(0)), i3)
                return void this.fire(new t.ErrorEvent(i3));
              let r2 = { dataType: "source", sourceDataType: e2 };
              this._collectResourceTiming && a2 && a2.length > 0 && t.extend(r2, { resourceTiming: a2 }), this.fire(new t.Event("data", r2));
            });
          }
          loaded() {
            return this._pendingLoads === 0;
          }
          loadTile(t2, e2) {
            let i2 = t2.actor ? "reloadTile" : "loadTile";
            t2.actor = this.actor;
            let o2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t2.request = this.actor.send(i2, o2, (o3, a2) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? e2(null) : o3 ? e2(o3) : (t2.loadVectorData(a2, this.map.painter, i2 === "reloadTile"), e2(null))));
          }
          abortTile(t2) {
            t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = !0;
          }
          unloadTile(t2) {
            t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id });
          }
          serialize() {
            return t.extend({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        var S = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class D extends t.Evented {
          constructor(t2, e2, i2, o2) {
            super(), this.id = t2, this.dispatcher = i2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o2), this.options = e2;
          }
          load(e2, i2) {
            this._loaded = !1, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (o2, a2) => {
              this._loaded = !0, o2 ? this.fire(new t.ErrorEvent(o2)) : a2 && (this.image = a2, e2 && (this.coordinates = e2), i2 && i2(), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t2) {
            return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, () => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setCoordinates(e2) {
            this.coordinates = e2;
            let i2 = e2.map(t.MercatorCoordinate.fromLngLat);
            this.tileID = function(e3) {
              let i3 = 1 / 0, o3 = 1 / 0, a2 = -1 / 0, r2 = -1 / 0;
              for (let t2 of e3)
                i3 = Math.min(i3, t2.x), o3 = Math.min(o3, t2.y), a2 = Math.max(a2, t2.x), r2 = Math.max(r2, t2.y);
              let s2 = Math.max(a2 - i3, r2 - o3), n2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), l2 = Math.pow(2, n2);
              return new t.CanonicalTileID(n2, Math.floor((i3 + a2) / 2 * l2), Math.floor((o3 + r2) / 2 * l2));
            }(i2), this.minzoom = this.maxzoom = this.tileID.z;
            let o2 = i2.map((t2) => this.tileID.getTilePoint(t2)._round());
            return this._boundsArray = new t.RasterBoundsArray(), this._boundsArray.emplaceBack(o2[0].x, o2[0].y, 0, 0), this._boundsArray.emplaceBack(o2[1].x, o2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(o2[3].x, o2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(o2[2].x, o2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image)
              return;
            let e2 = this.map.painter.context, i2 = e2.gl;
            this.boundsBuffer || (this.boundsBuffer = e2.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new l(e2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            for (let t2 in this.tiles) {
              let e3 = this.tiles[t2];
              e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
            }
          }
          loadTile(t2, e2) {
            this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e2(null)) : (t2.state = "errored", e2(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
        }
        class z extends D {
          constructor(t2, e2, i2, o2) {
            super(t2, e2, i2, o2), this.roundZoom = !0, this.type = "video", this.options = e2;
          }
          load() {
            this._loaded = !1;
            let e2 = this.options;
            this.urls = [];
            for (let i2 of e2.urls)
              this.urls.push(this.map._requestManager.transformRequest(i2, t.ResourceType.Source).url);
            t.getVideo(this.urls, (e3, i2) => {
              this._loaded = !0, e3 ? this.fire(new t.ErrorEvent(e3)) : i2 && (this.video = i2, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e2) {
            if (this.video) {
              let i2 = this.video.seekable;
              e2 < i2.start(0) || e2 > i2.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t2) {
            this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
              return;
            let e2 = this.map.painter.context, i2 = e2.gl;
            this.boundsBuffer || (this.boundsBuffer = e2.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new l(e2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            for (let t2 in this.tiles) {
              let e3 = this.tiles[t2];
              e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
            }
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class P extends D {
          constructor(e2, i2, o2, a2) {
            super(e2, i2, o2, a2), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((t2) => !Array.isArray(t2) || t2.length !== 2 || t2.some((t3) => typeof t3 != "number")) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === void 0 || i2.animate;
          }
          load() {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t2) {
            this.map = t2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e2 = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
              return;
            let i2 = this.map.painter.context, o2 = i2.gl;
            this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new l(i2, this.canvas, o2.RGBA, { premultiply: !0 });
            for (let t2 in this.tiles) {
              let e3 = this.tiles[t2];
              e3.state !== "loaded" && (e3.state = "loaded", e3.texture = this.texture);
            }
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (let t2 of [this.canvas.width, this.canvas.height])
              if (isNaN(t2) || t2 <= 0)
                return !0;
            return !1;
          }
        }
        let M = { vector: w, raster: T, "raster-dem": I, geojson: C, video: z, image: D, canvas: P };
        function A(e2, i2) {
          let o2 = t.create();
          return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e2.width, 0.5 * e2.height, 1]), t.multiply(o2, o2, e2.calculatePosMatrix(i2.toUnwrapped()));
        }
        function L(t2, e2, i2, o2, a2, r2) {
          let s2 = function(t3, e3, i3) {
            if (t3)
              for (let o3 of t3) {
                let t4 = e3[o3];
                if (t4 && t4.source === i3 && t4.type === "fill-extrusion")
                  return !0;
              }
            else
              for (let t4 in e3) {
                let o3 = e3[t4];
                if (o3.source === i3 && o3.type === "fill-extrusion")
                  return !0;
              }
            return !1;
          }(a2 && a2.layers, e2, t2.id), n2 = r2.maxPitchScaleFactor(), l2 = t2.tilesIn(o2, n2, s2);
          l2.sort(R);
          let c2 = [];
          for (let o3 of l2)
            c2.push({ wrappedTileID: o3.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(e2, i2, t2._state, o3.queryGeometry, o3.cameraQueryGeometry, o3.scale, a2, r2, n2, A(t2.transform, o3.tileID)) });
          let h2 = function(t3) {
            let e3 = {}, i3 = {};
            for (let o3 of t3) {
              let t4 = o3.queryResults, a3 = o3.wrappedTileID, r3 = i3[a3] = i3[a3] || {};
              for (let i4 in t4) {
                let o4 = t4[i4], a4 = r3[i4] = r3[i4] || {}, s3 = e3[i4] = e3[i4] || [];
                for (let t5 of o4)
                  a4[t5.featureIndex] || (a4[t5.featureIndex] = !0, s3.push(t5));
              }
            }
            return e3;
          }(c2);
          for (let e3 in h2)
            h2[e3].forEach((e4) => {
              let i3 = e4.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
              i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
            });
          return h2;
        }
        function R(t2, e2) {
          let i2 = t2.tileID, o2 = e2.tileID;
          return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
        }
        class k {
          constructor(e2, i2) {
            this.tileID = e2, this.uid = t.uniqueId(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.textures = [], this.textureCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e2) {
            let i2 = e2 + this.timeAdded;
            i2 < t.exported.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(t2) {
            this.demTexture && t2.saveTileTexture(this.demTexture), this.textures.forEach((e2) => t2.saveTileTexture(e2)), this.demTexture = null, this.textures = [], this.textureCoords = {};
          }
          loadVectorData(e2, i2, o2) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
              e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(t2, e3) {
                let i3 = {};
                if (!e3)
                  return i3;
                for (let o3 of t2) {
                  let t3 = o3.layerIds.map((t4) => e3.getLayer(t4)).filter(Boolean);
                  if (t3.length !== 0) {
                    o3.layers = t3, o3.stateDependentLayerIds && (o3.stateDependentLayers = o3.stateDependentLayerIds.map((e4) => t3.filter((t4) => t4.id === e4)[0]));
                    for (let e4 of t3)
                      i3[e4.id] = o3;
                  }
                }
                return i3;
              }(e2.buckets, i2.style), this.hasSymbolBuckets = !1;
              for (let e3 in this.buckets) {
                let i3 = this.buckets[e3];
                if (i3 instanceof t.SymbolBucket) {
                  if (this.hasSymbolBuckets = !0, !o2)
                    break;
                  i3.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (let e3 in this.buckets) {
                  let i3 = this.buckets[e3];
                  if (i3 instanceof t.SymbolBucket && i3.hasRTLText) {
                    this.hasRTLText = !0, t.lazyLoadRTLTextPlugin();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (let t2 in this.buckets) {
                let e3 = this.buckets[t2];
                this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t2).queryRadius(e3));
              }
              e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage);
            } else
              this.collisionBoxArray = new t.CollisionBoxArray();
          }
          unloadVectorData() {
            for (let t2 in this.buckets)
              this.buckets[t2].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t2) {
            return this.buckets[t2.id];
          }
          upload(t2) {
            for (let e3 in this.buckets) {
              let i2 = this.buckets[e3];
              i2.uploadPending() && i2.upload(t2);
            }
            let e2 = t2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new l(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new l(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t2, e2, i2, o2, a2, r2, s2, n2, l2, c2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: o2, cameraQueryGeometry: a2, scale: r2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: s2, queryPadding: this.queryPadding * l2 }, t2, e2, i2) : {};
          }
          querySourceFeatures(e2, i2) {
            let o2 = this.latestFeatureIndex;
            if (!o2 || !o2.rawTileData)
              return;
            let a2 = o2.loadVTLayers(), r2 = i2 ? i2.sourceLayer : "", s2 = a2._geojsonTileLayer || a2[r2];
            if (!s2)
              return;
            let n2 = t.createFilter(i2 && i2.filter), { z: l2, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h2 };
            for (let i3 = 0; i3 < s2.length; i3++) {
              let a3 = s2.feature(i3);
              if (n2.needGeometry) {
                let e3 = t.toEvaluationFeature(a3, !0);
                if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), e3, this.tileID.canonical))
                  continue;
              } else if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), a3))
                continue;
              let d2 = o2.getId(a3, r2), m2 = new t.GeoJSONFeature(a3, l2, c2, h2, d2);
              m2.tile = u2, e2.push(m2);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e2) {
            let i2 = this.expirationTime;
            if (e2.cacheControl) {
              let i3 = t.parseCacheControl(e2.cacheControl);
              i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
            } else
              e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
            if (this.expirationTime) {
              let t2 = Date.now(), e3 = !1;
              if (this.expirationTime > t2)
                e3 = !1;
              else if (i2)
                if (this.expirationTime < i2)
                  e3 = !0;
                else {
                  let o2 = this.expirationTime - i2;
                  o2 ? this.expirationTime = t2 + Math.max(o2, 3e4) : e3 = !0;
                }
              else
                e3 = !0;
              e3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t2, e2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t2).length === 0)
              return;
            let i2 = this.latestFeatureIndex.loadVTLayers();
            for (let o2 in this.buckets) {
              if (!e2.style.hasLayer(o2))
                continue;
              let a2 = this.buckets[o2], r2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", s2 = i2[r2], n2 = t2[r2];
              if (!s2 || !n2 || Object.keys(n2).length === 0)
                continue;
              a2.update(n2, s2, this.imageAtlas && this.imageAtlas.patternPositions || {});
              let l2 = e2 && e2.style && e2.style.getLayer(o2);
              l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(a2)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t.exported.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e2) {
            this.symbolFadeHoldUntil = t.exported.now() + e2;
          }
          setDependencies(t2, e2) {
            let i2 = {};
            for (let t3 of e2)
              i2[t3] = !0;
            this.dependencies[t2] = i2;
          }
          hasDependency(t2, e2) {
            for (let i2 of t2) {
              let t3 = this.dependencies[i2];
              if (t3) {
                for (let i3 of e2)
                  if (t3[i3])
                    return !0;
              }
            }
            return !1;
          }
        }
        class B {
          constructor(t2, e2) {
            this.max = t2, this.onRemove = e2, this.reset();
          }
          reset() {
            for (let t2 in this.data)
              for (let e2 of this.data[t2])
                e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t2, e2, i2) {
            let o2 = t2.wrapped().key;
            this.data[o2] === void 0 && (this.data[o2] = []);
            let a2 = { value: e2, timeout: void 0 };
            if (i2 !== void 0 && (a2.timeout = setTimeout(() => {
              this.remove(t2, a2);
            }, i2)), this.data[o2].push(a2), this.order.push(o2), this.order.length > this.max) {
              let t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          has(t2) {
            return t2.wrapped().key in this.data;
          }
          getAndRemove(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }
          _getAndRemoveByKey(t2) {
            let e2 = this.data[t2].shift();
            return e2.timeout && clearTimeout(e2.timeout), this.data[t2].length === 0 && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
          }
          getByKey(t2) {
            let e2 = this.data[t2];
            return e2 ? e2[0].value : null;
          }
          get(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }
          remove(t2, e2) {
            if (!this.has(t2))
              return this;
            let i2 = t2.wrapped().key, o2 = e2 === void 0 ? 0 : this.data[i2].indexOf(e2), a2 = this.data[i2][o2];
            return this.data[i2].splice(o2, 1), a2.timeout && clearTimeout(a2.timeout), this.data[i2].length === 0 && delete this.data[i2], this.onRemove(a2.value), this.order.splice(this.order.indexOf(i2), 1), this;
          }
          setMaxSize(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              let t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          filter(t2) {
            let e2 = [];
            for (let i2 in this.data)
              for (let o2 of this.data[i2])
                t2(o2.value) || e2.push(o2);
            for (let t3 of e2)
              this.remove(t3.value.tileID, t3);
          }
        }
        class F {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e2, i2, o2) {
            let a2 = String(i2);
            if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][a2] = this.stateChanges[e2][a2] || {}, t.extend(this.stateChanges[e2][a2], o2), this.deletedStates[e2] === null) {
              this.deletedStates[e2] = {};
              for (let t2 in this.state[e2])
                t2 !== a2 && (this.deletedStates[e2][t2] = null);
            } else if (this.deletedStates[e2] && this.deletedStates[e2][a2] === null) {
              this.deletedStates[e2][a2] = {};
              for (let t2 in this.state[e2][a2])
                o2[t2] || (this.deletedStates[e2][a2][t2] = null);
            } else
              for (let t2 in o2)
                this.deletedStates[e2] && this.deletedStates[e2][a2] && this.deletedStates[e2][a2][t2] === null && delete this.deletedStates[e2][a2][t2];
          }
          removeFeatureState(t2, e2, i2) {
            if (this.deletedStates[t2] === null)
              return;
            let o2 = String(e2);
            if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && e2 !== void 0)
              this.deletedStates[t2][o2] !== null && (this.deletedStates[t2][o2] = this.deletedStates[t2][o2] || {}, this.deletedStates[t2][o2][i2] = null);
            else if (e2 !== void 0)
              if (this.stateChanges[t2] && this.stateChanges[t2][o2])
                for (i2 in this.deletedStates[t2][o2] = {}, this.stateChanges[t2][o2])
                  this.deletedStates[t2][o2][i2] = null;
              else
                this.deletedStates[t2][o2] = null;
            else
              this.deletedStates[t2] = null;
          }
          getState(e2, i2) {
            let o2 = String(i2), a2 = t.extend({}, (this.state[e2] || {})[o2], (this.stateChanges[e2] || {})[o2]);
            if (this.deletedStates[e2] === null)
              return {};
            if (this.deletedStates[e2]) {
              let t2 = this.deletedStates[e2][i2];
              if (t2 === null)
                return {};
              for (let e3 in t2)
                delete a2[e3];
            }
            return a2;
          }
          initializeTileState(t2, e2) {
            t2.setFeatureState(this.state, e2);
          }
          coalesceChanges(e2, i2) {
            let o2 = {};
            for (let e3 in this.stateChanges) {
              this.state[e3] = this.state[e3] || {};
              let i3 = {};
              for (let o3 in this.stateChanges[e3])
                this.state[e3][o3] || (this.state[e3][o3] = {}), t.extend(this.state[e3][o3], this.stateChanges[e3][o3]), i3[o3] = this.state[e3][o3];
              o2[e3] = i3;
            }
            for (let e3 in this.deletedStates) {
              this.state[e3] = this.state[e3] || {};
              let i3 = {};
              if (this.deletedStates[e3] === null)
                for (let t2 in this.state[e3])
                  i3[t2] = {}, this.state[e3][t2] = {};
              else
                for (let t2 in this.deletedStates[e3]) {
                  if (this.deletedStates[e3][t2] === null)
                    this.state[e3][t2] = {};
                  else
                    for (let i4 of Object.keys(this.deletedStates[e3][t2]))
                      delete this.state[e3][t2][i4];
                  i3[t2] = this.state[e3][t2];
                }
              o2[e3] = o2[e3] || {}, t.extend(o2[e3], i3);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o2).length !== 0)
              for (let t2 in e2)
                e2[t2].setFeatureState(o2, i2);
          }
        }
        class O extends t.Evented {
          constructor(e2, i2, o2) {
            super(), this.id = e2, this.dispatcher = o2, this.on("data", (t2) => {
              t2.dataType === "source" && t2.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && t2.dataType === "source" && t2.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain));
            }), this.on("dataloading", () => {
              this._sourceErrored = !1;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = function(e3, i3, o3, a2) {
              let r2 = new M[i3.type](e3, i3, o3, a2);
              if (r2.id !== e3)
                throw new Error(`Expected Source id to be ${e3} instead of ${r2.id}`);
              return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], r2), r2;
            }(e2, i2, o2, this), this._tiles = {}, this._cache = new B(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new F();
          }
          onAdd(t2) {
            this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t2);
          }
          onRemove(t2) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
          }
          loaded() {
            if (this._sourceErrored)
              return !0;
            if (!this._sourceLoaded || !this._source.loaded())
              return !1;
            for (let t2 in this._tiles) {
              let e2 = this._tiles[t2];
              if (e2.state !== "loaded" && e2.state !== "errored")
                return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused)
              return;
            let t2 = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, t2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t2, e2) {
            return this._source.loadTile(t2, e2);
          }
          _unloadTile(t2) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t2, () => {
              });
          }
          _abortTile(e2) {
            this._source.abortTile && this._source.abortTile(e2, () => {
            }), this._source.fire(new t.Event("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (let e2 in this._tiles) {
              let i2 = this._tiles[e2];
              i2.upload(t2), i2.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((t2) => t2.tileID).sort(U).map((t2) => t2.key);
          }
          getRenderableIds(e2) {
            let i2 = [];
            for (let t2 in this._tiles)
              this._isIdRenderable(t2, e2) && i2.push(this._tiles[t2]);
            return e2 ? i2.sort((e3, i3) => {
              let o2 = e3.tileID, a2 = i3.tileID, r2 = new t.pointGeometry(o2.canonical.x, o2.canonical.y)._rotate(this.transform.angle), s2 = new t.pointGeometry(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle);
              return o2.overscaledZ - a2.overscaledZ || s2.y - r2.y || s2.x - r2.x;
            }).map((t2) => t2.tileID.key) : i2.map((t2) => t2.tileID).sort(U).map((t2) => t2.key);
          }
          hasRenderableParent(t2) {
            let e2 = this.findLoadedParent(t2, 0);
            return !!e2 && this._isIdRenderable(e2.tileID.key);
          }
          _isIdRenderable(t2, e2) {
            return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (let t2 in this._tiles)
                this._tiles[t2].state !== "errored" && this._reloadTile(t2, "reloading");
            }
          }
          _reloadTile(t2, e2) {
            let i2 = this._tiles[t2];
            i2 && (i2.state !== "loading" && (i2.state = e2), this._loadTile(i2, this._tileLoaded.bind(this, i2, t2, e2)));
          }
          _tileLoaded(e2, i2, o2, a2) {
            if (a2)
              return e2.state = "errored", void (a2.status !== 404 ? this._source.fire(new t.ErrorEvent(a2, { tile: e2 })) : this.update(this.transform, this.terrain));
            e2.timeAdded = t.exported.now(), o2 === "expired" && (e2.refreshedUponExpiration = !0), this._setTileReloadTimer(i2, e2), this.getSource().type === "raster-dem" && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t.Event("data", { dataType: "source", tile: e2, coord: e2.tileID }));
          }
          _backfillDEM(t2) {
            let e2 = this.getRenderableIds();
            for (let o2 = 0; o2 < e2.length; o2++) {
              let a2 = e2[o2];
              if (t2.neighboringTiles && t2.neighboringTiles[a2]) {
                let e3 = this.getTileByID(a2);
                i2(t2, e3), i2(e3, t2);
              }
            }
            function i2(t3, e3) {
              t3.needsHillshadePrepare = !0, t3.needsTerrainPrepare = !0;
              let i3 = e3.tileID.canonical.x - t3.tileID.canonical.x, o2 = e3.tileID.canonical.y - t3.tileID.canonical.y, a2 = Math.pow(2, t3.tileID.canonical.z), r2 = e3.tileID.key;
              i3 === 0 && o2 === 0 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (Math.abs(i3 + a2) === 1 ? i3 += a2 : Math.abs(i3 - a2) === 1 && (i3 -= a2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, i3, o2), t3.neighboringTiles && t3.neighboringTiles[r2] && (t3.neighboringTiles[r2].backfilled = !0)));
            }
          }
          getTile(t2) {
            return this.getTileByID(t2.key);
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          _retainLoadedChildren(t2, e2, i2, o2) {
            for (let a2 in this._tiles) {
              let r2 = this._tiles[a2];
              if (o2[a2] || !r2.hasData() || r2.tileID.overscaledZ <= e2 || r2.tileID.overscaledZ > i2)
                continue;
              let s2 = r2.tileID;
              for (; r2 && r2.tileID.overscaledZ > e2 + 1; ) {
                let t3 = r2.tileID.scaledTo(r2.tileID.overscaledZ - 1);
                r2 = this._tiles[t3.key], r2 && r2.hasData() && (s2 = t3);
              }
              let n2 = s2;
              for (; n2.overscaledZ > e2; )
                if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                  o2[s2.key] = s2;
                  break;
                }
            }
          }
          findLoadedParent(t2, e2) {
            if (t2.key in this._loadedParentTiles) {
              let i2 = this._loadedParentTiles[t2.key];
              return i2 && i2.tileID.overscaledZ >= e2 ? i2 : null;
            }
            for (let i2 = t2.overscaledZ - 1; i2 >= e2; i2--) {
              let e3 = t2.scaledTo(i2), o2 = this._getLoadedTile(e3);
              if (o2)
                return o2;
            }
          }
          _getLoadedTile(t2) {
            let e2 = this._tiles[t2.key];
            return e2 && e2.hasData() ? e2 : this._cache.getByKey(t2.wrapped().key);
          }
          updateCacheSize(t2) {
            let e2 = Math.ceil(t2.width / this._source.tileSize) + 1, i2 = Math.ceil(t2.height / this._source.tileSize) + 1, o2 = Math.floor(e2 * i2 * 5), a2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, o2) : o2;
            this._cache.setMaxSize(a2);
          }
          handleWrapJump(t2) {
            let e2 = Math.round((t2 - (this._prevLng === void 0 ? t2 : this._prevLng)) / 360);
            if (this._prevLng = t2, e2) {
              let t3 = {};
              for (let i2 in this._tiles) {
                let o2 = this._tiles[i2];
                o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + e2), t3[o2.tileID.key] = o2;
              }
              this._tiles = t3;
              for (let t4 in this._timers)
                clearTimeout(this._timers[t4]), delete this._timers[t4];
              for (let t4 in this._tiles)
                this._setTileReloadTimer(t4, this._tiles[t4]);
            }
          }
          update(e2, i2) {
            if (this.transform = e2, this.terrain = i2, !this._sourceLoaded || this._paused)
              return;
            let o2;
            this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t.OverscaledTileID(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (o2 = e2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2 }), this._source.hasTile && (o2 = o2.filter((t2) => this._source.hasTile(t2)))) : o2 = [];
            let a2 = e2.coveringZoomLevel(this._source), r2 = Math.max(a2 - O.maxOverzooming, this._source.minzoom), s2 = Math.max(a2 + O.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              let t2 = {};
              for (let e3 of o2)
                if (e3.canonical.z > this._source.minzoom) {
                  let i3 = e3.scaledTo(e3.canonical.z - 1);
                  t2[i3.key] = i3;
                  let o3 = e3.scaledTo(Math.max(this._source.minzoom, Math.min(e3.canonical.z, 5)));
                  t2[o3.key] = o3;
                }
              o2 = o2.concat(Object.values(t2));
            }
            let n2 = this._updateRetainedTiles(o2, a2);
            if (N(this._source.type)) {
              let e3 = {}, l3 = {}, c2 = Object.keys(n2);
              for (let i3 of c2) {
                let o3 = n2[i3], a3 = this._tiles[i3];
                if (!a3 || a3.fadeEndTime && a3.fadeEndTime <= t.exported.now())
                  continue;
                let s3 = this.findLoadedParent(o3, r2);
                s3 && (this._addTile(s3.tileID), e3[s3.tileID.key] = s3.tileID), l3[i3] = o3;
              }
              this._retainLoadedChildren(l3, a2, s2, n2);
              for (let t2 in e3)
                n2[t2] || (this._coveredTiles[t2] = !0, n2[t2] = e3[t2]);
              if (i2) {
                let t2 = {}, e4 = {};
                for (let i3 of o2)
                  this._tiles[i3.key].hasData() ? t2[i3.key] = i3 : e4[i3.key] = i3;
                for (let i3 in e4) {
                  let o3 = e4[i3].children(this._source.maxzoom);
                  this._tiles[o3[0].key] && this._tiles[o3[1].key] && this._tiles[o3[2].key] && this._tiles[o3[3].key] && (t2[o3[0].key] = n2[o3[0].key] = o3[0], t2[o3[1].key] = n2[o3[1].key] = o3[1], t2[o3[2].key] = n2[o3[2].key] = o3[2], t2[o3[3].key] = n2[o3[3].key] = o3[3], delete e4[i3]);
                }
                for (let i3 in e4) {
                  let o3 = this.findLoadedParent(e4[i3], this._source.minzoom);
                  if (o3) {
                    t2[o3.tileID.key] = n2[o3.tileID.key] = o3.tileID;
                    for (let e5 in t2)
                      t2[e5].isChildOf(o3.tileID) && delete t2[e5];
                  }
                }
                for (let e5 in this._tiles)
                  t2[e5] || (this._coveredTiles[e5] = !0);
              }
            }
            for (let t2 in n2)
              this._tiles[t2].clearFadeHold();
            let l2 = t.keysDifference(this._tiles, n2);
            for (let t2 of l2) {
              let e3 = this._tiles[t2];
              e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(t2);
            }
            this._updateLoadedParentTileCache();
          }
          releaseSymbolFadeTiles() {
            for (let t2 in this._tiles)
              this._tiles[t2].holdingForFade() && this._removeTile(t2);
          }
          _updateRetainedTiles(t2, e2) {
            let i2 = {}, o2 = {}, a2 = Math.max(e2 - O.maxOverzooming, this._source.minzoom), r2 = Math.max(e2 + O.maxUnderzooming, this._source.minzoom), s2 = {};
            for (let o3 of t2) {
              let t3 = this._addTile(o3);
              i2[o3.key] = o3, t3.hasData() || e2 < this._source.maxzoom && (s2[o3.key] = o3);
            }
            this._retainLoadedChildren(s2, e2, r2, i2);
            for (let r3 of t2) {
              let t3 = this._tiles[r3.key];
              if (t3.hasData())
                continue;
              if (e2 + 1 > this._source.maxzoom) {
                let t4 = r3.children(this._source.maxzoom)[0], e3 = this.getTile(t4);
                if (e3 && e3.hasData()) {
                  i2[t4.key] = t4;
                  continue;
                }
              } else {
                let t4 = r3.children(this._source.maxzoom);
                if (i2[t4[0].key] && i2[t4[1].key] && i2[t4[2].key] && i2[t4[3].key])
                  continue;
              }
              let s3 = t3.wasRequested();
              for (let e3 = r3.overscaledZ - 1; e3 >= a2; --e3) {
                let a3 = r3.scaledTo(e3);
                if (o2[a3.key] || (o2[a3.key] = !0, t3 = this.getTile(a3), !t3 && s3 && (t3 = this._addTile(a3)), t3 && (i2[a3.key] = a3, s3 = t3.wasRequested(), t3.hasData())))
                  break;
              }
            }
            return i2;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (let t2 in this._tiles) {
              let e2 = [], i2, o2 = this._tiles[t2].tileID;
              for (; o2.overscaledZ > 0; ) {
                if (o2.key in this._loadedParentTiles) {
                  i2 = this._loadedParentTiles[o2.key];
                  break;
                }
                e2.push(o2.key);
                let t3 = o2.scaledTo(o2.overscaledZ - 1);
                if (i2 = this._getLoadedTile(t3), i2)
                  break;
                o2 = t3;
              }
              for (let t3 of e2)
                this._loadedParentTiles[t3] = i2;
            }
          }
          _addTile(e2) {
            let i2 = this._tiles[e2.key];
            if (i2)
              return i2;
            i2 = this._cache.getAndRemove(e2), i2 && (this._setTileReloadTimer(e2.key, i2), i2.tileID = e2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, i2)));
            let o2 = i2;
            return i2 || (i2 = new k(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i2, this._tileLoaded.bind(this, i2, e2.key, i2.state))), i2.uses++, this._tiles[e2.key] = i2, o2 || this._source.fire(new t.Event("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
          }
          _setTileReloadTimer(t2, e2) {
            t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
            let i2 = e2.getExpiryTimeout();
            i2 && (this._timers[t2] = setTimeout(() => {
              this._reloadTile(t2, "expired"), delete this._timers[t2];
            }, i2));
          }
          _removeTile(t2) {
            let e2 = this._tiles[t2];
            e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && e2.state !== "reloading" ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = !0, this._abortTile(e2), this._unloadTile(e2))));
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (let t2 in this._tiles)
              this._removeTile(t2);
            this._cache.reset();
          }
          tilesIn(e2, i2, o2) {
            let a2 = [], r2 = this.transform;
            if (!r2)
              return a2;
            let s2 = o2 ? r2.getCameraQueryGeometry(e2) : e2, n2 = e2.map((t2) => r2.pointCoordinate(t2, this.terrain)), l2 = s2.map((t2) => r2.pointCoordinate(t2, this.terrain)), c2 = this.getIds(), h2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, m2 = -1 / 0;
            for (let t2 of l2)
              h2 = Math.min(h2, t2.x), u2 = Math.min(u2, t2.y), d2 = Math.max(d2, t2.x), m2 = Math.max(m2, t2.y);
            for (let e3 = 0; e3 < c2.length; e3++) {
              let o3 = this._tiles[c2[e3]];
              if (o3.holdingForFade())
                continue;
              let s3 = o3.tileID, _2 = Math.pow(2, r2.zoom - o3.tileID.overscaledZ), p2 = i2 * o3.queryPadding * t.EXTENT / o3.tileSize / _2, f2 = [s3.getTilePoint(new t.MercatorCoordinate(h2, u2)), s3.getTilePoint(new t.MercatorCoordinate(d2, m2))];
              if (f2[0].x - p2 < t.EXTENT && f2[0].y - p2 < t.EXTENT && f2[1].x + p2 >= 0 && f2[1].y + p2 >= 0) {
                let t2 = n2.map((t3) => s3.getTilePoint(t3)), e4 = l2.map((t3) => s3.getTilePoint(t3));
                a2.push({ tile: o3, tileID: s3, queryGeometry: t2, cameraQueryGeometry: e4, scale: _2 });
              }
            }
            return a2;
          }
          getVisibleCoordinates(t2) {
            let e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
            for (let t3 of e2)
              t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
            return e2;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return !0;
            if (N(this._source.type))
              for (let e2 in this._tiles) {
                let i2 = this._tiles[e2];
                if (i2.fadeEndTime !== void 0 && i2.fadeEndTime >= t.exported.now())
                  return !0;
              }
            return !1;
          }
          setFeatureState(t2, e2, i2) {
            this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, i2);
          }
          removeFeatureState(t2, e2, i2) {
            this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, i2);
          }
          getFeatureState(t2, e2) {
            return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
          }
          setDependencies(t2, e2, i2) {
            let o2 = this._tiles[t2];
            o2 && o2.setDependencies(e2, i2);
          }
          reloadTilesForDependencies(t2, e2) {
            for (let i2 in this._tiles)
              this._tiles[i2].hasDependency(t2, e2) && this._reloadTile(i2, "reloading");
            this._cache.filter((i2) => !i2.hasDependency(t2, e2));
          }
        }
        function U(t2, e2) {
          let i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), o2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t2.overscaledZ - e2.overscaledZ || o2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
        }
        function N(t2) {
          return t2 === "raster" || t2 === "image" || t2 === "video";
        }
        O.maxOverzooming = 10, O.maxUnderzooming = 3;
        let G = "mapboxgl_preloaded_worker_pool";
        class Z {
          constructor() {
            this.active = {};
          }
          acquire(t2) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Z.workerCount; )
                this.workers.push(new Worker(ba.workerUrl));
            return this.active[t2] = !0, this.workers.slice();
          }
          release(t2) {
            delete this.active[t2], this.numActive() === 0 && (this.workers.forEach((t3) => {
              t3.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[G];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        let V = Math.floor(t.exported.hardwareConcurrency / 2), q;
        function j() {
          return q || (q = new Z()), q;
        }
        function $(e2, i2) {
          let o2 = {};
          for (let t2 in e2)
            t2 !== "ref" && (o2[t2] = e2[t2]);
          return t.refProperties.forEach((t2) => {
            t2 in i2 && (o2[t2] = i2[t2]);
          }), o2;
        }
        function X(t2) {
          t2 = t2.slice();
          let e2 = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < t2.length; i2++)
            e2[t2[i2].id] = t2[i2];
          for (let i2 = 0; i2 < t2.length; i2++)
            "ref" in t2[i2] && (t2[i2] = $(t2[i2], e2[t2[i2].ref]));
          return t2;
        }
        Z.workerCount = Math.max(Math.min(V, 6), 1);
        let W = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
        function H(t2, e2, i2) {
          i2.push({ command: W.addSource, args: [t2, e2[t2]] });
        }
        function K(t2, e2, i2) {
          e2.push({ command: W.removeSource, args: [t2] }), i2[t2] = !0;
        }
        function Y(t2, e2, i2, o2) {
          K(t2, i2, o2), H(t2, e2, i2);
        }
        function J(t2, e2, i2) {
          let o2;
          for (o2 in t2[i2])
            if (Object.prototype.hasOwnProperty.call(t2[i2], o2) && o2 !== "data" && !a(t2[i2][o2], e2[i2][o2]))
              return !1;
          for (o2 in e2[i2])
            if (Object.prototype.hasOwnProperty.call(e2[i2], o2) && o2 !== "data" && !a(t2[i2][o2], e2[i2][o2]))
              return !1;
          return !0;
        }
        function Q(t2, e2, i2, o2, r2, s2) {
          let n2;
          for (n2 in e2 = e2 || {}, t2 = t2 || {})
            Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e2[n2]) || i2.push({ command: s2, args: [o2, n2, e2[n2], r2] }));
          for (n2 in e2)
            Object.prototype.hasOwnProperty.call(e2, n2) && !Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e2[n2]) || i2.push({ command: s2, args: [o2, n2, e2[n2], r2] }));
        }
        function tt(t2) {
          return t2.id;
        }
        function et(t2, e2) {
          return t2[e2.id] = e2, t2;
        }
        class it {
          constructor(t2, e2) {
            this.reset(t2, e2);
          }
          reset(t2, e2) {
            this.points = t2 || [], this._distances = [0];
            for (let t3 = 1; t3 < this.points.length; t3++)
              this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e2) {
            if (this.points.length === 1)
              return this.points[0];
            e2 = t.clamp(e2, 0, 1);
            let i2 = 1, o2 = this._distances[i2], a2 = e2 * this.paddedLength + this.padding;
            for (; o2 < a2 && i2 < this._distances.length; )
              o2 = this._distances[++i2];
            let r2 = i2 - 1, s2 = this._distances[r2], n2 = o2 - s2, l2 = n2 > 0 ? (a2 - s2) / n2 : 0;
            return this.points[r2].mult(1 - l2).add(this.points[i2].mult(l2));
          }
        }
        function ot(t2, e2) {
          let i2 = !0;
          return t2 === "always" || t2 !== "never" && e2 !== "never" || (i2 = !1), i2;
        }
        class at {
          constructor(t2, e2, i2) {
            let o2 = this.boxCells = [], a2 = this.circleCells = [];
            this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
            for (let t3 = 0; t3 < this.xCellCount * this.yCellCount; t3++)
              o2.push([]), a2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t2, e2, i2, o2, a2) {
            this._forEachCell(e2, i2, o2, a2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(a2);
          }
          insertCircle(t2, e2, i2, o2) {
            this._forEachCell(e2 - o2, i2 - o2, e2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(o2);
          }
          _insertBoxCell(t2, e2, i2, o2, a2, r2) {
            this.boxCells[a2].push(r2);
          }
          _insertCircleCell(t2, e2, i2, o2, a2, r2) {
            this.circleCells[a2].push(r2);
          }
          _query(t2, e2, i2, o2, a2, r2, s2) {
            if (i2 < 0 || t2 > this.width || o2 < 0 || e2 > this.height)
              return [];
            let n2 = [];
            if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= o2) {
              if (a2)
                return [{ key: null, x1: t2, y1: e2, x2: i2, y2: o2 }];
              for (let t3 = 0; t3 < this.boxKeys.length; t3++)
                n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
              for (let t3 = 0; t3 < this.circleKeys.length; t3++) {
                let e3 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], o3 = this.circles[3 * t3 + 2];
                n2.push({ key: this.circleKeys[t3], x1: e3 - o3, y1: i3 - o3, x2: e3 + o3, y2: i3 + o3 });
              }
            } else
              this._forEachCell(t2, e2, i2, o2, this._queryCell, n2, { hitTest: a2, overlapMode: r2, seenUids: { box: {}, circle: {} } }, s2);
            return n2;
          }
          query(t2, e2, i2, o2) {
            return this._query(t2, e2, i2, o2, !1, null);
          }
          hitTest(t2, e2, i2, o2, a2, r2) {
            return this._query(t2, e2, i2, o2, !0, a2, r2).length > 0;
          }
          hitTestCircle(t2, e2, i2, o2, a2) {
            let r2 = t2 - i2, s2 = t2 + i2, n2 = e2 - i2, l2 = e2 + i2;
            if (s2 < 0 || r2 > this.width || l2 < 0 || n2 > this.height)
              return !1;
            let c2 = [];
            return this._forEachCell(r2, n2, s2, l2, this._queryCellCircle, c2, { hitTest: !0, overlapMode: o2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, a2), c2.length > 0;
          }
          _queryCell(t2, e2, i2, o2, a2, r2, s2, n2) {
            let { seenUids: l2, hitTest: c2, overlapMode: h2 } = s2, u2 = this.boxCells[a2];
            if (u2 !== null) {
              let a3 = this.bboxes;
              for (let s3 of u2)
                if (!l2.box[s3]) {
                  l2.box[s3] = !0;
                  let u3 = 4 * s3, d3 = this.boxKeys[s3];
                  if (t2 <= a3[u3 + 2] && e2 <= a3[u3 + 3] && i2 >= a3[u3 + 0] && o2 >= a3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !ot(h2, d3.overlapMode)) && (r2.push({ key: d3, x1: a3[u3], y1: a3[u3 + 1], x2: a3[u3 + 2], y2: a3[u3 + 3] }), c2))
                    return !0;
                }
            }
            let d2 = this.circleCells[a2];
            if (d2 !== null) {
              let a3 = this.circles;
              for (let s3 of d2)
                if (!l2.circle[s3]) {
                  l2.circle[s3] = !0;
                  let u3 = 3 * s3, d3 = this.circleKeys[s3];
                  if (this._circleAndRectCollide(a3[u3], a3[u3 + 1], a3[u3 + 2], t2, e2, i2, o2) && (!n2 || n2(d3)) && (!c2 || !ot(h2, d3.overlapMode))) {
                    let t3 = a3[u3], e3 = a3[u3 + 1], i3 = a3[u3 + 2];
                    if (r2.push({ key: d3, x1: t3 - i3, y1: e3 - i3, x2: t3 + i3, y2: e3 + i3 }), c2)
                      return !0;
                  }
                }
            }
            return !1;
          }
          _queryCellCircle(t2, e2, i2, o2, a2, r2, s2, n2) {
            let { circle: l2, seenUids: c2, overlapMode: h2 } = s2, u2 = this.boxCells[a2];
            if (u2 !== null) {
              let t3 = this.bboxes;
              for (let e3 of u2)
                if (!c2.box[e3]) {
                  c2.box[e3] = !0;
                  let i3 = 4 * e3, o3 = this.boxKeys[e3];
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(o3)) && !ot(h2, o3.overlapMode))
                    return r2.push(!0), !0;
                }
            }
            let d2 = this.circleCells[a2];
            if (d2 !== null) {
              let t3 = this.circles;
              for (let e3 of d2)
                if (!c2.circle[e3]) {
                  c2.circle[e3] = !0;
                  let i3 = 3 * e3, o3 = this.circleKeys[e3];
                  if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(o3)) && !ot(h2, o3.overlapMode))
                    return r2.push(!0), !0;
                }
            }
          }
          _forEachCell(t2, e2, i2, o2, a2, r2, s2, n2) {
            let l2 = this._convertToXCellCoord(t2), c2 = this._convertToYCellCoord(e2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
            for (let d2 = l2; d2 <= h2; d2++)
              for (let l3 = c2; l3 <= u2; l3++)
                if (a2.call(this, t2, e2, i2, o2, this.xCellCount * l3 + d2, r2, s2, n2))
                  return;
          }
          _convertToXCellCoord(t2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
          }
          _convertToYCellCoord(t2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
          }
          _circlesCollide(t2, e2, i2, o2, a2, r2) {
            let s2 = o2 - t2, n2 = a2 - e2, l2 = i2 + r2;
            return l2 * l2 > s2 * s2 + n2 * n2;
          }
          _circleAndRectCollide(t2, e2, i2, o2, a2, r2, s2) {
            let n2 = (r2 - o2) / 2, l2 = Math.abs(t2 - (o2 + n2));
            if (l2 > n2 + i2)
              return !1;
            let c2 = (s2 - a2) / 2, h2 = Math.abs(e2 - (a2 + c2));
            if (h2 > c2 + i2)
              return !1;
            if (l2 <= n2 || h2 <= c2)
              return !0;
            let u2 = l2 - n2, d2 = h2 - c2;
            return u2 * u2 + d2 * d2 <= i2 * i2;
          }
        }
        function rt(e2, i2, o2, a2, r2) {
          let s2 = t.create();
          return i2 ? (t.scale(s2, s2, [1 / r2, 1 / r2, 1]), o2 || t.rotateZ(s2, s2, a2.angle)) : t.multiply(s2, a2.labelPlaneMatrix, e2), s2;
        }
        function st(e2, i2, o2, a2, r2) {
          if (i2) {
            let i3 = t.clone(e2);
            return t.scale(i3, i3, [r2, r2, 1]), o2 || t.rotateZ(i3, i3, -a2.angle), i3;
          }
          return a2.glCoordMatrix;
        }
        function nt(e2, i2, o2) {
          let a2;
          o2 ? (a2 = [e2.x, e2.y, o2(e2.x, e2.y), 1], t.transformMat4(a2, a2, i2)) : (a2 = [e2.x, e2.y, 0, 1], xt(a2, a2, i2));
          let r2 = a2[3];
          return { point: new t.pointGeometry(a2[0] / r2, a2[1] / r2), signedDistanceFromCamera: r2 };
        }
        function lt(t2, e2) {
          return 0.5 + t2 / e2 * 0.5;
        }
        function ct(t2, e2) {
          let i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
          return i2 >= -e2[0] && i2 <= e2[0] && o2 >= -e2[1] && o2 <= e2[1];
        }
        function ht(e2, i2, o2, a2, r2, s2, n2, l2, c2, h2) {
          let u2 = a2 ? e2.textSizeData : e2.iconSizeData, d2 = t.evaluateSizeForZoom(u2, o2.transform.zoom), m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], _2 = a2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
          _2.clear();
          let p2 = e2.lineVertexArray, f2 = a2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, g2 = o2.transform.width / o2.transform.height, x2 = !1;
          for (let a3 = 0; a3 < f2.length; a3++) {
            let v2 = f2.get(a3);
            if (v2.hidden || v2.writingMode === t.WritingMode.vertical && !x2) {
              gt(v2.numGlyphs, _2);
              continue;
            }
            let y2;
            if (x2 = !1, h2 ? (y2 = [v2.anchorX, v2.anchorY, h2(v2.anchorX, v2.anchorY), 1], t.transformMat4(y2, y2, i2)) : (y2 = [v2.anchorX, v2.anchorY, 0, 1], xt(y2, y2, i2)), !ct(y2, m2)) {
              gt(v2.numGlyphs, _2);
              continue;
            }
            let b2 = lt(o2.transform.cameraToCenterDistance, y2[3]), w2 = t.evaluateSizeForFeature(u2, d2, v2), T2 = n2 ? w2 / b2 : w2 * b2, E2 = new t.pointGeometry(v2.anchorX, v2.anchorY), I2 = nt(E2, r2, h2).point, C2 = {}, S2 = mt(v2, T2, !1, l2, i2, r2, s2, e2.glyphOffsetArray, p2, _2, I2, E2, C2, g2, c2, h2);
            x2 = S2.useVertical, (S2.notEnoughRoom || x2 || S2.needsFlipping && mt(v2, T2, !0, l2, i2, r2, s2, e2.glyphOffsetArray, p2, _2, I2, E2, C2, g2, c2, h2).notEnoughRoom) && gt(v2.numGlyphs, _2);
          }
          a2 ? e2.text.dynamicLayoutVertexBuffer.updateData(_2) : e2.icon.dynamicLayoutVertexBuffer.updateData(_2);
        }
        function ut(t2, e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2) {
          let m2 = n2.glyphStartIndex + n2.numGlyphs, _2 = n2.lineStartIndex, p2 = n2.lineStartIndex + n2.lineLength, f2 = e2.getoffsetX(n2.glyphStartIndex), g2 = e2.getoffsetX(m2 - 1), x2 = pt(t2 * f2, i2, o2, a2, r2, s2, n2.segment, _2, p2, l2, c2, h2, u2, d2);
          if (!x2)
            return null;
          let v2 = pt(t2 * g2, i2, o2, a2, r2, s2, n2.segment, _2, p2, l2, c2, h2, u2, d2);
          return v2 ? { first: x2, last: v2 } : null;
        }
        function dt(e2, i2, o2, a2) {
          return e2 === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * a2 ? { useVertical: !0 } : (e2 === t.WritingMode.vertical ? i2.y < o2.y : i2.x > o2.x) ? { needsFlipping: !0 } : null;
        }
        function mt(e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2, p2, f2) {
          let g2 = i2 / 24, x2 = e2.lineOffsetX * g2, v2 = e2.lineOffsetY * g2, y2;
          if (e2.numGlyphs > 1) {
            let t2 = e2.glyphStartIndex + e2.numGlyphs, i3 = e2.lineStartIndex, r3 = e2.lineStartIndex + e2.lineLength, h3 = ut(g2, l2, x2, v2, o2, u2, d2, e2, c2, s2, m2, p2, f2);
            if (!h3)
              return { notEnoughRoom: !0 };
            let b2 = nt(h3.first.point, n2, f2).point, w2 = nt(h3.last.point, n2, f2).point;
            if (a2 && !o2) {
              let t3 = dt(e2.writingMode, b2, w2, _2);
              if (t3)
                return t3;
            }
            y2 = [h3.first];
            for (let a3 = e2.glyphStartIndex + 1; a3 < t2 - 1; a3++)
              y2.push(pt(g2 * l2.getoffsetX(a3), x2, v2, o2, u2, d2, e2.segment, i3, r3, c2, s2, m2, p2, f2));
            y2.push(h3.last);
          } else {
            if (a2 && !o2) {
              let i4 = nt(d2, r2, f2).point, o3 = e2.lineStartIndex + e2.segment + 1, a3 = new t.pointGeometry(c2.getx(o3), c2.gety(o3)), s3 = nt(a3, r2, f2), n3 = s3.signedDistanceFromCamera > 0 ? s3.point : _t(d2, a3, i4, 1, r2, f2), l3 = dt(e2.writingMode, i4, n3, _2);
              if (l3)
                return l3;
            }
            let i3 = pt(g2 * l2.getoffsetX(e2.glyphStartIndex), x2, v2, o2, u2, d2, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, c2, s2, m2, p2, f2);
            if (!i3)
              return { notEnoughRoom: !0 };
            y2 = [i3];
          }
          for (let e3 of y2)
            t.addDynamicAttributes(h2, e3.point, e3.angle);
          return {};
        }
        function _t(t2, e2, i2, o2, a2, r2) {
          let s2 = nt(t2.add(t2.sub(e2)._unit()), a2, r2).point, n2 = i2.sub(s2);
          return i2.add(n2._mult(o2 / n2.mag()));
        }
        function pt(e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2) {
          let p2 = a2 ? e2 - i2 : e2 + i2, f2 = p2 > 0 ? 1 : -1, g2 = 0;
          a2 && (f2 *= -1, g2 = Math.PI), f2 < 0 && (g2 += Math.PI);
          let x2 = f2 > 0 ? l2 + n2 : l2 + n2 + 1, v2 = r2, y2 = r2, b2 = 0, w2 = 0, T2 = Math.abs(p2), E2 = [];
          for (; b2 + w2 <= T2; ) {
            if (x2 += f2, x2 < l2 || x2 >= c2)
              return null;
            if (y2 = v2, E2.push(v2), v2 = d2[x2], v2 === void 0) {
              let e3 = new t.pointGeometry(h2.getx(x2), h2.gety(x2)), i3 = nt(e3, u2, _2);
              if (i3.signedDistanceFromCamera > 0)
                v2 = d2[x2] = i3.point;
              else {
                let i4 = x2 - f2;
                v2 = _t(b2 === 0 ? s2 : new t.pointGeometry(h2.getx(i4), h2.gety(i4)), e3, y2, T2 - b2 + 1, u2, _2);
              }
            }
            b2 += w2, w2 = y2.dist(v2);
          }
          let I2 = (T2 - b2) / w2, C2 = v2.sub(y2), S2 = C2.mult(I2)._add(y2);
          S2._add(C2._unit()._perp()._mult(o2 * f2));
          let D2 = g2 + Math.atan2(v2.y - y2.y, v2.x - y2.x);
          return E2.push(S2), { point: S2, angle: m2 ? D2 : 0, path: E2 };
        }
        let ft = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function gt(t2, e2) {
          for (let i2 = 0; i2 < t2; i2++) {
            let t3 = e2.length;
            e2.resize(t3 + 4), e2.float32.set(ft, 3 * t3);
          }
        }
        function xt(t2, e2, i2) {
          let o2 = e2[0], a2 = e2[1];
          return t2[0] = i2[0] * o2 + i2[4] * a2 + i2[12], t2[1] = i2[1] * o2 + i2[5] * a2 + i2[13], t2[3] = i2[3] * o2 + i2[7] * a2 + i2[15], t2;
        }
        let vt = 100;
        class yt {
          constructor(t2, e2 = new at(t2.width + 200, t2.height + 200, 25), i2 = new at(t2.width + 200, t2.height + 200, 25)) {
            this.transform = t2, this.grid = e2, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + vt, this.screenBottomBoundary = t2.height + vt, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t2, e2, i2, o2, a2, r2) {
            let s2 = this.projectAndGetPerspectiveRatio(o2, t2.anchorPointX, t2.anchorPointY, r2), n2 = i2 * s2.perspectiveRatio, l2 = t2.x1 * n2 + s2.point.x, c2 = t2.y1 * n2 + s2.point.y, h2 = t2.x2 * n2 + s2.point.x, u2 = t2.y2 * n2 + s2.point.y;
            return !this.isInsideGrid(l2, c2, h2, u2) || e2 !== "always" && this.grid.hitTest(l2, c2, h2, u2, e2, a2) || s2.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: !1 } : { box: [l2, c2, h2, u2], offscreen: this.isOffscreen(l2, c2, h2, u2) };
          }
          placeCollisionCircles(e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2) {
            let p2 = [], f2 = new t.pointGeometry(i2.anchorX, i2.anchorY), g2 = nt(f2, s2, _2), x2 = lt(this.transform.cameraToCenterDistance, g2.signedDistanceFromCamera), v2 = (h2 ? r2 / x2 : r2 * x2) / t.ONE_EM, y2 = nt(f2, n2, _2).point, b2 = ut(v2, a2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, !1, y2, f2, i2, o2, n2, {}, !1, _2), w2 = !1, T2 = !1, E2 = !0;
            if (b2) {
              let i3 = 0.5 * d2 * x2 + m2, o3 = new t.pointGeometry(-100, -100), a3 = new t.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), r3 = new it(), s3 = b2.first, n3 = b2.last, h3 = [];
              for (let t2 = s3.path.length - 1; t2 >= 1; t2--)
                h3.push(s3.path[t2]);
              for (let t2 = 1; t2 < n3.path.length; t2++)
                h3.push(n3.path[t2]);
              let f3 = 2.5 * i3;
              if (l2) {
                let t2 = h3.map((t3) => nt(t3, l2, _2));
                h3 = t2.some((t3) => t3.signedDistanceFromCamera <= 0) ? [] : t2.map((t3) => t3.point);
              }
              let g3 = [];
              if (h3.length > 0) {
                let e3 = h3[0].clone(), i4 = h3[0].clone();
                for (let t2 = 1; t2 < h3.length; t2++)
                  e3.x = Math.min(e3.x, h3[t2].x), e3.y = Math.min(e3.y, h3[t2].y), i4.x = Math.max(i4.x, h3[t2].x), i4.y = Math.max(i4.y, h3[t2].y);
                g3 = e3.x >= o3.x && i4.x <= a3.x && e3.y >= o3.y && i4.y <= a3.y ? [h3] : i4.x < o3.x || e3.x > a3.x || i4.y < o3.y || e3.y > a3.y ? [] : t.clipLine([h3], o3.x, o3.y, a3.x, a3.y);
              }
              for (let t2 of g3) {
                r3.reset(t2, 0.25 * i3);
                let o4 = 0;
                o4 = r3.length <= 0.5 * i3 ? 1 : Math.ceil(r3.paddedLength / f3) + 1;
                for (let t3 = 0; t3 < o4; t3++) {
                  let a4 = t3 / Math.max(o4 - 1, 1), s4 = r3.lerp(a4), n4 = s4.x + vt, l3 = s4.y + vt;
                  p2.push(n4, l3, i3, 0);
                  let h4 = n4 - i3, d3 = l3 - i3, m3 = n4 + i3, _3 = l3 + i3;
                  if (E2 = E2 && this.isOffscreen(h4, d3, m3, _3), T2 = T2 || this.isInsideGrid(h4, d3, m3, _3), e2 !== "always" && this.grid.hitTestCircle(n4, l3, i3, e2, u2) && (w2 = !0, !c2))
                    return { circles: [], offscreen: !1, collisionDetected: w2 };
                }
              }
            }
            return { circles: !c2 && w2 || !T2 || x2 < this.perspectiveRatioCutoff ? [] : p2, offscreen: E2, collisionDetected: w2 };
          }
          queryRenderedSymbols(e2) {
            if (e2.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
              return {};
            let i2 = [], o2 = 1 / 0, a2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0;
            for (let n3 of e2) {
              let e3 = new t.pointGeometry(n3.x + vt, n3.y + vt);
              o2 = Math.min(o2, e3.x), a2 = Math.min(a2, e3.y), r2 = Math.max(r2, e3.x), s2 = Math.max(s2, e3.y), i2.push(e3);
            }
            let n2 = this.grid.query(o2, a2, r2, s2).concat(this.ignoredGrid.query(o2, a2, r2, s2)), l2 = {}, c2 = {};
            for (let e3 of n2) {
              let o3 = e3.key;
              if (l2[o3.bucketInstanceId] === void 0 && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                continue;
              let a3 = [new t.pointGeometry(e3.x1, e3.y1), new t.pointGeometry(e3.x2, e3.y1), new t.pointGeometry(e3.x2, e3.y2), new t.pointGeometry(e3.x1, e3.y2)];
              t.polygonIntersectsPolygon(i2, a3) && (l2[o3.bucketInstanceId][o3.featureIndex] = !0, c2[o3.bucketInstanceId] === void 0 && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
            }
            return c2;
          }
          insertCollisionBox(t2, e2, i2, o2, a2, r2) {
            (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: o2, featureIndex: a2, collisionGroupID: r2, overlapMode: e2 }, t2[0], t2[1], t2[2], t2[3]);
          }
          insertCollisionCircles(t2, e2, i2, o2, a2, r2) {
            let s2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: o2, featureIndex: a2, collisionGroupID: r2, overlapMode: e2 };
            for (let e3 = 0; e3 < t2.length; e3 += 4)
              s2.insertCircle(n2, t2[e3], t2[e3 + 1], t2[e3 + 2]);
          }
          projectAndGetPerspectiveRatio(e2, i2, o2, a2) {
            let r2;
            return a2 ? (r2 = [i2, o2, a2(i2, o2), 1], t.transformMat4(r2, r2, e2)) : (r2 = [i2, o2, 0, 1], xt(r2, r2, e2)), { point: new t.pointGeometry((r2[0] / r2[3] + 1) / 2 * this.transform.width + vt, (-r2[1] / r2[3] + 1) / 2 * this.transform.height + vt), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / r2[3] * 0.5 };
          }
          isOffscreen(t2, e2, i2, o2) {
            return i2 < vt || t2 >= this.screenRightBoundary || o2 < vt || e2 > this.screenBottomBoundary;
          }
          isInsideGrid(t2, e2, i2, o2) {
            return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            let e2 = t.identity([]);
            return t.translate(e2, e2, [-100, -100, 0]), e2;
          }
        }
        function bt(e2, i2, o2) {
          return i2 * (t.EXTENT / (e2.tileSize * Math.pow(2, o2 - e2.tileID.overscaledZ)));
        }
        class wt {
          constructor(t2, e2, i2, o2) {
            this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : o2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Tt {
          constructor(t2, e2, i2, o2, a2) {
            this.text = new wt(t2 ? t2.text : null, e2, i2, a2), this.icon = new wt(t2 ? t2.icon : null, e2, o2, a2);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Et {
          constructor(t2, e2, i2) {
            this.text = t2, this.icon = e2, this.skipFade = i2;
          }
        }
        class It {
          constructor() {
            this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];
          }
        }
        class Ct {
          constructor(t2, e2, i2, o2, a2) {
            this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = a2;
          }
        }
        class St {
          constructor(t2) {
            this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t2) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[t2]) {
              let e2 = ++this.maxGroupID;
              this.collisionGroups[t2] = { ID: e2, predicate: (t3) => t3.collisionGroupID === e2 };
            }
            return this.collisionGroups[t2];
          }
        }
        function Dt(e2, i2, o2, a2, r2) {
          let { horizontalAlign: s2, verticalAlign: n2 } = t.getAnchorAlignment(e2), l2 = -(s2 - 0.5) * i2, c2 = -(n2 - 0.5) * o2, h2 = t.evaluateVariableOffset(e2, a2);
          return new t.pointGeometry(l2 + h2[0] * r2, c2 + h2[1] * r2);
        }
        function zt(e2, i2, o2, a2, r2, s2) {
          let { x1: n2, x2: l2, y1: c2, y2: h2, anchorPointX: u2, anchorPointY: d2 } = e2, m2 = new t.pointGeometry(i2, o2);
          return a2 && m2._rotate(r2 ? s2 : -s2), { x1: n2 + m2.x, y1: c2 + m2.y, x2: l2 + m2.x, y2: h2 + m2.y, anchorPointX: u2, anchorPointY: d2 };
        }
        class Pt {
          constructor(t2, e2, i2, o2, a2) {
            this.transform = t2.clone(), this.terrain = e2, this.collisionIndex = new yt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new St(o2), this.collisionCircleArrays = {}, this.prevPlacement = a2, a2 && (a2.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(e2, i2, o2, a2) {
            let r2 = o2.getBucket(i2), s2 = o2.latestFeatureIndex;
            if (!r2 || !s2 || i2.id !== r2.layerIds[0])
              return;
            let n2 = o2.collisionBoxArray, l2 = r2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / t.EXTENT, u2 = this.transform.calculatePosMatrix(o2.tileID.toUnwrapped()), d2 = l2.get("text-pitch-alignment") === "map", m2 = l2.get("text-rotation-alignment") === "map", _2 = bt(o2, 1, this.transform.zoom), p2 = rt(u2, d2, m2, this.transform, _2), f2 = null;
            if (d2) {
              let e3 = st(u2, d2, m2, this.transform, _2);
              f2 = t.multiply([], this.transform.labelPlaneMatrix, e3);
            }
            this.retainedQueryData[r2.bucketInstanceId] = new Ct(r2.bucketInstanceId, s2, r2.sourceLayerIndex, r2.index, o2.tileID);
            let g2 = { bucket: r2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: p2, labelToScreenMatrix: f2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(r2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(r2.sourceID) };
            if (a2)
              for (let t2 of r2.sortKeyRanges) {
                let { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3 } = t2;
                e2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3, parameters: g2 });
              }
            else
              e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: r2.symbolInstances.length, parameters: g2 });
          }
          attemptAnchorPlacement(t2, e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2, p2) {
            let f2 = [u2.textOffset0, u2.textOffset1], g2 = Dt(t2, i2, o2, f2, a2), x2 = this.collisionIndex.placeCollisionBox(zt(e2, g2.x, g2.y, r2, s2, this.transform.angle), h2, n2, l2, c2.predicate, p2);
            if ((!_2 || this.collisionIndex.placeCollisionBox(zt(_2, g2.x, g2.y, r2, s2, this.transform.angle), h2, n2, l2, c2.predicate, p2).box.length !== 0) && x2.box.length > 0) {
              let e3;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID].text && (e3 = this.prevPlacement.variableOffsets[u2.crossTileID].anchor), u2.crossTileID === 0)
                throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[u2.crossTileID] = { textOffset: f2, width: i2, height: o2, anchor: t2, textBoxScale: a2, prevAnchor: e3 }, this.markUsedJustification(d2, t2, u2, m2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, m2, u2), this.placedOrientations[u2.crossTileID] = m2), { shift: g2, placedGlyphBoxes: x2 };
            }
          }
          placeLayerBucketPart(e2, i2, o2) {
            let { bucket: a2, layout: r2, posMatrix: s2, textLabelPlaneMatrix: n2, labelToScreenMatrix: l2, textPixelRatio: c2, holdingForFade: h2, collisionBoxArray: u2, partiallyEvaluatedTextSize: d2, collisionGroup: m2 } = e2.parameters, _2 = r2.get("text-optional"), p2 = r2.get("icon-optional"), f2 = t.getOverlapMode(r2, "text-overlap", "text-allow-overlap"), g2 = f2 === "always", x2 = t.getOverlapMode(r2, "icon-overlap", "icon-allow-overlap"), v2 = x2 === "always", y2 = r2.get("text-rotation-alignment") === "map", b2 = r2.get("text-pitch-alignment") === "map", w2 = r2.get("icon-text-fit") !== "none", T2 = r2.get("symbol-z-order") === "viewport-y", E2 = g2 && (v2 || !a2.hasIconData() || p2), I2 = v2 && (g2 || !a2.hasTextData() || _2);
            !a2.collisionArrays && u2 && a2.deserializeCollisionBoxes(u2);
            let C2 = (e3, u3) => {
              if (i2[e3.crossTileID])
                return;
              if (h2)
                return void (this.placements[e3.crossTileID] = new Et(!1, !1, !1));
              let v3 = !1, T3 = !1, C3 = !0, S2 = null, D2 = { box: null, offscreen: null }, z2 = { box: null, offscreen: null }, P2 = null, M2 = null, A2 = null, L2 = 0, R2 = 0, k2 = 0;
              u3.textFeatureIndex ? L2 = u3.textFeatureIndex : e3.useRuntimeCollisionCircles && (L2 = e3.featureIndex), u3.verticalTextFeatureIndex && (R2 = u3.verticalTextFeatureIndex);
              let B2 = this.retainedQueryData[a2.bucketInstanceId].tileID, F2 = this.terrain ? (t2, e4) => this.terrain.getElevation(B2, t2, e4) : null;
              for (let t2 of ["textBox", "verticalTextBox", "iconBox", "verticalIconBox"]) {
                let e4 = u3[t2];
                e4 && (e4.elevation = F2 ? F2(e4.anchorPointX, e4.anchorPointY) : 0);
              }
              let O2 = u3.textBox;
              if (O2) {
                let i3 = (i4) => {
                  let o4 = t.WritingMode.horizontal;
                  if (a2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    let t2 = this.prevPlacement.placedOrientations[e3.crossTileID];
                    t2 && (this.placedOrientations[e3.crossTileID] = t2, o4 = t2, this.markUsedOrientation(a2, o4, e3));
                  }
                  return o4;
                }, o3 = (i4, o4) => {
                  if (a2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && u3.verticalTextBox) {
                    for (let e4 of a2.writingModes)
                      if (e4 === t.WritingMode.vertical ? (D2 = o4(), z2 = D2) : D2 = i4(), D2 && D2.box && D2.box.length)
                        break;
                  } else
                    D2 = i4();
                };
                if (r2.get("text-variable-anchor")) {
                  let n3 = r2.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[e3.crossTileID]) {
                    let t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                    n3.indexOf(t2.anchor) > 0 && (n3 = n3.filter((e4) => e4 !== t2.anchor), n3.unshift(t2.anchor));
                  }
                  let l3 = (t2, i4, o4) => {
                    let r3 = t2.x2 - t2.x1, l4 = t2.y2 - t2.y1, h4 = e3.textBoxScale, u4 = w2 && x2 === "never" ? i4 : null, d3 = { box: [], offscreen: !1 }, _3 = f2 !== "never" ? 2 * n3.length : n3.length;
                    for (let i5 = 0; i5 < _3; ++i5) {
                      let _4 = this.attemptAnchorPlacement(n3[i5 % n3.length], t2, r3, l4, h4, y2, b2, c2, s2, m2, i5 >= n3.length ? f2 : "never", e3, a2, o4, u4, F2);
                      if (_4 && (d3 = _4.placedGlyphBoxes, d3 && d3.box && d3.box.length)) {
                        v3 = !0, S2 = _4.shift;
                        break;
                      }
                    }
                    return d3;
                  };
                  o3(() => l3(O2, u3.iconBox, t.WritingMode.horizontal), () => {
                    let i4 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && !(D2 && D2.box && D2.box.length) && e3.numVerticalGlyphVertices > 0 && i4 ? l3(i4, u3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                  }), D2 && (v3 = D2.box, C3 = D2.offscreen);
                  let h3 = i3(D2 && D2.box);
                  if (!v3 && this.prevPlacement) {
                    let t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                    t2 && (this.variableOffsets[e3.crossTileID] = t2, this.markUsedJustification(a2, t2.anchor, e3, h3));
                  }
                } else {
                  let r3 = (t2, i4) => {
                    let o4 = this.collisionIndex.placeCollisionBox(t2, f2, c2, s2, m2.predicate, F2);
                    return o4 && o4.box && o4.box.length && (this.markUsedOrientation(a2, i4, e3), this.placedOrientations[e3.crossTileID] = i4), o4;
                  };
                  o3(() => r3(O2, t.WritingMode.horizontal), () => {
                    let i4 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? r3(i4, t.WritingMode.vertical) : { box: null, offscreen: null };
                  }), i3(D2 && D2.box && D2.box.length);
                }
              }
              if (P2 = D2, v3 = P2 && P2.box && P2.box.length > 0, C3 = P2 && P2.offscreen, e3.useRuntimeCollisionCircles) {
                let i3 = a2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), c3 = t.evaluateSizeForFeature(a2.textSizeData, d2, i3), h3 = r2.get("text-padding");
                M2 = this.collisionIndex.placeCollisionCircles(f2, i3, a2.lineVertexArray, a2.glyphOffsetArray, c3, s2, n2, l2, o2, b2, m2.predicate, e3.collisionCircleDiameter, h3, F2), M2.circles.length && M2.collisionDetected && !o2 && t.warnOnce("Collisions detected, but collision boxes are not shown"), v3 = g2 || M2.circles.length > 0 && !M2.collisionDetected, C3 = C3 && M2.offscreen;
              }
              if (u3.iconFeatureIndex && (k2 = u3.iconFeatureIndex), u3.iconBox) {
                let t2 = (t3) => {
                  let e4 = w2 && S2 ? zt(t3, S2.x, S2.y, y2, b2, this.transform.angle) : t3;
                  return this.collisionIndex.placeCollisionBox(e4, x2, c2, s2, m2.predicate, F2);
                };
                z2 && z2.box && z2.box.length && u3.verticalIconBox ? (A2 = t2(u3.verticalIconBox), T3 = A2.box.length > 0) : (A2 = t2(u3.iconBox), T3 = A2.box.length > 0), C3 = C3 && A2.offscreen;
              }
              let U2 = _2 || e3.numHorizontalGlyphVertices === 0 && e3.numVerticalGlyphVertices === 0, N2 = p2 || e3.numIconVertices === 0;
              if (U2 || N2 ? N2 ? U2 || (T3 = T3 && v3) : v3 = T3 && v3 : T3 = v3 = T3 && v3, v3 && P2 && P2.box && this.collisionIndex.insertCollisionBox(P2.box, f2, r2.get("text-ignore-placement"), a2.bucketInstanceId, z2 && z2.box && R2 ? R2 : L2, m2.ID), T3 && A2 && this.collisionIndex.insertCollisionBox(A2.box, x2, r2.get("icon-ignore-placement"), a2.bucketInstanceId, k2, m2.ID), M2 && (v3 && this.collisionIndex.insertCollisionCircles(M2.circles, f2, r2.get("text-ignore-placement"), a2.bucketInstanceId, L2, m2.ID), o2)) {
                let t2 = a2.bucketInstanceId, e4 = this.collisionCircleArrays[t2];
                e4 === void 0 && (e4 = this.collisionCircleArrays[t2] = new It());
                for (let t3 = 0; t3 < M2.circles.length; t3 += 4)
                  e4.circles.push(M2.circles[t3 + 0]), e4.circles.push(M2.circles[t3 + 1]), e4.circles.push(M2.circles[t3 + 2]), e4.circles.push(M2.collisionDetected ? 1 : 0);
              }
              if (e3.crossTileID === 0)
                throw new Error("symbolInstance.crossTileID can't be 0");
              if (a2.bucketInstanceId === 0)
                throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[e3.crossTileID] = new Et(v3 || E2, T3 || I2, C3 || a2.justReloaded), i2[e3.crossTileID] = !0;
            };
            if (T2) {
              if (e2.symbolInstanceStart !== 0)
                throw new Error("bucket.bucketInstanceId should be 0");
              let t2 = a2.getSortedSymbolIndexes(this.transform.angle);
              for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                let i3 = t2[e3];
                C2(a2.symbolInstances.get(i3), a2.collisionArrays[i3]);
              }
            } else
              for (let t2 = e2.symbolInstanceStart; t2 < e2.symbolInstanceEnd; t2++)
                C2(a2.symbolInstances.get(t2), a2.collisionArrays[t2]);
            if (o2 && a2.bucketInstanceId in this.collisionCircleArrays) {
              let e3 = this.collisionCircleArrays[a2.bucketInstanceId];
              t.invert(e3.invProjMatrix, s2), e3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            a2.justReloaded = !1;
          }
          markUsedJustification(e2, i2, o2, a2) {
            let r2;
            r2 = a2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i2)];
            let s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
            for (let t2 of s2)
              t2 >= 0 && (e2.text.placedSymbolArray.get(t2).crossTileID = r2 >= 0 && t2 !== r2 ? 0 : o2.crossTileID);
          }
          markUsedOrientation(e2, i2, o2) {
            let a2 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, r2 = i2 === t.WritingMode.vertical ? i2 : 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
            for (let t2 of s2)
              e2.text.placedSymbolArray.get(t2).placedOrientation = a2;
            o2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = r2);
          }
          commit(t2) {
            this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            let e2 = this.prevPlacement, i2 = !1;
            this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
            let o2 = e2 ? e2.symbolFadeChange(t2) : 1, a2 = e2 ? e2.opacities : {}, r2 = e2 ? e2.variableOffsets : {}, s2 = e2 ? e2.placedOrientations : {};
            for (let t3 in this.placements) {
              let e3 = this.placements[t3], r3 = a2[t3];
              r3 ? (this.opacities[t3] = new Tt(r3, o2, e3.text, e3.icon), i2 = i2 || e3.text !== r3.text.placed || e3.icon !== r3.icon.placed) : (this.opacities[t3] = new Tt(null, o2, e3.text, e3.icon, e3.skipFade), i2 = i2 || e3.text || e3.icon);
            }
            for (let t3 in a2) {
              let e3 = a2[t3];
              if (!this.opacities[t3]) {
                let a3 = new Tt(e3, o2, !1, !1);
                a3.isHidden() || (this.opacities[t3] = a3, i2 = i2 || e3.text.placed || e3.icon.placed);
              }
            }
            for (let t3 in r2)
              this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = r2[t3]);
            for (let t3 in s2)
              this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = s2[t3]);
            if (e2 && e2.lastPlacementChangeTime === void 0)
              throw new Error("Last placement time for previous placement is not defined");
            i2 ? this.lastPlacementChangeTime = t2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
          }
          updateLayerOpacities(t2, e2) {
            let i2 = {};
            for (let o2 of e2) {
              let e3 = o2.getBucket(t2);
              e3 && o2.latestFeatureIndex && t2.id === e3.layerIds[0] && this.updateBucketOpacities(e3, i2, o2.collisionBoxArray);
            }
          }
          updateBucketOpacities(e2, i2, o2) {
            e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
            let a2 = e2.layers[0].layout, r2 = new Tt(null, 0, !1, !1, !0), s2 = a2.get("text-allow-overlap"), n2 = a2.get("icon-allow-overlap"), l2 = a2.get("text-variable-anchor"), c2 = a2.get("text-rotation-alignment") === "map", h2 = a2.get("text-pitch-alignment") === "map", u2 = a2.get("icon-text-fit") !== "none", d2 = new Tt(null, 0, s2 && (n2 || !e2.hasIconData() || a2.get("icon-optional")), n2 && (s2 || !e2.hasTextData() || a2.get("text-optional")), !0);
            !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
            let m2 = (t2, e3, i3) => {
              for (let o3 = 0; o3 < e3 / 4; o3++)
                t2.opacityVertexArray.emplaceBack(i3);
            };
            for (let o3 = 0; o3 < e2.symbolInstances.length; o3++) {
              let a3 = e2.symbolInstances.get(o3), { numHorizontalGlyphVertices: s3, numVerticalGlyphVertices: n3, crossTileID: _2 } = a3, p2 = this.opacities[_2];
              i2[_2] ? p2 = r2 : p2 || (p2 = d2, this.opacities[_2] = p2), i2[_2] = !0;
              let f2 = a3.numIconVertices > 0, g2 = this.placedOrientations[a3.crossTileID], x2 = g2 === t.WritingMode.vertical, v2 = g2 === t.WritingMode.horizontal || g2 === t.WritingMode.horizontalOnly;
              if (s3 > 0 || n3 > 0) {
                let t2 = Ut(p2.text);
                m2(e2.text, s3, x2 ? Nt : t2), m2(e2.text, n3, v2 ? Nt : t2);
                let i3 = p2.text.isHidden();
                [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach((t3) => {
                  t3 >= 0 && (e2.text.placedSymbolArray.get(t3).hidden = i3 || x2 ? 1 : 0);
                }), a3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = i3 || v2 ? 1 : 0);
                let o4 = this.variableOffsets[a3.crossTileID];
                o4 && this.markUsedJustification(e2, o4.anchor, a3, g2);
                let r3 = this.placedOrientations[a3.crossTileID];
                r3 && (this.markUsedJustification(e2, "left", a3, r3), this.markUsedOrientation(e2, r3, a3));
              }
              if (f2) {
                let t2 = Ut(p2.icon), i3 = !(u2 && a3.verticalPlacedIconSymbolIndex && x2);
                a3.placedIconSymbolIndex >= 0 && (m2(e2.icon, a3.numIconVertices, i3 ? t2 : Nt), e2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = p2.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (m2(e2.icon, a3.numVerticalIconVertices, i3 ? Nt : t2), e2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = p2.icon.isHidden());
              }
              if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                let i3 = e2.collisionArrays[o3];
                if (i3) {
                  let o4 = new t.pointGeometry(0, 0);
                  if (i3.textBox || i3.verticalTextBox) {
                    let t2 = !0;
                    if (l2) {
                      let e3 = this.variableOffsets[_2];
                      e3 ? (o4 = Dt(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), c2 && o4._rotate(h2 ? this.transform.angle : -this.transform.angle)) : t2 = !1;
                    }
                    i3.textBox && Mt(e2.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || x2, o4.x, o4.y), i3.verticalTextBox && Mt(e2.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || v2, o4.x, o4.y);
                  }
                  let a4 = Boolean(!v2 && i3.verticalIconBox);
                  i3.iconBox && Mt(e2.iconCollisionBox.collisionVertexArray, p2.icon.placed, a4, u2 ? o4.x : 0, u2 ? o4.y : 0), i3.verticalIconBox && Mt(e2.iconCollisionBox.collisionVertexArray, p2.icon.placed, !a4, u2 ? o4.x : 0, u2 ? o4.y : 0);
                }
              }
            }
            if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4)
              throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
            if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4)
              throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
            if (e2.bucketInstanceId in this.collisionCircleArrays) {
              let t2 = this.collisionCircleArrays[e2.bucketInstanceId];
              e2.placementInvProjMatrix = t2.invProjMatrix, e2.placementViewportMatrix = t2.viewportMatrix, e2.collisionCircleArray = t2.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
            }
          }
          symbolFadeChange(t2) {
            return this.fadeDuration === 0 ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t2) {
            return Math.max(0, (this.transform.zoom - t2) / 1.5);
          }
          hasTransitions(t2) {
            return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t2, e2) {
            let i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
            return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function Mt(t2, e2, i2, o2, a2) {
          t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0);
        }
        let At = Math.pow(2, 25), Lt = Math.pow(2, 24), Rt = Math.pow(2, 17), kt = Math.pow(2, 16), Bt = Math.pow(2, 9), Ft = Math.pow(2, 8), Ot = Math.pow(2, 1);
        function Ut(t2) {
          if (t2.opacity === 0 && !t2.placed)
            return 0;
          if (t2.opacity === 1 && t2.placed)
            return 4294967295;
          let e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
          return i2 * At + e2 * Lt + i2 * Rt + e2 * kt + i2 * Bt + e2 * Ft + i2 * Ot + e2;
        }
        let Nt = 0;
        class Gt {
          constructor(t2) {
            this._sortAcrossTiles = t2.layout.get("symbol-z-order") !== "viewport-y" && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t2, e2, i2, o2, a2) {
            let r2 = this._bucketParts;
            for (; this._currentTileIndex < t2.length; )
              if (e2.getBucketParts(r2, o2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a2())
                return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, r2.sort((t3, e3) => t3.sortKey - e3.sortKey)); this._currentPartIndex < r2.length; )
              if (e2.placeLayerBucketPart(r2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, a2())
                return !0;
            return !1;
          }
        }
        class Zt {
          constructor(t2, e2, i2, o2, a2, r2, s2, n2) {
            this.placement = new Pt(t2, e2, r2, s2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = o2, this._showCollisionBoxes = a2, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e2, i2, o2) {
            let a2 = t.exported.now(), r2 = () => {
              let e3 = t.exported.now() - a2;
              return !this._forceFullPlacement && e3 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              let t2 = i2[e2[this._currentPlacementIndex]], a3 = this.placement.collisionIndex.transform.zoom;
              if (t2.type === "symbol" && (!t2.minzoom || t2.minzoom <= a3) && (!t2.maxzoom || t2.maxzoom > a3)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Gt(t2)), this._inProgressLayer.continuePlacement(o2[t2.source], this.placement, this._showCollisionBoxes, t2, r2))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(t2) {
            return this.placement.commit(t2), this.placement;
          }
        }
        let Vt = 512 / t.EXTENT / 2;
        class qt {
          constructor(t2, e2, i2) {
            this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
            for (let i3 = 0; i3 < e2.length; i3++) {
              let o2 = e2.get(i3), a2 = o2.key;
              this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, t2) });
            }
          }
          getScaledCoordinates(e2, i2) {
            let o2 = Vt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
            return { x: Math.floor((i2.canonical.x * t.EXTENT + e2.anchorX) * o2), y: Math.floor((i2.canonical.y * t.EXTENT + e2.anchorY) * o2) };
          }
          findMatches(t2, e2, i2) {
            let o2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
            for (let a2 = 0; a2 < t2.length; a2++) {
              let r2 = t2.get(a2);
              if (r2.crossTileID)
                continue;
              let s2 = this.indexedSymbolInstances[r2.key];
              if (!s2)
                continue;
              let n2 = this.getScaledCoordinates(r2, e2);
              for (let t3 of s2)
                if (Math.abs(t3.coord.x - n2.x) <= o2 && Math.abs(t3.coord.y - n2.y) <= o2 && !i2[t3.crossTileID]) {
                  i2[t3.crossTileID] = !0, r2.crossTileID = t3.crossTileID;
                  break;
                }
            }
          }
        }
        class jt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class $t {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t2) {
            let e2 = Math.round((t2 - this.lng) / 360);
            if (e2 !== 0)
              for (let t3 in this.indexes) {
                let i2 = this.indexes[t3], o2 = {};
                for (let t4 in i2) {
                  let a2 = i2[t4];
                  a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), o2[a2.tileID.key] = a2;
                }
                this.indexes[t3] = o2;
              }
            this.lng = t2;
          }
          addBucket(t2, e2, i2) {
            if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
              if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
                return !1;
              this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
            }
            for (let t3 = 0; t3 < e2.symbolInstances.length; t3++)
              e2.symbolInstances.get(t3).crossTileID = 0;
            this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
            let o2 = this.usedCrossTileIDs[t2.overscaledZ];
            for (let i3 in this.indexes) {
              let a2 = this.indexes[i3];
              if (Number(i3) > t2.overscaledZ)
                for (let i4 in a2) {
                  let r2 = a2[i4];
                  r2.tileID.isChildOf(t2) && r2.findMatches(e2.symbolInstances, t2, o2);
                }
              else {
                let r2 = a2[t2.scaledTo(Number(i3)).key];
                r2 && r2.findMatches(e2.symbolInstances, t2, o2);
              }
            }
            for (let t3 = 0; t3 < e2.symbolInstances.length; t3++) {
              let a2 = e2.symbolInstances.get(t3);
              a2.crossTileID || (a2.crossTileID = i2.generate(), o2[a2.crossTileID] = !0);
            }
            return this.indexes[t2.overscaledZ] === void 0 && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new qt(t2, e2.symbolInstances, e2.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(t2, e2) {
            for (let i2 in e2.indexedSymbolInstances)
              for (let o2 of e2.indexedSymbolInstances[i2])
                delete this.usedCrossTileIDs[t2][o2.crossTileID];
          }
          removeStaleBuckets(t2) {
            let e2 = !1;
            for (let i2 in this.indexes) {
              let o2 = this.indexes[i2];
              for (let a2 in o2)
                t2[o2[a2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[a2]), delete o2[a2], e2 = !0);
            }
            return e2;
          }
        }
        class Xt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new jt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t2, e2, i2) {
            let o2 = this.layerIndexes[t2.id];
            o2 === void 0 && (o2 = this.layerIndexes[t2.id] = new $t());
            let a2 = !1, r2 = {};
            o2.handleWrapJump(i2);
            for (let i3 of e2) {
              let e3 = i3.getBucket(t2);
              e3 && t2.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(i3.tileID, e3, this.crossTileIDs) && (a2 = !0), r2[e3.bucketInstanceId] = !0);
            }
            return o2.removeStaleBuckets(r2) && (a2 = !0), a2;
          }
          pruneUnusedLayers(t2) {
            let e2 = {};
            t2.forEach((t3) => {
              e2[t3] = !0;
            });
            for (let t3 in this.layerIndexes)
              e2[t3] || delete this.layerIndexes[t3];
          }
        }
        var Wt = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]);
        class Ht extends t.Evented {
          constructor(t2) {
            super(), this.sourceCache = t2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.renderHistory = [], this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, this.renderHistorySize = t2._cache.max, t2.usedForTerrain = !0, t2.tileSize = this.tileSize * 2 ** this.deltaZoom;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
            for (let t2 in this._tiles) {
              let e2 = this._tiles[t2];
              e2.textures.forEach((t3) => t3.destroy()), e2.textures = [];
            }
          }
          update(e2, i2) {
            this.sourceCache.update(e2, i2), this._renderableTilesKeys = [];
            for (let o2 of e2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: i2 }))
              this._renderableTilesKeys.push(o2.key), this._tiles[o2.key] || (o2.posMatrix = new Float64Array(16), t.ortho(o2.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), this._tiles[o2.key] = new k(o2, this.tileSize));
          }
          removeOutdated(t2) {
            let e2 = {};
            this.renderHistory = this.renderHistory.filter((t3, e3) => this.renderHistory.indexOf(t3) === e3).slice(0, this.renderHistorySize);
            for (let t3 of this._renderableTilesKeys)
              e2[t3] = !0;
            for (let t3 of this.renderHistory)
              e2[t3] = !0;
            for (let i2 in this._tiles)
              e2[i2] || (this._tiles[i2].clearTextures(t2), delete this._tiles[i2]);
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((t2) => this.getTileByID(t2));
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          getTerrainCoords(e2) {
            let i2 = {};
            for (let o2 of this._renderableTilesKeys) {
              let a2 = this._tiles[o2].tileID;
              if (a2.canonical.equals(e2.canonical)) {
                let a3 = e2.clone();
                a3.posMatrix = new Float64Array(16), t.ortho(a3.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), i2[o2] = a3;
              } else if (a2.canonical.isChildOf(e2.canonical)) {
                let r2 = e2.clone();
                r2.posMatrix = new Float64Array(16);
                let s2 = a2.canonical.z - e2.canonical.z, n2 = a2.canonical.x - (a2.canonical.x >> s2 << s2), l2 = a2.canonical.y - (a2.canonical.y >> s2 << s2), c2 = t.EXTENT >> s2;
                t.ortho(r2.posMatrix, 0, c2, 0, c2, 0, 1), t.translate(r2.posMatrix, r2.posMatrix, [-n2 * c2, -l2 * c2, 0]), i2[o2] = r2;
              } else if (e2.canonical.isChildOf(a2.canonical)) {
                let r2 = e2.clone();
                r2.posMatrix = new Float64Array(16);
                let s2 = e2.canonical.z - a2.canonical.z, n2 = e2.canonical.x - (e2.canonical.x >> s2 << s2), l2 = e2.canonical.y - (e2.canonical.y >> s2 << s2), c2 = t.EXTENT >> s2;
                t.ortho(r2.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), t.translate(r2.posMatrix, r2.posMatrix, [n2 * c2, l2 * c2, 0]), t.scale(r2.posMatrix, r2.posMatrix, [1 / 2 ** s2, 1 / 2 ** s2, 0]), i2[o2] = r2;
              }
            }
            return i2;
          }
          getSourceTile(t2, e2) {
            let i2 = this.sourceCache._source, o2 = t2.overscaledZ - this.deltaZoom;
            if (o2 > i2.maxzoom && (o2 = i2.maxzoom), o2 < i2.minzoom)
              return null;
            this._sourceTileCache[t2.key] || (this._sourceTileCache[t2.key] = t2.scaledTo(o2).key);
            let a2 = this.sourceCache.getTileByID(this._sourceTileCache[t2.key]);
            if ((!a2 || !a2.dem) && e2)
              for (; o2 >= i2.minzoom && (!a2 || !a2.dem); )
                a2 = this.sourceCache.getTileByID(t2.scaledTo(o2--).key);
            return a2;
          }
          tilesAfterTime(t2 = Date.now()) {
            return Object.values(this._tiles).filter((e2) => e2.timeLoaded >= t2);
          }
        }
        class Kt {
          constructor(t2, e2, i2) {
            this.style = t2, this.sourceCache = new Ht(e2), this.options = i2, this.exaggeration = typeof i2.exaggeration == "number" ? i2.exaggeration : 1, this.elevationOffset = typeof i2.elevationOffset == "number" ? i2.elevationOffset : 450, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024, this.clearRerenderCache();
          }
          getDEMElevation(e2, i2, o2, a2 = t.EXTENT) {
            if (!(i2 >= 0 && i2 < a2 && o2 >= 0 && o2 < a2))
              return this.elevationOffset;
            let r2 = 0, s2 = this.getTerrainData(e2);
            if (s2.tile && s2.tile.dem) {
              let e3 = t.transformMat4$1([], [i2 / a2 * t.EXTENT, o2 / a2 * t.EXTENT], s2.u_terrain_matrix), n2 = [e3[0] * s2.tile.dem.dim, e3[1] * s2.tile.dem.dim], l2 = [Math.floor(n2[0]), Math.floor(n2[1])], c2 = s2.tile.dem.get(l2[0], l2[1]), h2 = s2.tile.dem.get(l2[0], l2[1] + 1), u2 = s2.tile.dem.get(l2[0] + 1, l2[1]), d2 = s2.tile.dem.get(l2[0] + 1, l2[1] + 1);
              r2 = t.number(t.number(c2, h2, n2[0] - l2[0]), t.number(u2, d2, n2[0] - l2[0]), n2[1] - l2[1]);
            }
            return r2;
          }
          rememberForRerender(t2, e2) {
            for (let i2 in this.sourceCache._tiles) {
              let o2 = this.sourceCache._tiles[i2];
              (o2.tileID.equals(e2) || o2.tileID.isChildOf(e2)) && (t2 === this.sourceCache.sourceCache.id && (o2.timeLoaded = Date.now()), this._rerender[t2] = this._rerender[t2] || {}, this._rerender[t2][o2.tileID.key] = !0);
            }
          }
          needsRerender(t2, e2) {
            return this._rerender[t2] && this._rerender[t2][e2.key];
          }
          clearRerenderCache() {
            this._rerender = {};
          }
          getElevation(e2, i2, o2, a2 = t.EXTENT) {
            return (this.getDEMElevation(e2, i2, o2, a2) + this.elevationOffset) * this.exaggeration;
          }
          getTerrainData(e2) {
            if (!this._emptyDemTexture) {
              let e3 = this.style.map.painter.context, i3 = new t.RGBAImage({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new l(e3, i3, e3.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new l(e3, new t.RGBAImage({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.identity([]);
            }
            let i2 = this.sourceCache.getSourceTile(e2, !0);
            if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
              let t2 = this.style.map.painter.context;
              i2.demTexture = this.style.map.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: !1 }) : i2.demTexture = new l(t2, i2.dem.getPixels(), t2.gl.RGBA, { premultiply: !1 }), i2.demTexture.bind(t2.gl.NEAREST, t2.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = !1;
            }
            let o2 = i2 && i2 + i2.tileID.key + e2.key;
            if (o2 && !this._demMatrixCache[o2]) {
              let o3 = this.sourceCache.sourceCache._source.maxzoom, a2 = e2.canonical.z - i2.tileID.canonical.z;
              e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= o3 ? a2 = e2.canonical.z - o3 : t.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              let r2 = e2.canonical.x - (e2.canonical.x >> a2 << a2), s2 = e2.canonical.y - (e2.canonical.y >> a2 << a2), n2 = t.fromScaling(new Float64Array(16), [1 / (t.EXTENT << a2), 1 / (t.EXTENT << a2), 0]);
              t.translate(n2, n2, [r2 * t.EXTENT, s2 * t.EXTENT, 0]), this._demMatrixCache[e2.key] = { matrix: n2, coord: e2 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: o2 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_offset: this.elevationOffset, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
          }
          getRTTFramebuffer() {
            let t2 = this.style.map.painter;
            if (!this._rttFramebuffer) {
              let e2 = this.sourceCache.tileSize * this.qualityFactor;
              this._rttFramebuffer = t2.context.createFramebuffer(e2, e2, !0), this._rttFramebuffer.depthAttachment.set(t2.context.createRenderbuffer(t2.context.gl.DEPTH_COMPONENT16, e2, e2));
            }
            return this._rttFramebuffer;
          }
          getFramebuffer(t2) {
            let e2 = this.style.map.painter, i2 = e2.width / devicePixelRatio, o2 = e2.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === i2 && this._fbo.height === o2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new l(e2.context, { width: i2, height: o2, data: null }, e2.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new l(e2.context, { width: i2, height: o2, data: null }, e2.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i2, o2, !0), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i2, o2))), this._fbo.colorAttachment.set(t2 === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            let e2 = this.style.map.painter.context;
            if (this._coordsTexture)
              return this._coordsTexture;
            let i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let t2 = 0, e3 = 0; t2 < this._coordsTextureSize; t2++)
              for (let o3 = 0; o3 < this._coordsTextureSize; o3++, e3 += 4)
                i2[e3 + 0] = 255 & o3, i2[e3 + 1] = 255 & t2, i2[e3 + 2] = o3 >> 8 << 4 | t2 >> 8, i2[e3 + 3] = 0;
            let o2 = new t.RGBAImage({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), a2 = new l(e2, o2, e2.gl.RGBA, { premultiply: !1 });
            return a2.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = a2, a2;
          }
          pointCoordinate(e2) {
            let i2 = new Uint8Array(4), o2 = this.style.map.painter, a2 = o2.context, r2 = a2.gl;
            a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r2.readPixels(e2.x, o2.height / devicePixelRatio - e2.y - 1, 1, 1, r2.RGBA, r2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
            let s2 = i2[0] + (i2[2] >> 4 << 8), n2 = i2[1] + ((15 & i2[2]) << 8), l2 = this.coordsIndex[255 - i2[3]], c2 = l2 && this.sourceCache.getTileByID(l2);
            if (!c2)
              return null;
            let h2 = this._coordsTextureSize, u2 = (1 << c2.tileID.canonical.z) * h2;
            return new t.MercatorCoordinate((c2.tileID.canonical.x * h2 + s2) / u2, (c2.tileID.canonical.y * h2 + n2) / u2, this.getElevation(c2.tileID, s2, n2, h2));
          }
          getTerrainMesh() {
            if (this._mesh)
              return this._mesh;
            let e2 = this.style.map.painter.context, i2 = new t.PosArray(), o2 = new t.TriangleIndexArray(), a2 = this.meshSize, r2 = t.EXTENT / a2, s2 = a2 * a2;
            for (let t2 = 0; t2 <= a2; t2++)
              for (let e3 = 0; e3 <= a2; e3++)
                i2.emplaceBack(e3 * r2, t2 * r2);
            for (let t2 = 0; t2 < s2; t2 += a2 + 1)
              for (let e3 = 0; e3 < a2; e3++)
                o2.emplaceBack(e3 + t2, a2 + e3 + t2 + 1, a2 + e3 + t2 + 2), o2.emplaceBack(e3 + t2, a2 + e3 + t2 + 2, e3 + t2 + 1);
            return this._mesh = { indexBuffer: e2.createIndexBuffer(o2), vertexBuffer: e2.createVertexBuffer(i2, Wt.members), segments: t.SegmentVector.simpleSegment(0, 0, i2.length, o2.length) }, this._mesh;
          }
          getMinMaxElevation(t2) {
            let e2 = this.getTerrainData(t2).tile, i2 = { minElevation: null, maxElevation: null };
            return e2 && e2.dem && (i2.minElevation = (e2.dem.min + this.elevationOffset) * this.exaggeration, i2.maxElevation = (e2.dem.max + this.elevationOffset) * this.exaggeration), i2;
          }
        }
        let Yt = (e2, i2) => t.emitValidationErrors(e2, i2 && i2.filter((t2) => t2.identifier !== "source.canvas")), Jt = t.pick(W, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Qt = t.pick(W, ["setCenter", "setZoom", "setBearing", "setPitch"]), te = function() {
          let e2 = {}, i2 = t.spec.$version;
          for (let o2 in t.spec.$root) {
            let a2 = t.spec.$root[o2];
            if (a2.required) {
              let t2 = null;
              t2 = o2 === "version" ? i2 : a2.type === "array" ? [] : {}, t2 != null && (e2[o2] = t2);
            }
          }
          return e2;
        }();
        class ee extends t.Evented {
          constructor(e2, i2 = {}) {
            super(), this.map = e2, this.dispatcher = new v(j(), this), this.imageManager = new h(), this.imageManager.setEventedParent(this), this.glyphManager = new _(e2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new x(256, 512), this.crossTileSymbolIndex = new Xt(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
            let o2 = this;
            this._rtlTextPluginCallback = ee.registerForPluginStateChange((e3) => {
              o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, (e4, i3) => {
                if (t.triggerPluginCompletionEvent(e4), i3 && i3.every((t2) => t2))
                  for (let t2 in o2.sourceCaches)
                    o2.sourceCaches[t2].reload();
              });
            }), this.on("data", (t2) => {
              if (t2.dataType !== "source" || t2.sourceDataType !== "metadata")
                return;
              let e3 = this.sourceCaches[t2.sourceId];
              if (!e3)
                return;
              let i3 = e3.getSource();
              if (i3 && i3.vectorLayerIds)
                for (let t3 in this._layers) {
                  let e4 = this._layers[t3];
                  e4.source === i3.id && this._validateLayer(e4);
                }
            });
          }
          loadURL(e2, i2 = {}) {
            this.fire(new t.Event("dataloading", { dataType: "style" }));
            let o2 = typeof i2.validate != "boolean" || i2.validate, a2 = this.map._requestManager.transformRequest(e2, t.ResourceType.Style);
            this._request = t.getJSON(a2, (e3, i3) => {
              this._request = null, e3 ? this.fire(new t.ErrorEvent(e3)) : i3 && this._load(i3, o2);
            });
          }
          loadJSON(e2, i2 = {}) {
            this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.exported.frame(() => {
              this._request = null, this._load(e2, i2.validate !== !1);
            });
          }
          loadEmpty() {
            this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(te, !1);
          }
          _load(e2, i2) {
            if (i2 && Yt(this, t.validateStyle(e2)))
              return;
            this._loaded = !0, this.stylesheet = e2;
            for (let t2 in e2.sources)
              this.addSource(t2, e2.sources[t2], { validate: !1 });
            e2.sprite ? this._loadSprite(e2.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e2.glyphs);
            let o2 = X(this.stylesheet.layers);
            this._order = o2.map((t2) => t2.id), this._layers = {}, this._serializedLayers = {};
            for (let e3 of o2)
              e3 = t.createStyleLayer(e3), e3.setEventedParent(this, { layer: { id: e3.id } }), this._layers[e3.id] = e3, this._serializedLayers[e3.id] = e3.serialize();
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new g(this.stylesheet.light), this.setTerrain(this.stylesheet.terrain), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
          }
          _loadSprite(e2) {
            this._spriteRequest = function(e3, i2, o2, a2) {
              let r2, s2, n2, l2 = o2 > 1 ? "@2x" : "", c2 = t.getJSON(i2.transformRequest(i2.normalizeSpriteURL(e3, l2, ".json"), t.ResourceType.SpriteJSON), (t2, e4) => {
                c2 = null, n2 || (n2 = t2, r2 = e4, u2());
              }), h2 = t.getImage(i2.transformRequest(i2.normalizeSpriteURL(e3, l2, ".png"), t.ResourceType.SpriteImage), (t2, e4) => {
                h2 = null, n2 || (n2 = t2, s2 = e4, u2());
              });
              function u2() {
                if (n2)
                  a2(n2);
                else if (r2 && s2) {
                  let e4 = t.exported.getImageData(s2), i3 = {};
                  for (let o3 in r2) {
                    let { width: a3, height: s3, x: n3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u3, stretchY: d2, content: m2 } = r2[o3], _2 = new t.RGBAImage({ width: a3, height: s3 });
                    t.RGBAImage.copy(e4, _2, { x: n3, y: l3 }, { x: 0, y: 0 }, { width: a3, height: s3 }), i3[o3] = { data: _2, pixelRatio: h3, sdf: c3, stretchX: u3, stretchY: d2, content: m2 };
                  }
                  a2(null, i3);
                }
              }
              return { cancel() {
                c2 && (c2.cancel(), c2 = null), h2 && (h2.cancel(), h2 = null);
              } };
            }(e2, this.map._requestManager, this.map.getPixelRatio(), (e3, i2) => {
              if (this._spriteRequest = null, e3)
                this.fire(new t.ErrorEvent(e3));
              else if (i2)
                for (let t2 in i2)
                  this.imageManager.addImage(t2, i2[t2]);
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
            });
          }
          _validateLayer(e2) {
            let i2 = this.sourceCaches[e2.source];
            if (!i2)
              return;
            let o2 = e2.sourceLayer;
            if (!o2)
              return;
            let a2 = i2.getSource();
            (a2.type === "geojson" || a2.vectorLayerIds && a2.vectorLayerIds.indexOf(o2) === -1) && this.fire(new t.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${a2.id}" as specified by style layer "${e2.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length)
              return !1;
            for (let t2 in this.sourceCaches)
              if (!this.sourceCaches[t2].loaded())
                return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeLayers(t2) {
            let e2 = [];
            for (let i2 of t2) {
              let t3 = this._layers[i2];
              t3.type !== "custom" && e2.push(t3.serialize());
            }
            return e2;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return !0;
            for (let t2 in this.sourceCaches)
              if (this.sourceCaches[t2].hasTransition())
                return !0;
            for (let t2 in this._layers)
              if (this._layers[t2].hasTransition())
                return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading.");
          }
          update(e2) {
            if (!this._loaded)
              return;
            let i2 = this._changed;
            if (this._changed) {
              let t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
              (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
              for (let t3 in this._updatedSources) {
                let e3 = this._updatedSources[t3];
                if (e3 === "reload")
                  this._reloadSource(t3);
                else {
                  if (e3 !== "clear")
                    throw new Error(`Invalid action ${e3}`);
                  this._clearSource(t3);
                }
              }
              this._updateTilesForChangedImages();
              for (let t3 in this._updatedPaintProps)
                this._layers[t3].updateTransitions(e2);
              this.light.updateTransitions(e2), this._resetUpdates();
            }
            let o2 = {};
            for (let t2 in this.sourceCaches) {
              let e3 = this.sourceCaches[t2];
              o2[t2] = e3.used, e3.used = !1;
            }
            for (let t2 of this._order) {
              let i3 = this._layers[t2];
              i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom) && i3.source && (this.sourceCaches[i3.source].used = !0);
            }
            for (let e3 in o2) {
              let i3 = this.sourceCaches[e3];
              o2[e3] !== i3.used && i3.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
            }
            this.light.recalculate(e2), this.z = e2.zoom, i2 && this.fire(new t.Event("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            let t2 = Object.keys(this._changedImages);
            if (t2.length) {
              for (let e2 in this.sourceCaches)
                this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t2);
              this._changedImages = {};
            }
          }
          _updateWorkerLayers(t2, e2) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e2 });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }
          setTerrain(e2) {
            if (this._checkLoaded(), this._terrainDataCallback && this.off("data", this._terrainDataCallback), this._terrainfreezeElevationCallback && this.map.off("freezeElevation", this._terrainfreezeElevationCallback), e2) {
              let t2 = this.sourceCaches[e2.source];
              if (!t2)
                throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
              this.terrain = new Kt(this, t2, e2), this.map.transform.updateElevation(this.terrain), this._terrainfreezeElevationCallback = (t3) => {
                t3.freeze ? this.map.transform.freezeElevation = !0 : (this.map.transform.freezeElevation = !1, this.map.transform.recalculateZoom(this.terrain));
              }, this._terrainDataCallback = (t3) => {
                t3.tile && (t3.sourceId === e2.source ? (this.map.transform.updateElevation(this.terrain), this.terrain.rememberForRerender(t3.sourceId, t3.tile.tileID)) : t3.source.type === "geojson" && this.terrain.rememberForRerender(t3.sourceId, t3.tile.tileID));
              }, this.on("data", this._terrainDataCallback), this.map.on("freezeElevation", this._terrainfreezeElevationCallback);
            } else
              this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.map.transform.updateElevation(this.terrain);
            this.map.fire(new t.Event("terrain", { terrain: e2 }));
          }
          setState(e2) {
            if (this._checkLoaded(), Yt(this, t.validateStyle(e2)))
              return !1;
            (e2 = t.clone$1(e2)).layers = X(e2.layers);
            let i2 = function(t2, e3) {
              if (!t2)
                return [{ command: W.setStyle, args: [e3] }];
              let i3 = [];
              try {
                if (!a(t2.version, e3.version))
                  return [{ command: W.setStyle, args: [e3] }];
                a(t2.center, e3.center) || i3.push({ command: W.setCenter, args: [e3.center] }), a(t2.zoom, e3.zoom) || i3.push({ command: W.setZoom, args: [e3.zoom] }), a(t2.bearing, e3.bearing) || i3.push({ command: W.setBearing, args: [e3.bearing] }), a(t2.pitch, e3.pitch) || i3.push({ command: W.setPitch, args: [e3.pitch] }), a(t2.sprite, e3.sprite) || i3.push({ command: W.setSprite, args: [e3.sprite] }), a(t2.glyphs, e3.glyphs) || i3.push({ command: W.setGlyphs, args: [e3.glyphs] }), a(t2.transition, e3.transition) || i3.push({ command: W.setTransition, args: [e3.transition] }), a(t2.light, e3.light) || i3.push({ command: W.setLight, args: [e3.light] });
                let o3 = {}, r2 = [];
                (function(t3, e4, i4, o4) {
                  let r3;
                  for (r3 in e4 = e4 || {}, t3 = t3 || {})
                    Object.prototype.hasOwnProperty.call(t3, r3) && (Object.prototype.hasOwnProperty.call(e4, r3) || K(r3, i4, o4));
                  for (r3 in e4)
                    Object.prototype.hasOwnProperty.call(e4, r3) && (Object.prototype.hasOwnProperty.call(t3, r3) ? a(t3[r3], e4[r3]) || (t3[r3].type === "geojson" && e4[r3].type === "geojson" && J(t3, e4, r3) ? i4.push({ command: W.setGeoJSONSourceData, args: [r3, e4[r3].data] }) : Y(r3, e4, i4, o4)) : H(r3, e4, i4));
                })(t2.sources, e3.sources, r2, o3);
                let s2 = [];
                t2.layers && t2.layers.forEach((t3) => {
                  o3[t3.source] ? i3.push({ command: W.removeLayer, args: [t3.id] }) : s2.push(t3);
                }), i3 = i3.concat(r2), function(t3, e4, i4) {
                  e4 = e4 || [];
                  let o4 = (t3 = t3 || []).map(tt), r3 = e4.map(tt), s3 = t3.reduce(et, {}), n2 = e4.reduce(et, {}), l2 = o4.slice(), c2 = /* @__PURE__ */ Object.create(null), h2, u2, d2, m2, _2, p2, f2;
                  for (h2 = 0, u2 = 0; h2 < o4.length; h2++)
                    d2 = o4[h2], Object.prototype.hasOwnProperty.call(n2, d2) ? u2++ : (i4.push({ command: W.removeLayer, args: [d2] }), l2.splice(l2.indexOf(d2, u2), 1));
                  for (h2 = 0, u2 = 0; h2 < r3.length; h2++)
                    d2 = r3[r3.length - 1 - h2], l2[l2.length - 1 - h2] !== d2 && (Object.prototype.hasOwnProperty.call(s3, d2) ? (i4.push({ command: W.removeLayer, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - u2), 1)) : u2++, p2 = l2[l2.length - h2], i4.push({ command: W.addLayer, args: [n2[d2], p2] }), l2.splice(l2.length - h2, 0, d2), c2[d2] = !0);
                  for (h2 = 0; h2 < r3.length; h2++)
                    if (d2 = r3[h2], m2 = s3[d2], _2 = n2[d2], !c2[d2] && !a(m2, _2))
                      if (a(m2.source, _2.source) && a(m2["source-layer"], _2["source-layer"]) && a(m2.type, _2.type)) {
                        for (f2 in Q(m2.layout, _2.layout, i4, d2, null, W.setLayoutProperty), Q(m2.paint, _2.paint, i4, d2, null, W.setPaintProperty), a(m2.filter, _2.filter) || i4.push({ command: W.setFilter, args: [d2, _2.filter] }), a(m2.minzoom, _2.minzoom) && a(m2.maxzoom, _2.maxzoom) || i4.push({ command: W.setLayerZoomRange, args: [d2, _2.minzoom, _2.maxzoom] }), m2)
                          Object.prototype.hasOwnProperty.call(m2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Q(m2[f2], _2[f2], i4, d2, f2.slice(6), W.setPaintProperty) : a(m2[f2], _2[f2]) || i4.push({ command: W.setLayerProperty, args: [d2, f2, _2[f2]] }));
                        for (f2 in _2)
                          Object.prototype.hasOwnProperty.call(_2, f2) && !Object.prototype.hasOwnProperty.call(m2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Q(m2[f2], _2[f2], i4, d2, f2.slice(6), W.setPaintProperty) : a(m2[f2], _2[f2]) || i4.push({ command: W.setLayerProperty, args: [d2, f2, _2[f2]] }));
                      } else
                        i4.push({ command: W.removeLayer, args: [d2] }), p2 = l2[l2.lastIndexOf(d2) + 1], i4.push({ command: W.addLayer, args: [_2, p2] });
                }(s2, e3.layers, i3);
              } catch (t3) {
                console.warn("Unable to compute style diff:", t3), i3 = [{ command: W.setStyle, args: [e3] }];
              }
              return i3;
            }(this.serialize(), e2).filter((t2) => !(t2.command in Qt));
            if (i2.length === 0)
              return !1;
            let o2 = i2.filter((t2) => !(t2.command in Jt));
            if (o2.length > 0)
              throw new Error(`Unimplemented: ${o2.map((t2) => t2.command).join(", ")}.`);
            return i2.forEach((t2) => {
              t2.command !== "setTransition" && this[t2.command].apply(this, t2.args);
            }), this.stylesheet = e2, !0;
          }
          addImage(e2, i2) {
            if (this.getImage(e2))
              return this.fire(new t.ErrorEvent(new Error(`An image named "${e2}" already exists.`)));
            this.imageManager.addImage(e2, i2), this._afterImageUpdated(e2);
          }
          updateImage(t2, e2) {
            this.imageManager.updateImage(t2, e2);
          }
          getImage(t2) {
            return this.imageManager.getImage(t2);
          }
          removeImage(e2) {
            if (!this.getImage(e2))
              return this.fire(new t.ErrorEvent(new Error(`An image named "${e2}" does not exist.`)));
            this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
          }
          _afterImageUpdated(e2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e2, i2, o2 = {}) {
            if (this._checkLoaded(), this.sourceCaches[e2] !== void 0)
              throw new Error(`Source "${e2}" already exists.`);
            if (!i2.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.validateStyle.source, `sources.${e2}`, i2, null, o2))
              return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = !0);
            let a2 = this.sourceCaches[e2] = new O(e2, i2, this.dispatcher);
            a2.style = this, a2.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: a2.serialize(), sourceId: e2 })), a2.onAdd(this.map), this._changed = !0;
          }
          removeSource(e2) {
            if (this._checkLoaded(), this.sourceCaches[e2] === void 0)
              throw new Error("There is no source with this ID");
            for (let i3 in this._layers)
              if (this._layers[i3].source === e2)
                return this.fire(new t.ErrorEvent(new Error(`Source "${e2}" cannot be removed while layer "${i3}" is using it.`)));
            let i2 = this.sourceCaches[e2];
            delete this.sourceCaches[e2], delete this._updatedSources[e2], i2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(t2, e2) {
            if (this._checkLoaded(), this.sourceCaches[t2] === void 0)
              throw new Error(`There is no source with this ID=${t2}`);
            let i2 = this.sourceCaches[t2].getSource();
            if (i2.type !== "geojson")
              throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
            i2.setData(e2), this._changed = !0;
          }
          getSource(t2) {
            return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
          }
          addLayer(e2, i2, o2 = {}) {
            this._checkLoaded();
            let a2 = e2.id;
            if (this.getLayer(a2))
              return void this.fire(new t.ErrorEvent(new Error(`Layer "${a2}" already exists on this map.`)));
            let r2;
            if (e2.type === "custom") {
              if (Yt(this, t.validateCustomStyleLayer(e2)))
                return;
              r2 = t.createStyleLayer(e2);
            } else {
              if (typeof e2.source == "object" && (this.addSource(a2, e2.source), e2 = t.clone$1(e2), e2 = t.extend(e2, { source: a2 })), this._validate(t.validateStyle.layer, `layers.${a2}`, e2, { arrayIndex: -1 }, o2))
                return;
              r2 = t.createStyleLayer(e2), this._validateLayer(r2), r2.setEventedParent(this, { layer: { id: a2 } }), this._serializedLayers[r2.id] = r2.serialize();
            }
            let s2 = i2 ? this._order.indexOf(i2) : this._order.length;
            if (i2 && s2 === -1)
              this.fire(new t.ErrorEvent(new Error(`Cannot add layer "${a2}" before non-existing layer "${i2}".`)));
            else {
              if (this._order.splice(s2, 0, a2), this._layerOrderChanged = !0, this._layers[a2] = r2, this._removedLayers[a2] && r2.source && r2.type !== "custom") {
                let t2 = this._removedLayers[a2];
                delete this._removedLayers[a2], t2.type !== r2.type ? this._updatedSources[r2.source] = "clear" : (this._updatedSources[r2.source] = "reload", this.sourceCaches[r2.source].pause());
              }
              this._updateLayer(r2), r2.onAdd && r2.onAdd(this.map);
            }
          }
          moveLayer(e2, i2) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e2])
              return void this.fire(new t.ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
            if (e2 === i2)
              return;
            let o2 = this._order.indexOf(e2);
            this._order.splice(o2, 1);
            let a2 = i2 ? this._order.indexOf(i2) : this._order.length;
            i2 && a2 === -1 ? this.fire(new t.ErrorEvent(new Error(`Cannot move layer "${e2}" before non-existing layer "${i2}".`))) : (this._order.splice(a2, 0, e2), this._layerOrderChanged = !0);
          }
          removeLayer(e2) {
            this._checkLoaded();
            let i2 = this._layers[e2];
            if (!i2)
              return void this.fire(new t.ErrorEvent(new Error(`Cannot remove non-existing layer "${e2}".`)));
            i2.setEventedParent(null);
            let o2 = this._order.indexOf(e2);
            this._order.splice(o2, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e2] = i2, delete this._layers[e2], delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i2.onRemove && i2.onRemove(this.map);
          }
          getLayer(t2) {
            return this._layers[t2];
          }
          hasLayer(t2) {
            return t2 in this._layers;
          }
          setLayerZoomRange(e2, i2, o2) {
            this._checkLoaded();
            let a2 = this.getLayer(e2);
            a2 ? a2.minzoom === i2 && a2.maxzoom === o2 || (i2 != null && (a2.minzoom = i2), o2 != null && (a2.maxzoom = o2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
          }
          setFilter(e2, i2, o2 = {}) {
            this._checkLoaded();
            let r2 = this.getLayer(e2);
            if (r2) {
              if (!a(r2.filter, i2))
                return i2 == null ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(t.validateStyle.filter, `layers.${r2.id}.filter`, i2, null, o2) || (r2.filter = t.clone$1(i2), this._updateLayer(r2)));
            } else
              this.fire(new t.ErrorEvent(new Error(`Cannot filter non-existing layer "${e2}".`)));
          }
          getFilter(e2) {
            return t.clone$1(this.getLayer(e2).filter);
          }
          setLayoutProperty(e2, i2, o2, r2 = {}) {
            this._checkLoaded();
            let s2 = this.getLayer(e2);
            s2 ? a(s2.getLayoutProperty(i2), o2) || (s2.setLayoutProperty(i2, o2, r2), this._updateLayer(s2)) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          getLayoutProperty(e2, i2) {
            let o2 = this.getLayer(e2);
            if (o2)
              return o2.getLayoutProperty(i2);
            this.fire(new t.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e2}".`)));
          }
          setPaintProperty(e2, i2, o2, r2 = {}) {
            this._checkLoaded();
            let s2 = this.getLayer(e2);
            s2 ? a(s2.getPaintProperty(i2), o2) || (s2.setPaintProperty(i2, o2, r2) && this._updateLayer(s2), this._changed = !0, this._updatedPaintProps[e2] = !0) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          getPaintProperty(t2, e2) {
            return this.getLayer(t2).getPaintProperty(e2);
          }
          setFeatureState(e2, i2) {
            this._checkLoaded();
            let o2 = e2.source, a2 = e2.sourceLayer, r2 = this.sourceCaches[o2];
            if (r2 === void 0)
              return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            let s2 = r2.getSource().type;
            s2 === "geojson" && a2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : s2 !== "vector" || a2 ? (e2.id === void 0 && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r2.setFeatureState(a2, e2.id, i2)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e2, i2) {
            this._checkLoaded();
            let o2 = e2.source, a2 = this.sourceCaches[o2];
            if (a2 === void 0)
              return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            let r2 = a2.getSource().type, s2 = r2 === "vector" ? e2.sourceLayer : void 0;
            r2 !== "vector" || s2 ? i2 && typeof e2.id != "string" && typeof e2.id != "number" ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : a2.removeFeatureState(s2, e2.id, i2) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e2) {
            this._checkLoaded();
            let i2 = e2.source, o2 = e2.sourceLayer, a2 = this.sourceCaches[i2];
            if (a2 !== void 0)
              return a2.getSource().type !== "vector" || o2 ? (e2.id === void 0 && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.getFeatureState(o2, e2.id)) : void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new t.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
          }
          getTransition() {
            return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, (t2) => t2.serialize()), layers: this._serializeLayers(this._order) }, (t2) => t2 !== void 0);
          }
          _updateLayer(t2) {
            this._updatedLayers[t2.id] = !0, t2.source && !this._updatedSources[t2.source] && this.sourceCaches[t2.source].getSource().type !== "raster" && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(t2) {
            let e2 = (t3) => this._layers[t3].type === "fill-extrusion", i2 = {}, o2 = [];
            for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
              let r2 = this._order[a3];
              if (e2(r2)) {
                i2[r2] = a3;
                for (let e3 of t2) {
                  let t3 = e3[r2];
                  if (t3)
                    for (let e4 of t3)
                      o2.push(e4);
                }
              }
            }
            o2.sort((t3, e3) => e3.intersectionZ - t3.intersectionZ);
            let a2 = [];
            for (let r2 = this._order.length - 1; r2 >= 0; r2--) {
              let s2 = this._order[r2];
              if (e2(s2))
                for (let t3 = o2.length - 1; t3 >= 0; t3--) {
                  let e3 = o2[t3].feature;
                  if (i2[e3.layer.id] < r2)
                    break;
                  a2.push(e3), o2.pop();
                }
              else
                for (let e3 of t2) {
                  let t3 = e3[s2];
                  if (t3)
                    for (let e4 of t3)
                      a2.push(e4.feature);
                }
            }
            return a2;
          }
          queryRenderedFeatures(e2, i2, o2) {
            i2 && i2.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
            let a2 = {};
            if (i2 && i2.layers) {
              if (!Array.isArray(i2.layers))
                return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (let e3 of i2.layers) {
                let i3 = this._layers[e3];
                if (!i3)
                  return this.fire(new t.ErrorEvent(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
                a2[i3.source] = !0;
              }
            }
            let r2 = [];
            i2.availableImages = this._availableImages;
            for (let t2 in this.sourceCaches)
              i2.layers && !a2[t2] || r2.push(L(this.sourceCaches[t2], this._layers, this._serializedLayers, e2, i2, o2));
            return this.placement && r2.push(function(t2, e3, i3, o3, a3, r3, s2) {
              let n2 = {}, l2 = r3.queryRenderedSymbols(o3), c2 = [];
              for (let t3 of Object.keys(l2).map(Number))
                c2.push(s2[t3]);
              c2.sort(R);
              for (let i4 of c2) {
                let o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e3, i4.bucketIndex, i4.sourceLayerIndex, a3.filter, a3.layers, a3.availableImages, t2);
                for (let t3 in o4) {
                  let e4 = n2[t3] = n2[t3] || [], a4 = o4[t3];
                  a4.sort((t4, e5) => {
                    let o5 = i4.featureSortOrder;
                    if (o5) {
                      let i5 = o5.indexOf(t4.featureIndex);
                      return o5.indexOf(e5.featureIndex) - i5;
                    }
                    return e5.featureIndex - t4.featureIndex;
                  });
                  for (let t4 of a4)
                    e4.push(t4);
                }
              }
              for (let e4 in n2)
                n2[e4].forEach((o4) => {
                  let a4 = o4.feature, r4 = i3[t2[e4].source].getFeatureState(a4.layer["source-layer"], a4.id);
                  a4.source = a4.layer.source, a4.layer["source-layer"] && (a4.sourceLayer = a4.layer["source-layer"]), a4.state = r4;
                });
              return n2;
            }(this._layers, this._serializedLayers, this.sourceCaches, e2, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(r2);
          }
          querySourceFeatures(e2, i2) {
            i2 && i2.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i2.filter, null, i2);
            let o2 = this.sourceCaches[e2];
            return o2 ? function(t2, e3) {
              let i3 = t2.getRenderableIds().map((e4) => t2.getTileByID(e4)), o3 = [], a2 = {};
              for (let t3 = 0; t3 < i3.length; t3++) {
                let r2 = i3[t3], s2 = r2.tileID.canonical.key;
                a2[s2] || (a2[s2] = !0, r2.querySourceFeatures(o3, e3));
              }
              return o3;
            }(o2, i2) : [];
          }
          addSourceType(t2, e2, i2) {
            return ee.getSourceType(t2) ? i2(new Error(`A source type called "${t2}" already exists.`)) : (ee.setSourceType(t2, e2), e2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e2.workerSourceURL }, i2) : i2(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e2, i2 = {}) {
            this._checkLoaded();
            let o2 = this.light.getLight(), r2 = !1;
            for (let t2 in e2)
              if (!a(e2[t2], o2[t2])) {
                r2 = !0;
                break;
              }
            if (!r2)
              return;
            let s2 = { now: t.exported.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e2, i2), this.light.updateTransitions(s2);
          }
          _validate(e2, i2, o2, a2, r2 = {}) {
            return (!r2 || r2.validate !== !1) && Yt(this, e2.call(t.validateStyle, t.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: t.spec }, a2)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
            for (let t2 in this._layers)
              this._layers[t2].setEventedParent(null);
            for (let t2 in this.sourceCaches) {
              let e2 = this.sourceCaches[t2];
              e2.setEventedParent(null), e2.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }
          _clearSource(t2) {
            this.sourceCaches[t2].clearTiles();
          }
          _reloadSource(t2) {
            this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
          }
          _updateSources(t2) {
            for (let e2 in this.sourceCaches)
              this.sourceCaches[e2].update(t2, this.terrain);
          }
          _generateCollisionBoxes() {
            for (let t2 in this.sourceCaches)
              this._reloadSource(t2);
          }
          _updatePlacement(e2, i2, o2, a2, r2 = !1) {
            let s2 = !1, n2 = !1, l2 = {};
            for (let t2 of this._order) {
              let i3 = this._layers[t2];
              if (i3.type !== "symbol")
                continue;
              if (!l2[i3.source]) {
                let t3 = this.sourceCaches[i3.source];
                l2[i3.source] = t3.getRenderableIds(!0).map((e3) => t3.getTileByID(e3)).sort((t4, e3) => e3.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e3.tileID) ? -1 : 1));
              }
              let o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], e2.center.lng);
              s2 = s2 || o3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r2 = r2 || this._layerOrderChanged || o2 === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e2.zoom)) && (this.pauseablePlacement = new Zt(e2, this.terrain, this._order, r2, i2, o2, a2, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()), n2 = !0), s2 && this.pauseablePlacement.placement.setStale()), n2 || s2)
              for (let t2 of this._order) {
                let e3 = this._layers[t2];
                e3.type === "symbol" && this.placement.updateLayerOpacities(e3, l2[e3.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now());
          }
          _releaseSymbolFadeTiles() {
            for (let t2 in this.sourceCaches)
              this.sourceCaches[t2].releaseSymbolFadeTiles();
          }
          getImages(t2, e2, i2) {
            this.imageManager.getImages(e2.icons, i2), this._updateTilesForChangedImages();
            let o2 = this.sourceCaches[e2.source];
            o2 && o2.setDependencies(e2.tileID.key, e2.type, e2.icons);
          }
          getGlyphs(t2, e2, i2) {
            this.glyphManager.getGlyphs(e2.stacks, i2);
          }
          getResource(e2, i2, o2) {
            return t.makeRequest(i2, o2);
          }
        }
        ee.getSourceType = function(t2) {
          return M[t2];
        }, ee.setSourceType = function(t2, e2) {
          M[t2] = e2;
        }, ee.registerForPluginStateChange = t.registerForPluginStateChange;
        var ie = "attribute vec2 a_pos;uniform mat4 u_matrix;varying vec2 v_texture_pos;varying float v_depth;void main() {v_texture_pos=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);v_depth=gl_Position.z/gl_Position.w;}";
        let oe = { prelude: ae(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_offset;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return (elevation+u_terrain_offset)*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: ae(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: ae(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: ae(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: ae("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ae(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), heatmapTexture: ae(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: ae("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ae("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ae("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: ae(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: ae(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: ae(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: ae(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: ae(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float baseDelta=10.0;float ele=get_elevation(a_centroid);
#else
float baseDelta=0.0;float ele=0.0;
#endif
base=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: ae(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float baseDelta=10.0;float ele=get_elevation(a_centroid);
#else
float baseDelta=0.0;float ele=0.0;
#endif
base=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: ae(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ae(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: ae(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: ae(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: ae(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: ae(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: ae(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: ae(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: ae(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: ae(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: ae("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", ie), terrainDepth: ae("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", ie), terrainCoords: ae("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", ie) };
        function ae(t2, e2) {
          let i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = e2.match(/attribute ([\w]+) ([\w]+)/g), a2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = r2 ? r2.concat(a2) : a2, n2 = {};
          return { fragmentSource: t2 = t2.replace(i2, (t3, e3, i3, o3, a3) => (n2[a3] = !0, e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${a3}
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`)), vertexSource: e2 = e2.replace(i2, (t3, e3, i3, o3, a3) => {
            let r3 = o3 === "float" ? "vec2" : "vec4", s3 = a3.match(/color/) ? "color" : r3;
            return n2[a3] ? e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${r3} a_${a3};
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : s3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = unpack_mix_${s3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${r3} a_${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : s3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = unpack_mix_${s3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`;
          }), staticAttributes: o2, staticUniforms: s2 };
        }
        class re {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t2, e2, i2, o2, a2, r2, s2, n2, l2) {
            this.context = t2;
            let c2 = this.boundPaintVertexBuffers.length !== o2.length;
            for (let t3 = 0; !c2 && t3 < o2.length; t3++)
              this.boundPaintVertexBuffers[t3] !== o2[t3] && (c2 = !0);
            t2.extVertexArrayObject && this.vao && this.boundProgram === e2 && this.boundLayoutVertexBuffer === i2 && !c2 && this.boundIndexBuffer === a2 && this.boundVertexOffset === r2 && this.boundDynamicVertexBuffer === s2 && this.boundDynamicVertexBuffer2 === n2 && this.boundDynamicVertexBuffer3 === l2 ? (t2.bindVertexArrayOES.set(this.vao), s2 && s2.bind(), a2 && a2.dynamicDraw && a2.bind(), n2 && n2.bind(), l2 && l2.bind()) : this.freshBind(e2, i2, o2, a2, r2, s2, n2, l2);
          }
          freshBind(t2, e2, i2, o2, a2, r2, s2, n2) {
            let l2, c2 = t2.numAttributes, h2 = this.context, u2 = h2.gl;
            if (h2.extVertexArrayObject)
              this.vao && this.destroy(), this.vao = h2.extVertexArrayObject.createVertexArrayOES(), h2.bindVertexArrayOES.set(this.vao), l2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = a2, this.boundDynamicVertexBuffer = r2, this.boundDynamicVertexBuffer2 = s2, this.boundDynamicVertexBuffer3 = n2;
            else {
              l2 = h2.currentNumAttributes || 0;
              for (let t3 = c2; t3 < l2; t3++)
                u2.disableVertexAttribArray(t3);
            }
            e2.enableAttributes(u2, t2);
            for (let e3 of i2)
              e3.enableAttributes(u2, t2);
            r2 && r2.enableAttributes(u2, t2), s2 && s2.enableAttributes(u2, t2), n2 && n2.enableAttributes(u2, t2), e2.bind(), e2.setVertexAttribPointers(u2, t2, a2);
            for (let e3 of i2)
              e3.bind(), e3.setVertexAttribPointers(u2, t2, a2);
            r2 && (r2.bind(), r2.setVertexAttribPointers(u2, t2, a2)), o2 && o2.bind(), s2 && (s2.bind(), s2.setVertexAttribPointers(u2, t2, a2)), n2 && (n2.bind(), n2.setVertexAttribPointers(u2, t2, a2)), h2.currentNumAttributes = c2;
          }
          destroy() {
            this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
          }
        }
        function se(t2) {
          let e2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            if (t2[i2] === null)
              continue;
            let o2 = t2[i2].split(" ");
            e2.push(o2.pop());
          }
          return e2;
        }
        class ne {
          constructor(e2, i2, o2, a2, r2, s2, n2) {
            let l2 = e2.gl;
            this.program = l2.createProgram();
            let c2 = se(o2.staticAttributes), h2 = a2 ? a2.getBinderAttributes() : [], u2 = c2.concat(h2), d2 = oe.prelude.staticUniforms ? se(oe.prelude.staticUniforms) : [], m2 = o2.staticUniforms ? se(o2.staticUniforms) : [], _2 = a2 ? a2.getBinderUniforms() : [], p2 = d2.concat(m2).concat(_2), f2 = [];
            for (let t2 of p2)
              f2.indexOf(t2) < 0 && f2.push(t2);
            let g2 = a2 ? a2.defines() : [];
            s2 && g2.push("#define OVERDRAW_INSPECTOR;"), n2 && g2.push("#define TERRAIN3D;");
            let x2 = g2.concat(oe.prelude.fragmentSource, o2.fragmentSource).join(`
`), v2 = g2.concat(oe.prelude.vertexSource, o2.vertexSource).join(`
`), y2 = l2.createShader(l2.FRAGMENT_SHADER);
            if (l2.isContextLost())
              return void (this.failedToCreate = !0);
            l2.shaderSource(y2, x2), l2.compileShader(y2), l2.attachShader(this.program, y2);
            let b2 = l2.createShader(l2.VERTEX_SHADER);
            if (l2.isContextLost())
              return void (this.failedToCreate = !0);
            l2.shaderSource(b2, v2), l2.compileShader(b2), l2.attachShader(this.program, b2), this.attributes = {};
            let w2 = {};
            this.numAttributes = u2.length;
            for (let t2 = 0; t2 < this.numAttributes; t2++)
              u2[t2] && (l2.bindAttribLocation(this.program, t2, u2[t2]), this.attributes[u2[t2]] = t2);
            l2.linkProgram(this.program), l2.deleteShader(b2), l2.deleteShader(y2);
            for (let t2 = 0; t2 < f2.length; t2++) {
              let e3 = f2[t2];
              if (e3 && !w2[e3]) {
                let t3 = l2.getUniformLocation(this.program, e3);
                t3 && (w2[e3] = t3);
              }
            }
            this.fixedUniforms = r2(e2, w2), this.terrainUniforms = ((e3, i3) => ({ u_depth: new t.Uniform1i(e3, i3.u_depth), u_terrain: new t.Uniform1i(e3, i3.u_terrain), u_terrain_dim: new t.Uniform1f(e3, i3.u_terrain_dim), u_terrain_matrix: new t.UniformMatrix4f(e3, i3.u_terrain_matrix), u_terrain_unpack: new t.Uniform4f(e3, i3.u_terrain_unpack), u_terrain_offset: new t.Uniform1f(e3, i3.u_terrain_offset), u_terrain_exaggeration: new t.Uniform1f(e3, i3.u_terrain_exaggeration) }))(e2, w2), this.binderUniforms = a2 ? a2.getUniforms(e2, w2) : [];
          }
          draw(t2, e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2, p2, f2, g2) {
            let x2 = t2.gl;
            if (this.failedToCreate)
              return;
            if (t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(a2), t2.setCullFace(r2), n2) {
              t2.activeTexture.set(x2.TEXTURE2), x2.bindTexture(x2.TEXTURE_2D, n2.depthTexture), t2.activeTexture.set(x2.TEXTURE3), x2.bindTexture(x2.TEXTURE_2D, n2.texture);
              for (let t3 in this.terrainUniforms)
                this.terrainUniforms[t3].set(n2[t3]);
            }
            for (let t3 in this.fixedUniforms)
              this.fixedUniforms[t3].set(s2[t3]);
            _2 && _2.setUniforms(t2, this.binderUniforms, d2, { zoom: m2 });
            let v2 = 0;
            switch (e2) {
              case x2.LINES:
                v2 = 2;
                break;
              case x2.TRIANGLES:
                v2 = 3;
                break;
              case x2.LINE_STRIP:
                v2 = 1;
            }
            for (let i3 of u2.get()) {
              let o3 = i3.vaos || (i3.vaos = {});
              (o3[l2] || (o3[l2] = new re())).bind(t2, this, c2, _2 ? _2.getPaintVertexBuffers() : [], h2, i3.vertexOffset, p2, f2, g2), x2.drawElements(e2, i3.primitiveLength * v2, x2.UNSIGNED_SHORT, i3.primitiveOffset * v2 * 2);
            }
          }
        }
        function le(t2, e2, i2) {
          let o2 = 1 / bt(i2, 1, e2.transform.tileZoom), a2 = Math.pow(2, i2.tileID.overscaledZ), r2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / a2, s2 = r2 * (i2.tileID.canonical.x + i2.tileID.wrap * a2), n2 = r2 * i2.tileID.canonical.y;
          return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [s2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & s2, 65535 & n2] };
        }
        let ce = (e2, i2, o2, a2) => {
          let r2 = i2.style.light, s2 = r2.properties.get("position"), n2 = [s2.x, s2.y, s2.z], l2 = t.create$1();
          r2.properties.get("anchor") === "viewport" && t.fromRotation(l2, -i2.transform.angle), t.transformMat3(n2, n2, l2);
          let c2 = r2.properties.get("color");
          return { u_matrix: e2, u_lightpos: n2, u_lightintensity: r2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: a2 };
        }, he = (e2, i2, o2, a2, r2, s2, n2) => t.extend(ce(e2, i2, o2, a2), le(s2, i2, n2), { u_height_factor: -Math.pow(2, r2.overscaledZ) / n2.tileSize / 8 }), ue = (t2) => ({ u_matrix: t2 }), de = (e2, i2, o2, a2) => t.extend(ue(e2), le(o2, i2, a2)), me = (t2, e2) => ({ u_matrix: t2, u_world: e2 }), _e = (e2, i2, o2, a2, r2) => t.extend(de(e2, i2, o2, a2), { u_world: r2 }), pe = (t2, e2, i2, o2) => {
          let a2 = t2.transform, r2, s2;
          if (o2.paint.get("circle-pitch-alignment") === "map") {
            let t3 = bt(i2, 1, a2.zoom);
            r2 = !0, s2 = [t3, t3];
          } else
            r2 = !1, s2 = a2.pixelsToGLUnits;
          return { u_camera_to_center_distance: a2.cameraToCenterDistance, u_scale_with_map: +(o2.paint.get("circle-pitch-scale") === "map"), u_matrix: t2.translatePosMatrix(e2.posMatrix, i2, o2.paint.get("circle-translate"), o2.paint.get("circle-translate-anchor")), u_pitch_with_map: +r2, u_device_pixel_ratio: t2.pixelRatio, u_extrude_scale: s2 };
        }, fe = (t2, e2, i2) => {
          let o2 = bt(i2, 1, e2.zoom), a2 = Math.pow(2, e2.zoom - i2.tileID.overscaledZ), r2 = i2.tileID.overscaleFactor();
          return { u_matrix: t2, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (o2 * a2), e2.pixelsToGLUnits[1] / (o2 * a2)], u_overscale_factor: r2 };
        }, ge = (t2, e2, i2 = 1) => ({ u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 }), xe = (t2) => ({ u_matrix: t2 }), ve = (t2, e2, i2, o2) => ({ u_matrix: t2, u_extrude_scale: bt(e2, 1, i2), u_intensity: o2 });
        function ye(e2, i2) {
          let o2 = Math.pow(2, i2.canonical.z), a2 = i2.canonical.y;
          return [new t.MercatorCoordinate(0, a2 / o2).toLngLat().lat, new t.MercatorCoordinate(0, (a2 + 1) / o2).toLngLat().lat];
        }
        let be = (t2, e2, i2, o2) => {
          let a2 = t2.transform;
          return { u_matrix: Ce(t2, e2, i2, o2), u_ratio: 1 / bt(e2, 1, a2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
        }, we = (e2, i2, o2, a2, r2) => t.extend(be(e2, i2, o2, r2), { u_image: 0, u_image_height: a2 }), Te = (t2, e2, i2, o2, a2) => {
          let r2 = t2.transform, s2 = Ie(e2, r2);
          return { u_matrix: Ce(t2, e2, i2, a2), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / bt(e2, 1, r2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_image: 0, u_scale: [s2, o2.fromScale, o2.toScale], u_fade: o2.t, u_units_to_pixels: [1 / r2.pixelsToGLUnits[0], 1 / r2.pixelsToGLUnits[1]] };
        }, Ee = (e2, i2, o2, a2, r2, s2) => {
          let n2 = e2.lineAtlas, l2 = Ie(i2, e2.transform), c2 = o2.layout.get("line-cap") === "round", h2 = n2.getDash(a2.from, c2), u2 = n2.getDash(a2.to, c2), d2 = h2.width * r2.fromScale, m2 = u2.width * r2.toScale;
          return t.extend(be(e2, i2, o2, s2), { u_patternscale_a: [l2 / d2, -h2.height / 2], u_patternscale_b: [l2 / m2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, m2) * e2.pixelRatio) / 2, u_image: 0, u_tex_y_a: h2.y, u_tex_y_b: u2.y, u_mix: r2.t });
        };
        function Ie(t2, e2) {
          return 1 / bt(t2, 1, e2.tileZoom);
        }
        function Ce(t2, e2, i2, o2) {
          return t2.translatePosMatrix(o2 ? o2.posMatrix : e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
        }
        let Se = (t2, e2, i2, o2, a2) => {
          return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (s2 = a2.paint.get("raster-saturation"), s2 > 0 ? 1 - 1 / (1.001 - s2) : -s2), u_contrast_factor: (r2 = a2.paint.get("raster-contrast"), r2 > 0 ? 1 / (1 - r2) : 1 + r2), u_spin_weights: De(a2.paint.get("raster-hue-rotate")) };
          var r2, s2;
        };
        function De(t2) {
          t2 *= Math.PI / 180;
          let e2 = Math.sin(t2), i2 = Math.cos(t2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
        }
        let ze = (t2, e2, i2, o2, a2, r2, s2, n2, l2, c2) => {
          let h2 = a2.transform;
          return { u_is_size_zoom_constant: +(t2 === "constant" || t2 === "source"), u_is_size_feature_constant: +(t2 === "constant" || t2 === "camera"), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: h2.cameraToCenterDistance, u_pitch: h2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: h2.width / h2.height, u_fade_change: a2.options.fadeDuration ? a2.symbolFadeChange : 1, u_matrix: r2, u_label_plane_matrix: s2, u_coord_matrix: n2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
        }, Pe = (e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2) => {
          let d2 = r2.transform;
          return t.extend(ze(e2, i2, o2, a2, r2, s2, n2, l2, c2, h2), { u_gamma_scale: a2 ? Math.cos(d2._pitch) * d2.cameraToCenterDistance : 1, u_device_pixel_ratio: r2.pixelRatio, u_is_halo: +u2 });
        }, Me = (e2, i2, o2, a2, r2, s2, n2, l2, c2, h2) => t.extend(Pe(e2, i2, o2, a2, r2, s2, n2, l2, !0, c2, !0), { u_texsize_icon: h2, u_texture_icon: 1 }), Ae = (t2, e2, i2) => ({ u_matrix: t2, u_opacity: e2, u_color: i2 }), Le = (e2, i2, o2, a2, r2, s2) => t.extend(function(t2, e3, i3, o3) {
          let a3 = i3.imageManager.getPattern(t2.from.toString()), r3 = i3.imageManager.getPattern(t2.to.toString()), { width: s3, height: n2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, h2 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l2), u2 = c2 * o3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: r3.tl, u_pattern_br_b: r3.br, u_texsize: [s3, n2], u_mix: e3.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: r3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / bt(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & u2] };
        }(a2, s2, o2, r2), { u_matrix: e2, u_opacity: i2 }), Re = { fillExtrusion: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), fillExtrusionPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e2, i2.u_height_factor), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), fill: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), fillPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), fillOutline: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world) }), fillOutlinePattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), circle: (e2, i2) => ({ u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e2, i2.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), collisionBox: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e2, i2.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e2, i2.u_overscale_factor) }), collisionCircle: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e2, i2.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e2, i2.u_viewport_size) }), debug: (e2, i2) => ({ u_color: new t.UniformColor(e2, i2.u_color), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_overlay: new t.Uniform1i(e2, i2.u_overlay), u_overlay_scale: new t.Uniform1f(e2, i2.u_overlay_scale) }), clippingMask: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), heatmap: (e2, i2) => ({ u_extrude_scale: new t.Uniform1f(e2, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e2, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), heatmapTexture: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_color_ramp: new t.Uniform1i(e2, i2.u_color_ramp), u_opacity: new t.Uniform1f(e2, i2.u_opacity) }), hillshade: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_latrange: new t.Uniform2f(e2, i2.u_latrange), u_light: new t.Uniform2f(e2, i2.u_light), u_shadow: new t.UniformColor(e2, i2.u_shadow), u_highlight: new t.UniformColor(e2, i2.u_highlight), u_accent: new t.UniformColor(e2, i2.u_accent) }), hillshadePrepare: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_dimension: new t.Uniform2f(e2, i2.u_dimension), u_zoom: new t.Uniform1f(e2, i2.u_zoom), u_unpack: new t.Uniform4f(e2, i2.u_unpack) }), line: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels) }), lineGradient: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_image: new t.Uniform1i(e2, i2.u_image), u_image_height: new t.Uniform1f(e2, i2.u_image_height) }), linePattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e2, i2.u_image), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) }), lineSDF: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e2, i2.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e2, i2.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e2, i2.u_sdfgamma), u_image: new t.Uniform1i(e2, i2.u_image), u_tex_y_a: new t.Uniform1f(e2, i2.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e2, i2.u_tex_y_b), u_mix: new t.Uniform1f(e2, i2.u_mix) }), raster: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_tl_parent: new t.Uniform2f(e2, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e2, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e2, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e2, i2.u_fade_t), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image0: new t.Uniform1i(e2, i2.u_image0), u_image1: new t.Uniform1i(e2, i2.u_image1), u_brightness_low: new t.Uniform1f(e2, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e2, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e2, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e2, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e2, i2.u_spin_weights) }), symbolIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture) }), symbolSDF: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) }), symbolTextAndIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e2, i2.u_texsize_icon), u_texture: new t.Uniform1i(e2, i2.u_texture), u_texture_icon: new t.Uniform1i(e2, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) }), background: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_color: new t.UniformColor(e2, i2.u_color) }), backgroundPattern: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image: new t.Uniform1i(e2, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e2, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_mix: new t.Uniform1f(e2, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e2, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e2, i2.u_scale_a), u_scale_b: new t.Uniform1f(e2, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e2, i2.u_tile_units_to_pixels) }), terrain: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texture: new t.Uniform1i(e2, i2.u_texture) }), terrainDepth: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) }), terrainCoords: (e2, i2) => ({ u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texture: new t.Uniform1i(e2, i2.u_texture), u_terrain_coords_id: new t.Uniform1f(e2, i2.u_terrain_coords_id) }) };
        class ke {
          constructor(t2, e2, i2) {
            this.context = t2;
            let o2 = t2.gl;
            this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t2) {
            let e2 = this.context.gl;
            if (!this.dynamicDraw)
              throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        let Be = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Fe {
          constructor(t2, e2, i2, o2) {
            this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
            let a2 = t2.gl;
            this.buffer = a2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t2) {
            if (t2.length !== this.length)
              throw new Error(`Length of new data is ${t2.length}, which doesn't match current length of ${this.length}`);
            let e2 = this.context.gl;
            this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          enableAttributes(t2, e2) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              let o2 = e2.attributes[this.attributes[i2].name];
              o2 !== void 0 && t2.enableVertexAttribArray(o2);
            }
          }
          setVertexAttribPointers(t2, e2, i2) {
            for (let o2 = 0; o2 < this.attributes.length; o2++) {
              let a2 = this.attributes[o2], r2 = e2.attributes[a2.name];
              r2 !== void 0 && t2.vertexAttribPointer(r2, a2.components, t2[Be[a2.type]], !1, this.itemSize, a2.offset + this.itemSize * (i2 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Oe {
          constructor(t2) {
            this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(t2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ue extends Oe {
          getDefault() {
            return t.Color.transparent;
          }
          set(t2) {
            let e2 = this.current;
            (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = !1);
          }
        }
        class Ne extends Oe {
          getDefault() {
            return 1;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = !1);
          }
        }
        class Ge extends Oe {
          getDefault() {
            return 0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = !1);
          }
        }
        class Ze extends Oe {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(t2) {
            let e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = !1);
          }
        }
        class Ve extends Oe {
          getDefault() {
            return !0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = !1);
          }
        }
        class qe extends Oe {
          getDefault() {
            return 255;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = !1);
          }
        }
        class je extends Oe {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t2) {
            let e2 = this.current;
            (t2.func !== e2.func || t2.ref !== e2.ref || t2.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = !1);
          }
        }
        class $e extends Oe {
          getDefault() {
            let t2 = this.gl;
            return [t2.KEEP, t2.KEEP, t2.KEEP];
          }
          set(t2) {
            let e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = !1);
          }
        }
        class Xe extends Oe {
          getDefault() {
            return !1;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            t2 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t2, this.dirty = !1;
          }
        }
        class We extends Oe {
          getDefault() {
            return [0, 1];
          }
          set(t2) {
            let e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = !1);
          }
        }
        class He extends Oe {
          getDefault() {
            return !1;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            t2 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t2, this.dirty = !1;
          }
        }
        class Ke extends Oe {
          getDefault() {
            return this.gl.LESS;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = !1);
          }
        }
        class Ye extends Oe {
          getDefault() {
            return !1;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            t2 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t2, this.dirty = !1;
          }
        }
        class Je extends Oe {
          getDefault() {
            let t2 = this.gl;
            return [t2.ONE, t2.ZERO];
          }
          set(t2) {
            let e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = !1);
          }
        }
        class Qe extends Oe {
          getDefault() {
            return t.Color.transparent;
          }
          set(t2) {
            let e2 = this.current;
            (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = !1);
          }
        }
        class ti extends Oe {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = !1);
          }
        }
        class ei extends Oe {
          getDefault() {
            return !1;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            t2 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t2, this.dirty = !1;
          }
        }
        class ii extends Oe {
          getDefault() {
            return this.gl.BACK;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = !1);
          }
        }
        class oi extends Oe {
          getDefault() {
            return this.gl.CCW;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = !1);
          }
        }
        class ai extends Oe {
          getDefault() {
            return null;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = !1);
          }
        }
        class ri extends Oe {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = !1);
          }
        }
        class si extends Oe {
          getDefault() {
            let t2 = this.gl;
            return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
          }
          set(t2) {
            let e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = !1);
          }
        }
        class ni extends Oe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, t2), this.current = t2, this.dirty = !1;
          }
        }
        class li extends Oe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            e2.bindRenderbuffer(e2.RENDERBUFFER, t2), this.current = t2, this.dirty = !1;
          }
        }
        class ci extends Oe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            e2.bindTexture(e2.TEXTURE_2D, t2), this.current = t2, this.dirty = !1;
          }
        }
        class hi extends Oe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            e2.bindBuffer(e2.ARRAY_BUFFER, t2), this.current = t2, this.dirty = !1;
          }
        }
        class ui extends Oe {
          getDefault() {
            return null;
          }
          set(t2) {
            let e2 = this.gl;
            e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = !1;
          }
        }
        class di extends Oe {
          constructor(t2) {
            super(t2), this.vao = t2.extVertexArrayObject;
          }
          getDefault() {
            return null;
          }
          set(t2) {
            this.vao && (t2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t2), this.current = t2, this.dirty = !1);
          }
        }
        class mi extends Oe {
          getDefault() {
            return 4;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = !1;
          }
        }
        class _i extends Oe {
          getDefault() {
            return !1;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = !1;
          }
        }
        class pi extends Oe {
          getDefault() {
            return !1;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            let e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = !1;
          }
        }
        class fi extends Oe {
          constructor(t2, e2) {
            super(t2), this.context = t2, this.parent = e2;
          }
          getDefault() {
            return null;
          }
        }
        class gi extends fi {
          setDirty() {
            this.dirty = !0;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            let e2 = this.gl;
            e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = !1;
          }
        }
        class xi extends fi {
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            let e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = !1;
          }
        }
        class vi {
          constructor(t2, e2, i2, o2) {
            this.context = t2, this.width = e2, this.height = i2;
            let a2 = t2.gl, r2 = this.framebuffer = a2.createFramebuffer();
            if (this.colorAttachment = new gi(t2, r2), o2 && (this.depthAttachment = new xi(t2, r2)), a2.checkFramebufferStatus(a2.FRAMEBUFFER) !== a2.FRAMEBUFFER_COMPLETE)
              throw new Error("Framebuffer is not complete");
          }
          destroy() {
            let t2 = this.context.gl, e2 = this.colorAttachment.get();
            if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
              let e3 = this.depthAttachment.get();
              e3 && t2.deleteRenderbuffer(e3);
            }
            t2.deleteFramebuffer(this.framebuffer);
          }
        }
        class yi {
          constructor(t2, e2, i2) {
            this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
          }
        }
        yi.Replace = [1, 0], yi.disabled = new yi(yi.Replace, t.Color.transparent, [!1, !1, !1, !1]), yi.unblended = new yi(yi.Replace, t.Color.transparent, [!0, !0, !0, !0]), yi.alphaBlended = new yi([1, 771], t.Color.transparent, [!0, !0, !0, !0]);
        class bi {
          constructor(t2) {
            this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new Ue(this), this.clearDepth = new Ne(this), this.clearStencil = new Ge(this), this.colorMask = new Ze(this), this.depthMask = new Ve(this), this.stencilMask = new qe(this), this.stencilFunc = new je(this), this.stencilOp = new $e(this), this.stencilTest = new Xe(this), this.depthRange = new We(this), this.depthTest = new He(this), this.depthFunc = new Ke(this), this.blend = new Ye(this), this.blendFunc = new Je(this), this.blendColor = new Qe(this), this.blendEquation = new ti(this), this.cullFace = new ei(this), this.cullFaceSide = new ii(this), this.frontFace = new oi(this), this.program = new ai(this), this.activeTexture = new ri(this), this.viewport = new si(this), this.bindFramebuffer = new ni(this), this.bindRenderbuffer = new li(this), this.bindTexture = new ci(this), this.bindVertexBuffer = new hi(this), this.bindElementBuffer = new ui(this), this.bindVertexArrayOES = this.extVertexArrayObject && new di(this), this.pixelStoreUnpack = new mi(this), this.pixelStoreUnpackPremultiplyAlpha = new _i(this), this.pixelStoreUnpackFlipY = new pi(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(t2, e2) {
            return new ke(this, t2, e2);
          }
          createVertexBuffer(t2, e2, i2) {
            return new Fe(this, t2, e2, i2);
          }
          createRenderbuffer(t2, e2, i2) {
            let o2 = this.gl, a2 = o2.createRenderbuffer();
            return this.bindRenderbuffer.set(a2), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), a2;
          }
          createFramebuffer(t2, e2, i2) {
            return new vi(this, t2, e2, i2);
          }
          clear({ color: t2, depth: e2 }) {
            let i2 = this.gl, o2 = 0;
            t2 && (o2 |= i2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([!0, !0, !0, !0])), e2 !== void 0 && (o2 |= i2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(!0)), i2.clear(o2);
          }
          setCullFace(t2) {
            t2.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
          }
          setDepthMode(t2) {
            t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(!0), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(!1);
          }
          setStencilMode(t2) {
            t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(t2) {
            a(t2.blendFunction, yi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
          }
          unbindVAO() {
            this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
          }
        }
        class wi {
          constructor(t2, e2, i2) {
            this.func = t2, this.mask = e2, this.range = i2;
          }
        }
        wi.ReadOnly = !1, wi.ReadWrite = !0, wi.disabled = new wi(519, wi.ReadOnly, [0, 1]);
        let Ti = 7680;
        class Ei {
          constructor(t2, e2, i2, o2, a2, r2) {
            this.test = t2, this.ref = e2, this.mask = i2, this.fail = o2, this.depthFail = a2, this.pass = r2;
          }
        }
        Ei.disabled = new Ei({ func: 519, mask: 0 }, 0, 0, Ti, Ti, Ti);
        class Ii {
          constructor(t2, e2, i2) {
            this.enable = t2, this.mode = e2, this.frontFace = i2;
          }
        }
        let Ci;
        function Si(e2, i2, o2, a2, r2, s2, n2) {
          let l2 = e2.context, c2 = l2.gl, h2 = e2.useProgram("collisionBox"), u2 = [], d2 = 0, m2 = 0;
          for (let _3 = 0; _3 < a2.length; _3++) {
            let p3 = a2[_3], f3 = i2.getTile(p3), g3 = f3.getBucket(o2);
            if (!g3)
              continue;
            let x3 = p3.posMatrix;
            r2[0] === 0 && r2[1] === 0 || (x3 = e2.translatePosMatrix(p3.posMatrix, f3, r2, s2));
            let v3 = n2 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
            if (y2.length > 0) {
              let i3 = t.create(), o3 = x3;
              t.mul(i3, g3.placementInvProjMatrix, e2.transform.glCoordMatrix), t.mul(i3, i3, g3.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: m2, transform: o3, invTransform: i3, coord: p3 }), d2 += y2.length / 4, m2 = d2;
            }
            v3 && h2.draw(l2, c2.LINES, wi.disabled, Ei.disabled, e2.colorModeForRenderPass(), Ii.disabled, fe(x3, e2.transform, f3), e2.style.terrain && e2.style.terrain.getTerrainData(p3), o2.id, v3.layoutVertexBuffer, v3.indexBuffer, v3.segments, null, e2.transform.zoom, null, null, v3.collisionVertexBuffer);
          }
          if (!n2 || !u2.length)
            return;
          let _2 = e2.useProgram("collisionCircle"), p2 = new t.CollisionCircleLayoutArray();
          p2.resize(4 * d2), p2._trim();
          let f2 = 0;
          for (let t2 of u2)
            for (let e3 = 0; e3 < t2.circleArray.length / 4; e3++) {
              let i3 = 4 * e3, o3 = t2.circleArray[i3 + 0], a3 = t2.circleArray[i3 + 1], r3 = t2.circleArray[i3 + 2], s3 = t2.circleArray[i3 + 3];
              p2.emplace(f2++, o3, a3, r3, s3, 0), p2.emplace(f2++, o3, a3, r3, s3, 1), p2.emplace(f2++, o3, a3, r3, s3, 2), p2.emplace(f2++, o3, a3, r3, s3, 3);
            }
          (!Ci || Ci.length < 2 * d2) && (Ci = function(e3) {
            let i3 = 2 * e3, o3 = new t.QuadTriangleArray();
            o3.resize(i3), o3._trim();
            for (let t2 = 0; t2 < i3; t2++) {
              let e4 = 6 * t2;
              o3.uint16[e4 + 0] = 4 * t2 + 0, o3.uint16[e4 + 1] = 4 * t2 + 1, o3.uint16[e4 + 2] = 4 * t2 + 2, o3.uint16[e4 + 3] = 4 * t2 + 2, o3.uint16[e4 + 4] = 4 * t2 + 3, o3.uint16[e4 + 5] = 4 * t2 + 0;
            }
            return o3;
          }(d2));
          let g2 = l2.createIndexBuffer(Ci, !0), x2 = l2.createVertexBuffer(p2, t.collisionCircleLayout.members, !0);
          for (let i3 of u2) {
            let a3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (v2 = e2.transform).cameraToCenterDistance, u_viewport_size: [v2.width, v2.height] };
            _2.draw(l2, c2.TRIANGLES, wi.disabled, Ei.disabled, e2.colorModeForRenderPass(), Ii.disabled, a3, e2.style.terrain && e2.style.terrain.getTerrainData(i3.coord), o2.id, x2, g2, t.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
          }
          var v2;
          x2.destroy(), g2.destroy();
        }
        Ii.disabled = new Ii(!1, 1029, 2305), Ii.backCCW = new Ii(!0, 1029, 2305);
        let Di = t.identity(new Float32Array(16));
        function zi(e2, i2, o2, a2, r2, s2) {
          let { horizontalAlign: n2, verticalAlign: l2 } = t.getAnchorAlignment(e2), c2 = -(n2 - 0.5) * i2, h2 = -(l2 - 0.5) * o2, u2 = t.evaluateVariableOffset(e2, a2);
          return new t.pointGeometry((c2 / r2 + u2[0]) * s2, (h2 / r2 + u2[1]) * s2);
        }
        function Pi(e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2) {
          let d2 = e2.text.placedSymbolArray, m2 = e2.text.dynamicLayoutVertexArray, _2 = e2.icon.dynamicLayoutVertexArray, p2 = {};
          m2.clear();
          for (let _3 = 0; _3 < d2.length; _3++) {
            let f2 = d2.get(_3), g2 = e2.allowVerticalPlacement && !f2.placedOrientation, x2 = f2.hidden || !f2.crossTileID || g2 ? null : a2[f2.crossTileID];
            if (x2) {
              let a3 = new t.pointGeometry(f2.anchorX, f2.anchorY), d3 = nt(a3, o2 ? n2 : s2, u2), _4 = lt(r2.cameraToCenterDistance, d3.signedDistanceFromCamera), g3 = t.evaluateSizeForFeature(e2.textSizeData, c2, f2) * _4 / t.ONE_EM;
              o2 && (g3 *= e2.tilePixelRatio / l2);
              let { width: v2, height: y2, anchor: b2, textOffset: w2, textBoxScale: T2 } = x2, E2 = zi(b2, v2, y2, w2, T2, g3), I2 = o2 ? nt(a3.add(E2), s2, u2).point : d3.point.add(i2 ? E2.rotate(-r2.angle) : E2), C2 = e2.allowVerticalPlacement && f2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
              for (let e3 = 0; e3 < f2.numGlyphs; e3++)
                t.addDynamicAttributes(m2, I2, C2);
              h2 && f2.associatedIconIndex >= 0 && (p2[f2.associatedIconIndex] = { shiftedAnchor: I2, angle: C2 });
            } else
              gt(f2.numGlyphs, m2);
          }
          if (h2) {
            _2.clear();
            let i3 = e2.icon.placedSymbolArray;
            for (let e3 = 0; e3 < i3.length; e3++) {
              let o3 = i3.get(e3);
              if (o3.hidden)
                gt(o3.numGlyphs, _2);
              else {
                let i4 = p2[e3];
                if (i4)
                  for (let e4 = 0; e4 < o3.numGlyphs; e4++)
                    t.addDynamicAttributes(_2, i4.shiftedAnchor, i4.angle);
                else
                  gt(o3.numGlyphs, _2);
              }
            }
            e2.icon.dynamicLayoutVertexBuffer.updateData(_2);
          }
          e2.text.dynamicLayoutVertexBuffer.updateData(m2);
        }
        function Mi(t2, e2, i2) {
          return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
        }
        function Ai(e2, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2) {
          let m2 = e2.context, _2 = m2.gl, p2 = e2.transform, f2 = l2 === "map", g2 = c2 === "map", x2 = l2 !== "viewport" && o2.layout.get("symbol-placement") !== "point", v2 = f2 && !g2 && !x2, y2 = !o2.layout.get("symbol-sort-key").isConstant(), b2 = !1, w2 = e2.depthModeForSublayer(0, wi.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [];
          for (let l3 of a2) {
            let a3 = i2.getTile(l3), c3 = a3.getBucket(o2);
            if (!c3)
              continue;
            let u3 = r2 ? c3.text : c3.icon;
            if (!u3 || !u3.segments.get().length)
              continue;
            let d3 = u3.programConfigurations.get(o2.id), m3 = r2 || c3.sdfIcons, w3 = r2 ? c3.textSizeData : c3.iconSizeData, I2 = g2 || p2.pitch !== 0, C2 = e2.useProgram(Mi(m3, r2, c3), d3), S2 = t.evaluateSizeForZoom(w3, p2.zoom), D2 = e2.style.terrain && e2.style.terrain.getTerrainData(l3), z2, P2, M2, A2, L2 = [0, 0], R2 = null;
            if (r2) {
              if (P2 = a3.glyphAtlasTexture, M2 = _2.LINEAR, z2 = a3.glyphAtlasTexture.size, c3.iconsInText) {
                L2 = a3.imageAtlasTexture.size, R2 = a3.imageAtlasTexture;
                let t2 = w3.kind === "composite" || w3.kind === "camera";
                A2 = I2 || e2.options.rotating || e2.options.zooming || t2 ? _2.LINEAR : _2.NEAREST;
              }
            } else {
              let t2 = o2.layout.get("icon-size").constantOr(0) !== 1 || c3.iconsNeedLinear;
              P2 = a3.imageAtlasTexture, M2 = m3 || e2.options.rotating || e2.options.zooming || t2 || I2 ? _2.LINEAR : _2.NEAREST, z2 = a3.imageAtlasTexture.size;
            }
            let k2 = bt(a3, 1, e2.transform.zoom), B2 = rt(l3.posMatrix, g2, f2, e2.transform, k2), F2 = st(l3.posMatrix, g2, f2, e2.transform, k2), O2 = T2 && c3.hasTextData(), U2 = o2.layout.get("icon-text-fit") !== "none" && O2 && c3.hasIconData();
            if (x2) {
              let t2 = e2.style.terrain ? (t3, i4) => e2.style.terrain.getElevation(l3, t3, i4) : null, i3 = o2.layout.get("text-rotation-alignment") === "map";
              ht(c3, l3.posMatrix, e2, r2, B2, F2, g2, h2, i3, t2);
            }
            let N2 = e2.translatePosMatrix(l3.posMatrix, a3, s2, n2), G2 = x2 || r2 && T2 || U2 ? Di : B2, Z2 = e2.translatePosMatrix(F2, a3, s2, n2, !0), V2 = m3 && o2.paint.get(r2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, q2;
            q2 = m3 ? c3.iconsInText ? Me(w3.kind, S2, v2, g2, e2, N2, G2, Z2, z2, L2) : Pe(w3.kind, S2, v2, g2, e2, N2, G2, Z2, r2, z2, !0) : ze(w3.kind, S2, v2, g2, e2, N2, G2, Z2, r2, z2);
            let j2 = { program: C2, buffers: u3, uniformValues: q2, atlasTexture: P2, atlasTextureIcon: R2, atlasInterpolation: M2, atlasInterpolationIcon: A2, isSDF: m3, hasHalo: V2 };
            if (y2 && c3.canOverlap) {
              b2 = !0;
              let e3 = u3.segments.get();
              for (let i3 of e3)
                E2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: j2, terrainData: D2 });
            } else
              E2.push({ segments: u3.segments, sortKey: 0, state: j2, terrainData: D2 });
          }
          b2 && E2.sort((t2, e3) => t2.sortKey - e3.sortKey);
          for (let t2 of E2) {
            let i3 = t2.state;
            if (m2.activeTexture.set(_2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, _2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (m2.activeTexture.set(_2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, _2.CLAMP_TO_EDGE)), i3.isSDF) {
              let a3 = i3.uniformValues;
              i3.hasHalo && (a3.u_is_halo = 1, Li(i3.buffers, t2.segments, o2, e2, i3.program, w2, u2, d2, a3, t2.terrainData)), a3.u_is_halo = 0;
            }
            Li(i3.buffers, t2.segments, o2, e2, i3.program, w2, u2, d2, i3.uniformValues, t2.terrainData);
          }
        }
        function Li(t2, e2, i2, o2, a2, r2, s2, n2, l2, c2) {
          let h2 = o2.context;
          a2.draw(h2, h2.gl.TRIANGLES, r2, s2, n2, Ii.disabled, l2, c2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, o2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
        }
        function Ri(t2, e2, i2, o2, a2, r2, s2) {
          let n2 = t2.context.gl, l2 = i2.paint.get("fill-pattern"), c2 = l2 && l2.constantOr(1), h2 = i2.getCrossfadeParameters(), u2, d2, m2, _2, p2;
          s2 ? (d2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = n2.LINES) : (d2 = c2 ? "fillPattern" : "fill", u2 = n2.TRIANGLES);
          for (let f2 of o2) {
            let o3 = e2.getTile(f2);
            if (c2 && !o3.patternsLoaded())
              continue;
            let g2 = o3.getBucket(i2);
            if (!g2)
              continue;
            let x2 = g2.programConfigurations.get(i2.id), v2 = t2.useProgram(d2, x2), y2 = t2.style.terrain && t2.style.terrain.getTerrainData(f2);
            c2 && (t2.context.activeTexture.set(n2.TEXTURE0), o3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers(h2));
            let b2 = l2.constantOr(null);
            if (b2 && o3.imageAtlas) {
              let t3 = o3.imageAtlas, e3 = t3.patternPositions[b2.to.toString()], i3 = t3.patternPositions[b2.from.toString()];
              e3 && i3 && x2.setConstantPatternPositions(e3, i3);
            }
            let w2 = y2 ? f2 : null, T2 = t2.translatePosMatrix(w2 ? w2.posMatrix : f2.posMatrix, o3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
            if (s2) {
              _2 = g2.indexBuffer2, p2 = g2.segments2;
              let e3 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
              m2 = d2 === "fillOutlinePattern" && c2 ? _e(T2, t2, h2, o3, e3) : me(T2, e3);
            } else
              _2 = g2.indexBuffer, p2 = g2.segments, m2 = c2 ? de(T2, t2, h2, o3) : ue(T2);
            v2.draw(t2.context, u2, a2, t2.stencilModeForClipping(f2), r2, Ii.disabled, m2, y2, i2.id, g2.layoutVertexBuffer, _2, p2, i2.paint, t2.transform.zoom, x2);
          }
        }
        function ki(t2, e2, i2, o2, a2, r2, s2) {
          let n2 = t2.context, l2 = n2.gl, c2 = i2.paint.get("fill-extrusion-pattern"), h2 = c2.constantOr(1), u2 = i2.getCrossfadeParameters(), d2 = i2.paint.get("fill-extrusion-opacity");
          for (let m2 of o2) {
            let o3 = e2.getTile(m2), _2 = o3.getBucket(i2);
            if (!_2)
              continue;
            let p2 = t2.style.terrain && t2.style.terrain.getTerrainData(m2), f2 = _2.programConfigurations.get(i2.id), g2 = t2.useProgram(h2 ? "fillExtrusionPattern" : "fillExtrusion", f2);
            h2 && (t2.context.activeTexture.set(l2.TEXTURE0), o3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), f2.updatePaintBuffers(u2));
            let x2 = c2.constantOr(null);
            if (x2 && o3.imageAtlas) {
              let t3 = o3.imageAtlas, e3 = t3.patternPositions[x2.to.toString()], i3 = t3.patternPositions[x2.from.toString()];
              e3 && i3 && f2.setConstantPatternPositions(e3, i3);
            }
            let v2 = t2.translatePosMatrix(m2.posMatrix, o3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), y2 = i2.paint.get("fill-extrusion-vertical-gradient"), b2 = h2 ? he(v2, t2, y2, d2, m2, u2, o3) : ce(v2, t2, y2, d2);
            g2.draw(n2, n2.gl.TRIANGLES, a2, r2, s2, Ii.backCCW, b2, p2, i2.id, _2.layoutVertexBuffer, _2.indexBuffer, _2.segments, i2.paint, t2.transform.zoom, f2, t2.style.terrain && _2.centroidVertexBuffer);
          }
        }
        function Bi(t2, e2, i2, o2, a2, r2, s2) {
          let n2 = t2.context, l2 = n2.gl, c2 = i2.fbo;
          if (!c2)
            return;
          let h2 = t2.useProgram("hillshade"), u2 = t2.style.terrain && t2.style.terrain.getTerrainData(e2);
          n2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c2.colorAttachment.get()), h2.draw(n2, l2.TRIANGLES, a2, r2, s2, Ii.disabled, ((t3, e3, i3, o3) => {
            let a3 = i3.paint.get("hillshade-shadow-color"), r3 = i3.paint.get("hillshade-highlight-color"), s3 = i3.paint.get("hillshade-accent-color"), n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            i3.paint.get("hillshade-illumination-anchor") === "viewport" && (n3 -= t3.transform.angle);
            let l3 = !t3.options.moving;
            return { u_matrix: o3 ? o3.posMatrix : t3.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: ye(0, e3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), n3], u_shadow: a3, u_highlight: r3, u_accent: s3 };
          })(t2, i2, o2, u2 ? e2 : null), u2, o2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
        }
        function Fi(e2, i2, o2, a2, r2, s2) {
          let n2 = e2.context, c2 = n2.gl, h2 = i2.dem;
          if (h2 && h2.data) {
            let u2 = h2.dim, d2 = h2.stride, m2 = h2.getPixels();
            if (n2.activeTexture.set(c2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(!1), i2.demTexture = i2.demTexture || e2.getTileTexture(d2), i2.demTexture) {
              let t2 = i2.demTexture;
              t2.update(m2, { premultiply: !1 }), t2.bind(c2.NEAREST, c2.CLAMP_TO_EDGE);
            } else
              i2.demTexture = new l(n2, m2, c2.RGBA, { premultiply: !1 }), i2.demTexture.bind(c2.NEAREST, c2.CLAMP_TO_EDGE);
            n2.activeTexture.set(c2.TEXTURE0);
            let _2 = i2.fbo;
            if (!_2) {
              let t2 = new l(n2, { width: u2, height: u2, data: null }, c2.RGBA);
              t2.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), _2 = i2.fbo = n2.createFramebuffer(u2, u2, !0), _2.colorAttachment.set(t2.texture);
            }
            n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, u2, u2]), e2.useProgram("hillshadePrepare").draw(n2, c2.TRIANGLES, a2, r2, s2, Ii.disabled, ((e3, i3) => {
              let o3 = i3.stride, a3 = t.create();
              return t.ortho(a3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(a3, a3, [0, -t.EXTENT, 0]), { u_matrix: a3, u_image: 1, u_dimension: [o3, o3], u_zoom: e3.overscaledZ, u_unpack: i3.getUnpackVector() };
            })(i2.tileID, h2), null, o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i2.needsHillshadePrepare = !1;
          }
        }
        function Oi(e2, i2, o2, a2, r2, s2) {
          let n2 = a2.paint.get("raster-fade-duration");
          if (!s2 && n2 > 0) {
            let a3 = t.exported.now(), s3 = (a3 - e2.timeAdded) / n2, l2 = i2 ? (a3 - i2.timeAdded) / n2 : -1, c2 = o2.getSource(), h2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(e2.tileID.overscaledZ - h2), d2 = u2 && e2.refreshedUponExpiration ? 1 : t.clamp(u2 ? s3 : 1 - l2, 0, 1);
            return e2.refreshedUponExpiration && s3 >= 1 && (e2.refreshedUponExpiration = !1), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        let Ui = new t.Color(1, 0, 0, 1), Ni = new t.Color(0, 1, 0, 1), Gi = new t.Color(0, 0, 1, 1), Zi = new t.Color(1, 0, 1, 1), Vi = new t.Color(0, 1, 1, 1);
        function qi(t2, e2, i2, o2) {
          $i(t2, 0, e2 + i2 / 2, t2.transform.width, i2, o2);
        }
        function ji(t2, e2, i2, o2) {
          $i(t2, e2 - i2 / 2, 0, i2, t2.transform.height, o2);
        }
        function $i(t2, e2, i2, o2, a2, r2) {
          let s2 = t2.context, n2 = s2.gl;
          n2.enable(n2.SCISSOR_TEST), n2.scissor(e2 * t2.pixelRatio, i2 * t2.pixelRatio, o2 * t2.pixelRatio, a2 * t2.pixelRatio), s2.clear({ color: r2 }), n2.disable(n2.SCISSOR_TEST);
        }
        function Xi(e2, i2, o2) {
          let a2 = e2.context, r2 = a2.gl, s2 = o2.posMatrix, n2 = e2.useProgram("debug"), l2 = wi.disabled, c2 = Ei.disabled, h2 = e2.colorModeForRenderPass(), u2 = "$debug", d2 = e2.style.terrain && e2.style.terrain.getTerrainData(o2);
          a2.activeTexture.set(r2.TEXTURE0), e2.emptyTexture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE);
          let m2 = i2.getTileByID(o2.key).latestRawTileData, _2 = Math.floor((m2 && m2.byteLength || 0) / 1024), p2 = i2.getTile(o2).tileSize, f2 = 512 / Math.min(p2, 512) * (o2.overscaledZ / e2.transform.zoom) * 0.5, g2 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (g2 += ` => ${o2.overscaledZ}`), function(t2, e3) {
            t2.initDebugOverlayCanvas();
            let i3 = t2.debugOverlayCanvas, o3 = t2.context.gl, a3 = t2.debugOverlayCanvas.getContext("2d");
            a3.clearRect(0, 0, i3.width, i3.height), a3.shadowColor = "white", a3.shadowBlur = 2, a3.lineWidth = 1.5, a3.strokeStyle = "white", a3.textBaseline = "top", a3.font = "bold 36px Open Sans, sans-serif", a3.fillText(e3, 5, 5), a3.strokeText(e3, 5, 5), t2.debugOverlayTexture.update(i3), t2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(e2, `${g2} ${_2}kB`), n2.draw(a2, r2.TRIANGLES, l2, c2, yi.alphaBlended, Ii.disabled, ge(s2, t.Color.transparent, f2), null, u2, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), n2.draw(a2, r2.LINE_STRIP, l2, c2, h2, Ii.disabled, ge(s2, t.Color.red), d2, u2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
        }
        function Wi(t2, e2, i2) {
          let o2 = t2.context, a2 = o2.gl, r2 = t2.colorModeForRenderPass(), s2 = new wi(a2.LEQUAL, wi.ReadWrite, t2.depthRangeFor3D), n2 = t2.useProgram("terrain"), l2 = e2.getTerrainMesh(), c2 = e2.getTerrainData(i2.tileID);
          o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, t2.width, t2.height]), o2.activeTexture.set(a2.TEXTURE0), a2.bindTexture(a2.TEXTURE_2D, e2.getRTTFramebuffer().colorAttachment.get());
          let h2 = t2.transform.calculatePosMatrix(i2.tileID.toUnwrapped());
          n2.draw(o2, a2.TRIANGLES, s2, Ei.disabled, r2, Ii.backCCW, { u_matrix: h2, u_texture: 0 }, c2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
        }
        function Hi(t2, e2, i2, o2) {
          let a2 = t2.context, r2 = i2.tileSize * e2.qualityFactor;
          i2.textures[o2] || (i2.textures[o2] = t2.getTileTexture(r2) || new l(a2, { width: r2, height: r2, data: null }, a2.gl.RGBA), i2.textures[o2].bind(a2.gl.LINEAR, a2.gl.CLAMP_TO_EDGE), o2 === 0 && e2.sourceCache.renderHistory.unshift(i2.tileID.key));
          let s2 = e2.getRTTFramebuffer();
          s2.colorAttachment.set(i2.textures[o2].texture), a2.bindFramebuffer.set(s2.framebuffer), a2.viewport.set([0, 0, r2, r2]);
        }
        class Ki {
          constructor(t2) {
            this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this.painter = t2, this._renderToTexture = { background: !0, fill: !0, line: !0, raster: !0 }, this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this._stacks = [], this._prevType = null, this._rerender = {}, this._renderableTiles = t2.style.terrain.sourceCache.getRenderableTiles(), this._init();
          }
          _init() {
            let t2 = this.painter.style, e2 = t2.terrain;
            for (let i2 in t2.sourceCaches) {
              this._coordsDescendingInv[i2] = {};
              let o2 = t2.sourceCaches[i2].getVisibleCoordinates();
              for (let t3 of o2) {
                let o3 = e2.sourceCache.getTerrainCoords(t3);
                for (let t4 in o3)
                  this._coordsDescendingInv[i2][t4] || (this._coordsDescendingInv[i2][t4] = []), this._coordsDescendingInv[i2][t4].push(o3[t4]);
              }
            }
            for (let e3 of t2._order) {
              let i2 = t2._layers[e3], o2 = i2.source;
              if (this._renderToTexture[i2.type] && !this._coordsDescendingInvStr[o2]) {
                this._coordsDescendingInvStr[o2] = {};
                for (let t3 in this._coordsDescendingInv[o2])
                  this._coordsDescendingInvStr[o2][t3] = this._coordsDescendingInv[o2][t3].map((t4) => t4.key).sort().join();
              }
            }
            return this._renderableTiles.forEach((t3) => {
              for (let i2 in this._coordsDescendingInvStr) {
                let o2 = this._coordsDescendingInvStr[i2][t3.tileID.key];
                o2 && o2 !== t3.textureCoords[i2] && t3.clearTextures(this.painter), e2.needsRerender(i2, t3.tileID) && t3.clearTextures(this.painter);
              }
              this._rerender[t3.tileID.key] = !t3.textures.length;
            }), e2.clearRerenderCache(), e2.sourceCache.removeOutdated(this.painter), this;
          }
          renderLayer(e2) {
            let i2 = e2.type, o2 = this.painter, a2 = o2.style._order, r2 = o2.currentLayer, s2 = r2 + 1 === a2.length;
            if (this._renderToTexture[i2] && (this._prevType && this._renderToTexture[this._prevType] || this._stacks.push([]), this._prevType = i2, this._stacks[this._stacks.length - 1].push(a2[r2]), !s2))
              return !0;
            if (this._renderToTexture[this._prevType] || i2 === "hillshade" || this._renderToTexture[i2] && s2) {
              this._prevType = i2;
              let s3 = this._stacks.length - 1, n2 = this._stacks[s3] || [];
              for (let e3 of this._renderableTiles) {
                if (Hi(o2, o2.style.terrain, e3, s3), this._rerender[e3.tileID.key]) {
                  o2.context.clear({ color: t.Color.transparent });
                  for (let t2 = 0; t2 < n2.length; t2++) {
                    let i3 = o2.style._layers[n2[t2]], a3 = i3.source ? this._coordsDescendingInv[i3.source][e3.tileID.key] : [e3.tileID];
                    o2._renderTileClippingMasks(i3, a3), o2.renderLayer(o2, o2.style.sourceCaches[i3.source], i3, a3), i3.source && (e3.textureCoords[i3.source] = this._coordsDescendingInvStr[i3.source][e3.tileID.key]);
                  }
                }
                Wi(o2, o2.style.terrain, e3);
              }
              if (i2 === "hillshade") {
                this._stacks.push([a2[r2]]);
                for (let i3 of this._renderableTiles) {
                  let a3 = this._coordsDescendingInv[e2.source][i3.tileID.key];
                  Hi(o2, o2.style.terrain, i3, this._stacks.length - 1), o2.context.clear({ color: t.Color.transparent }), o2._renderTileClippingMasks(e2, a3), o2.renderLayer(o2, o2.style.sourceCaches[e2.source], e2, a3), Wi(o2, o2.style.terrain, i3);
                }
                return !0;
              }
              return this._renderToTexture[i2];
            }
            return !1;
          }
        }
        let Yi = { symbol: function(e2, i2, o2, a2, r2) {
          if (e2.renderPass !== "translucent")
            return;
          let s2 = Ei.disabled, n2 = e2.colorModeForRenderPass();
          o2.layout.get("text-variable-anchor") && function(e3, i3, o3, a3, r3, s3, n3) {
            let l2 = i3.transform, c2 = r3 === "map", h2 = s3 === "map";
            for (let r4 of e3) {
              let e4 = a3.getTile(r4), s4 = e4.getBucket(o3);
              if (!s4 || !s4.text || !s4.text.segments.get().length)
                continue;
              let u2 = t.evaluateSizeForZoom(s4.textSizeData, l2.zoom), d2 = bt(e4, 1, i3.transform.zoom), m2 = rt(r4.posMatrix, h2, c2, i3.transform, d2), _2 = o3.layout.get("icon-text-fit") !== "none" && s4.hasIconData();
              if (u2) {
                let t2 = Math.pow(2, l2.zoom - e4.tileID.overscaledZ);
                Pi(s4, c2, h2, n3, l2, m2, r4.posMatrix, t2, u2, _2, i3.style.terrain ? (t3, e5) => i3.style.terrain.getElevation(r4, t3, e5) : null);
              }
            }
          }(a2, e2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), r2), o2.paint.get("icon-opacity").constantOr(1) !== 0 && Ai(e2, i2, o2, a2, !1, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), s2, n2), o2.paint.get("text-opacity").constantOr(1) !== 0 && Ai(e2, i2, o2, a2, !0, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), s2, n2), i2.map.showCollisionBoxes && (Si(e2, i2, o2, a2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), !0), Si(e2, i2, o2, a2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), !1));
        }, circle: function(e2, i2, o2, a2) {
          if (e2.renderPass !== "translucent")
            return;
          let r2 = o2.paint.get("circle-opacity"), s2 = o2.paint.get("circle-stroke-width"), n2 = o2.paint.get("circle-stroke-opacity"), l2 = !o2.layout.get("circle-sort-key").isConstant();
          if (r2.constantOr(1) === 0 && (s2.constantOr(1) === 0 || n2.constantOr(1) === 0))
            return;
          let c2 = e2.context, h2 = c2.gl, u2 = e2.depthModeForSublayer(0, wi.ReadOnly), d2 = Ei.disabled, m2 = e2.colorModeForRenderPass(), _2 = [];
          for (let r3 = 0; r3 < a2.length; r3++) {
            let s3 = a2[r3], n3 = i2.getTile(s3), c3 = n3.getBucket(o2);
            if (!c3)
              continue;
            let h3 = c3.programConfigurations.get(o2.id), u3 = e2.useProgram("circle", h3), d3 = c3.layoutVertexBuffer, m3 = c3.indexBuffer, p2 = e2.style.terrain && e2.style.terrain.getTerrainData(s3), f2 = { programConfiguration: h3, program: u3, layoutVertexBuffer: d3, indexBuffer: m3, uniformValues: pe(e2, s3, n3, o2), terrainData: p2 };
            if (l2) {
              let e3 = c3.segments.get();
              for (let i3 of e3)
                _2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: f2 });
            } else
              _2.push({ segments: c3.segments, sortKey: 0, state: f2 });
          }
          l2 && _2.sort((t2, e3) => t2.sortKey - e3.sortKey);
          for (let t2 of _2) {
            let { programConfiguration: i3, program: a3, layoutVertexBuffer: r3, indexBuffer: s3, uniformValues: n3, terrainData: l3 } = t2.state;
            a3.draw(c2, h2.TRIANGLES, u2, d2, m2, Ii.disabled, n3, l3, o2.id, r3, s3, t2.segments, o2.paint, e2.transform.zoom, i3);
          }
        }, heatmap: function(e2, i2, o2, a2) {
          if (o2.paint.get("heatmap-opacity") !== 0)
            if (e2.renderPass === "offscreen") {
              let r2 = e2.context, s2 = r2.gl, n2 = Ei.disabled, l2 = new yi([s2.ONE, s2.ONE], t.Color.transparent, [!0, !0, !0, !0]);
              (function(t2, e3, i3) {
                let o3 = t2.gl;
                t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e3.width / 4, e3.height / 4]);
                let a3 = i3.heatmapFbo;
                if (a3)
                  o3.bindTexture(o3.TEXTURE_2D, a3.colorAttachment.get()), t2.bindFramebuffer.set(a3.framebuffer);
                else {
                  let r3 = o3.createTexture();
                  o3.bindTexture(o3.TEXTURE_2D, r3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), a3 = i3.heatmapFbo = t2.createFramebuffer(e3.width / 4, e3.height / 4, !1), function(t3, e4, i4, o4) {
                    let a4 = t3.gl;
                    a4.texImage2D(a4.TEXTURE_2D, 0, a4.RGBA, e4.width / 4, e4.height / 4, 0, a4.RGBA, t3.extRenderToTextureHalfFloat ? t3.extTextureHalfFloat.HALF_FLOAT_OES : a4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                  }(t2, e3, r3, a3);
                }
              })(r2, e2, o2), r2.clear({ color: t.Color.transparent });
              for (let t2 = 0; t2 < a2.length; t2++) {
                let c2 = a2[t2];
                if (i2.hasRenderableParent(c2))
                  continue;
                let h2 = i2.getTile(c2), u2 = h2.getBucket(o2);
                if (!u2)
                  continue;
                let d2 = u2.programConfigurations.get(o2.id), m2 = e2.useProgram("heatmap", d2), { zoom: _2 } = e2.transform;
                m2.draw(r2, s2.TRIANGLES, wi.disabled, n2, l2, Ii.disabled, ve(c2.posMatrix, h2, _2, o2.paint.get("heatmap-intensity")), null, o2.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, o2.paint, e2.transform.zoom, d2);
              }
              r2.viewport.set([0, 0, e2.width, e2.height]);
            } else
              e2.renderPass === "translucent" && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, i3) {
                let o3 = e3.context, a3 = o3.gl, r2 = i3.heatmapFbo;
                if (!r2)
                  return;
                o3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, r2.colorAttachment.get()), o3.activeTexture.set(a3.TEXTURE1);
                let s2 = i3.colorRampTexture;
                s2 || (s2 = i3.colorRampTexture = new l(o3, i3.colorRamp, a3.RGBA)), s2.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(o3, a3.TRIANGLES, wi.disabled, Ei.disabled, e3.colorModeForRenderPass(), Ii.disabled, ((e4, i4, o4, a4) => {
                  let r3 = t.create();
                  t.ortho(r3, 0, e4.width, e4.height, 0, 0, 1);
                  let s3 = e4.context.gl;
                  return { u_matrix: r3, u_world: [s3.drawingBufferWidth, s3.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i4.paint.get("heatmap-opacity") };
                })(e3, i3), null, i3.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, i3.paint, e3.transform.zoom);
              }(e2, o2));
        }, line: function(e2, i2, o2, a2) {
          if (e2.renderPass !== "translucent")
            return;
          let r2 = o2.paint.get("line-opacity"), s2 = o2.paint.get("line-width");
          if (r2.constantOr(1) === 0 || s2.constantOr(1) === 0)
            return;
          let n2 = e2.depthModeForSublayer(0, wi.ReadOnly), c2 = e2.colorModeForRenderPass(), h2 = o2.paint.get("line-dasharray"), u2 = o2.paint.get("line-pattern"), d2 = u2.constantOr(1), m2 = o2.paint.get("line-gradient"), _2 = o2.getCrossfadeParameters(), p2 = d2 ? "linePattern" : h2 ? "lineSDF" : m2 ? "lineGradient" : "line", f2 = e2.context, g2 = f2.gl, x2 = !0;
          for (let r3 of a2) {
            let a3 = i2.getTile(r3);
            if (d2 && !a3.patternsLoaded())
              continue;
            let s3 = a3.getBucket(o2);
            if (!s3)
              continue;
            let v2 = s3.programConfigurations.get(o2.id), y2 = e2.context.program.get(), b2 = e2.useProgram(p2, v2), w2 = x2 || b2.program !== y2, T2 = e2.style.terrain && e2.style.terrain.getTerrainData(r3), E2 = u2.constantOr(null);
            if (E2 && a3.imageAtlas) {
              let t2 = a3.imageAtlas, e3 = t2.patternPositions[E2.to.toString()], i3 = t2.patternPositions[E2.from.toString()];
              e3 && i3 && v2.setConstantPatternPositions(e3, i3);
            }
            let I2 = T2 ? r3 : null, C2 = d2 ? Te(e2, a3, o2, _2, I2) : h2 ? Ee(e2, a3, o2, h2, _2, I2) : m2 ? we(e2, a3, o2, s3.lineClipsArray.length, I2) : be(e2, a3, o2, I2);
            if (d2)
              f2.activeTexture.set(g2.TEXTURE0), a3.imageAtlasTexture.bind(g2.LINEAR, g2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
            else if (h2 && (w2 || e2.lineAtlas.dirty))
              f2.activeTexture.set(g2.TEXTURE0), e2.lineAtlas.bind(f2);
            else if (m2) {
              let a4 = s3.gradients[o2.id], n3 = a4.texture;
              if (o2.gradientVersion !== a4.version) {
                let c3 = 256;
                if (o2.stepInterpolant) {
                  let o3 = i2.getSource().maxzoom, a5 = r3.canonical.z === o3 ? Math.ceil(1 << e2.transform.maxZoom - r3.canonical.z) : 1;
                  c3 = t.clamp(t.nextPowerOfTwo(s3.maxLineLength / t.EXTENT * 1024 * a5), 256, f2.maxTextureSize);
                }
                a4.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: c3, image: a4.gradient || void 0, clips: s3.lineClipsArray }), a4.texture ? a4.texture.update(a4.gradient) : a4.texture = new l(f2, a4.gradient, g2.RGBA), a4.version = o2.gradientVersion, n3 = a4.texture;
              }
              f2.activeTexture.set(g2.TEXTURE0), n3.bind(o2.stepInterpolant ? g2.NEAREST : g2.LINEAR, g2.CLAMP_TO_EDGE);
            }
            b2.draw(f2, g2.TRIANGLES, n2, e2.stencilModeForClipping(r3), c2, Ii.disabled, C2, T2, o2.id, s3.layoutVertexBuffer, s3.indexBuffer, s3.segments, o2.paint, e2.transform.zoom, v2, s3.layoutVertexBuffer2), x2 = !1;
          }
        }, fill: function(e2, i2, o2, a2) {
          let r2 = o2.paint.get("fill-color"), s2 = o2.paint.get("fill-opacity");
          if (s2.constantOr(1) === 0)
            return;
          let n2 = e2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e2.opaquePassEnabledForLayer() && !l2.constantOr(1) && r2.constantOr(t.Color.transparent).a === 1 && s2.constantOr(0) === 1 ? "opaque" : "translucent";
          if (e2.renderPass === c2) {
            let t2 = e2.depthModeForSublayer(1, e2.renderPass === "opaque" ? wi.ReadWrite : wi.ReadOnly);
            Ri(e2, i2, o2, a2, t2, n2, !1);
          }
          if (e2.renderPass === "translucent" && o2.paint.get("fill-antialias")) {
            let t2 = e2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, wi.ReadOnly);
            Ri(e2, i2, o2, a2, t2, n2, !0);
          }
        }, "fill-extrusion": function(t2, e2, i2, o2) {
          let a2 = i2.paint.get("fill-extrusion-opacity");
          if (a2 !== 0 && t2.renderPass === "translucent") {
            let r2 = new wi(t2.context.gl.LEQUAL, wi.ReadWrite, t2.depthRangeFor3D);
            if (a2 !== 1 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
              ki(t2, e2, i2, o2, r2, Ei.disabled, yi.disabled), ki(t2, e2, i2, o2, r2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
            else {
              let a3 = t2.colorModeForRenderPass();
              ki(t2, e2, i2, o2, r2, Ei.disabled, a3);
            }
          }
        }, hillshade: function(t2, e2, i2, o2) {
          if (t2.renderPass !== "offscreen" && t2.renderPass !== "translucent")
            return;
          let a2 = t2.context, r2 = t2.depthModeForSublayer(0, wi.ReadOnly), s2 = t2.colorModeForRenderPass(), [n2, l2] = t2.renderPass === "translucent" ? t2.stencilConfigForOverlap(o2) : [{}, o2];
          for (let o3 of l2) {
            let a3 = e2.getTile(o3);
            a3.needsHillshadePrepare !== void 0 && a3.needsHillshadePrepare && t2.renderPass === "offscreen" ? Fi(t2, a3, i2, r2, Ei.disabled, s2) : t2.renderPass === "translucent" && Bi(t2, o3, a3, i2, r2, n2[o3.overscaledZ], s2);
          }
          a2.viewport.set([0, 0, t2.width, t2.height]);
        }, raster: function(t2, e2, i2, o2) {
          if (t2.renderPass !== "translucent" || i2.paint.get("raster-opacity") === 0 || !o2.length)
            return;
          let a2 = t2.context, r2 = a2.gl, s2 = e2.getSource(), n2 = t2.useProgram("raster"), l2 = t2.colorModeForRenderPass(), [c2, h2] = s2 instanceof D ? [{}, o2] : t2.stencilConfigForOverlap(o2), u2 = h2[h2.length - 1].overscaledZ, d2 = !t2.options.moving;
          for (let o3 of h2) {
            let h3 = t2.depthModeForSublayer(o3.overscaledZ - u2, i2.paint.get("raster-opacity") === 1 ? wi.ReadWrite : wi.ReadOnly, r2.LESS), m2 = e2.getTile(o3);
            m2.registerFadeDuration(i2.paint.get("raster-fade-duration"));
            let _2 = e2.findLoadedParent(o3, 0), p2 = Oi(m2, _2, e2, i2, t2.transform, t2.style.terrain), f2, g2, x2 = i2.paint.get("raster-resampling") === "nearest" ? r2.NEAREST : r2.LINEAR;
            a2.activeTexture.set(r2.TEXTURE0), m2.texture.bind(x2, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST), a2.activeTexture.set(r2.TEXTURE1), _2 ? (_2.texture.bind(x2, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST), f2 = Math.pow(2, _2.tileID.overscaledZ - m2.tileID.overscaledZ), g2 = [m2.tileID.canonical.x * f2 % 1, m2.tileID.canonical.y * f2 % 1]) : m2.texture.bind(x2, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST);
            let v2 = t2.style.terrain && t2.style.terrain.getTerrainData(o3), y2 = v2 ? o3 : null, b2 = y2 ? y2.posMatrix : t2.transform.calculatePosMatrix(o3.toUnwrapped(), d2), w2 = Se(b2, g2 || [0, 0], f2 || 1, p2, i2);
            s2 instanceof D ? n2.draw(a2, r2.TRIANGLES, h3, Ei.disabled, l2, Ii.disabled, w2, v2, i2.id, s2.boundsBuffer, t2.quadTriangleIndexBuffer, s2.boundsSegments) : n2.draw(a2, r2.TRIANGLES, h3, c2[o3.overscaledZ], l2, Ii.disabled, w2, v2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
          }
        }, background: function(t2, e2, i2, o2) {
          let a2 = i2.paint.get("background-color"), r2 = i2.paint.get("background-opacity");
          if (r2 === 0)
            return;
          let s2 = t2.context, n2 = s2.gl, l2 = t2.transform, c2 = l2.tileSize, h2 = i2.paint.get("background-pattern");
          if (t2.isPatternMissing(h2))
            return;
          let u2 = !h2 && a2.a === 1 && r2 === 1 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (t2.renderPass !== u2)
            return;
          let d2 = Ei.disabled, m2 = t2.depthModeForSublayer(0, u2 === "opaque" ? wi.ReadWrite : wi.ReadOnly), _2 = t2.colorModeForRenderPass(), p2 = t2.useProgram(h2 ? "backgroundPattern" : "background"), f2 = o2 || l2.coveringTiles({ tileSize: c2, terrain: t2.style.terrain });
          h2 && (s2.activeTexture.set(n2.TEXTURE0), t2.imageManager.bind(t2.context));
          let g2 = i2.getCrossfadeParameters();
          for (let e3 of f2) {
            let l3 = o2 ? e3.posMatrix : t2.transform.calculatePosMatrix(e3.toUnwrapped()), u3 = h2 ? Le(l3, r2, t2, h2, { tileID: e3, tileSize: c2 }, g2) : Ae(l3, r2, a2), f3 = t2.style.terrain && t2.style.terrain.getTerrainData(e3);
            p2.draw(s2, n2.TRIANGLES, m2, d2, _2, Ii.disabled, u3, f3, i2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
          }
        }, debug: function(t2, e2, i2) {
          for (let o2 = 0; o2 < i2.length; o2++)
            Xi(t2, e2, i2[o2]);
        }, custom: function(t2, e2, i2) {
          let o2 = t2.context, a2 = i2.implementation;
          if (t2.renderPass === "offscreen") {
            let e3 = a2.prerender;
            e3 && (t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), e3.call(a2, o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState());
          } else if (t2.renderPass === "translucent") {
            t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), o2.setStencilMode(Ei.disabled);
            let e3 = a2.renderingMode === "3d" ? new wi(t2.context.gl.LEQUAL, wi.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, wi.ReadOnly);
            o2.setDepthMode(e3), a2.render(o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState(), o2.bindFramebuffer.set(null);
          }
        } };
        class Ji {
          constructor(e2, i2) {
            this.context = new bi(e2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: t.create(), renderTime: 0 }, this.setup(), this.numSublayers = O.maxUnderzooming + O.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Xt(), this.gpuTimers = {};
          }
          resize(t2, e2, i2) {
            if (this.width = t2 * i2, this.height = e2 * i2, this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (let t3 of this.style._order)
                this.style._layers[t3].resize();
          }
          setup() {
            let e2 = this.context, i2 = new t.PosArray();
            i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e2.createVertexBuffer(i2, Wt.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            let o2 = new t.PosArray();
            o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e2.createVertexBuffer(o2, Wt.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
            let a2 = new t.RasterBoundsArray();
            a2.emplaceBack(0, 0, 0, 0), a2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), a2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), a2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e2.createVertexBuffer(a2, S.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            let r2 = new t.PosArray();
            r2.emplaceBack(0, 0), r2.emplaceBack(1, 0), r2.emplaceBack(0, 1), r2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(r2, Wt.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            let s2 = new t.LineStripIndexArray();
            s2.emplaceBack(0), s2.emplaceBack(1), s2.emplaceBack(3), s2.emplaceBack(2), s2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(s2);
            let n2 = new t.TriangleIndexArray();
            n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(n2), this.emptyTexture = new l(e2, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e2.gl.RGBA);
            let c2 = this.context.gl;
            this.stencilClearMode = new Ei({ func: c2.ALWAYS, mask: 0 }, 0, 255, c2.ZERO, c2.ZERO, c2.ZERO);
          }
          clearStencil() {
            let e2 = this.context, i2 = e2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            let o2 = t.create();
            t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i2.TRIANGLES, wi.disabled, this.stencilClearMode, yi.disabled, Ii.disabled, xe(o2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t2, e2) {
            if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e2 || !e2.length)
              return;
            this.currentStencilSource = t2.source;
            let i2 = this.context, o2 = i2.gl;
            this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(yi.disabled), i2.setDepthMode(wi.disabled);
            let a2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (let t3 of e2) {
              let e3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, r2 = this.style.terrain && this.style.terrain.getTerrainData(t3);
              a2.draw(i2, o2.TRIANGLES, wi.disabled, new Ei({ func: o2.ALWAYS, mask: 0 }, e3, 255, o2.KEEP, o2.KEEP, o2.REPLACE), yi.disabled, Ii.disabled, xe(t3.posMatrix), r2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            let t2 = this.nextStencilID++, e2 = this.context.gl;
            return new Ei({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilModeForClipping(t2) {
            let e2 = this.context.gl;
            return new Ei({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilConfigForOverlap(t2) {
            let e2 = this.context.gl, i2 = t2.sort((t3, e3) => e3.overscaledZ - t3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, a2 = i2[0].overscaledZ - o2 + 1;
            if (a2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
              let t3 = {};
              for (let i3 = 0; i3 < a2; i3++)
                t3[i3 + o2] = new Ei({ func: e2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
              return this.nextStencilID += a2, [t3, i2];
            }
            return [{ [o2]: Ei.disabled }, i2];
          }
          colorModeForRenderPass() {
            let e2 = this.context.gl;
            return this._showOverdrawInspector ? new yi([e2.CONSTANT_COLOR, e2.ONE], new t.Color(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? yi.unblended : yi.alphaBlended;
          }
          depthModeForSublayer(t2, e2, i2) {
            if (!this.opaquePassEnabledForLayer())
              return wi.disabled;
            let o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
            return new wi(i2 || this.context.gl.LEQUAL, e2, [o2, o2]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e2, i2) {
            this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.exported.now()), this.imageManager.beginFrame();
            let o2 = this.style._order, a2 = this.style.sourceCaches, r2 = this.style.terrain && new Ki(this);
            for (let t2 in a2) {
              let e3 = a2[t2];
              e3.used && e3.prepare(this.context);
            }
            let s2 = {}, n2 = {}, l2 = {};
            for (let t2 in a2) {
              let e3 = a2[t2];
              s2[t2] = e3.getVisibleCoordinates(), n2[t2] = s2[t2].slice().reverse(), l2[t2] = e3.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let t2 = 0; t2 < o2.length; t2++)
              if (this.style._layers[o2[t2]].is3D()) {
                this.opaquePassCutoff = t2;
                break;
              }
            if (r2) {
              this.opaquePassCutoff = 0;
              let e3 = this.style.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
              (this.terrainFacilitator.dirty || !t.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || e3.length) && (t.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(e4, i3) {
                let o3 = e4.context, a3 = o3.gl, r3 = yi.unblended, s3 = new wi(a3.LEQUAL, wi.ReadWrite, [0, 1]), n3 = i3.getTerrainMesh(), l3 = i3.sourceCache.getRenderableTiles(), c2 = e4.useProgram("terrainDepth");
                o3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), o3.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), o3.clear({ color: t.Color.transparent, depth: 1 });
                for (let t2 of l3) {
                  let l4 = i3.getTerrainData(t2.tileID), h2 = e4.transform.calculatePosMatrix(t2.tileID.toUnwrapped());
                  c2.draw(o3, a3.TRIANGLES, s3, Ei.disabled, r3, Ii.backCCW, { u_matrix: h2 }, l4, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments);
                }
                o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, e4.width, e4.height]);
              }(this, this.style.terrain), function(e4, i3) {
                let o3 = e4.context, a3 = o3.gl, r3 = yi.unblended, s3 = new wi(a3.LEQUAL, wi.ReadWrite, [0, 1]), n3 = i3.getTerrainMesh(), l3 = i3.getCoordsTexture(), c2 = i3.sourceCache.getRenderableTiles(), h2 = e4.useProgram("terrainCoords");
                o3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), o3.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), o3.clear({ color: t.Color.transparent, depth: 1 }), i3.coordsIndex = [];
                for (let t2 of c2) {
                  let c3 = i3.getTerrainData(t2.tileID);
                  o3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, l3.texture);
                  let u2 = e4.transform.calculatePosMatrix(t2.tileID.toUnwrapped());
                  h2.draw(o3, a3.TRIANGLES, s3, Ei.disabled, r3, Ii.backCCW, { u_matrix: u2, u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0 }, c3, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments), i3.coordsIndex.push(t2.tileID.key);
                }
                o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, e4.width, e4.height]);
              }(this, this.style.terrain));
            }
            this.renderPass = "offscreen";
            for (let t2 of o2) {
              let e3 = this.style._layers[t2];
              if (!e3.hasOffscreenPass() || e3.isHidden(this.transform.zoom))
                continue;
              let i3 = n2[e3.source];
              (e3.type === "custom" || i3.length) && this.renderLayer(this, a2[e3.source], e3, i3);
            }
            if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !r2)
              for (this.renderPass = "opaque", this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                let t2 = this.style._layers[o2[this.currentLayer]], e3 = a2[t2.source], i3 = s2[t2.source];
                this._renderTileClippingMasks(t2, i3), this.renderLayer(this, e3, t2, i3);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
              let t2 = this.style._layers[o2[this.currentLayer]], e3 = a2[t2.source];
              if (r2 && r2.renderLayer(t2))
                continue;
              let i3 = (t2.type === "symbol" ? l2 : n2)[t2.source];
              this._renderTileClippingMasks(t2, s2[t2.source]), this.renderLayer(this, e3, t2, i3);
            }
            if (this.options.showTileBoundaries) {
              let t2, e3;
              Object.values(this.style._layers).forEach((i3) => {
                i3.source && !i3.isHidden(this.transform.zoom) && (i3.source !== (e3 && e3.id) && (e3 = this.style.sourceCaches[i3.source]), (!t2 || t2.getSource().maxzoom < e3.getSource().maxzoom) && (t2 = e3));
              }), t2 && Yi.debug(this, t2, t2.getVisibleCoordinates());
            }
            this.options.showPadding && function(t2) {
              let e3 = t2.transform.padding;
              qi(t2, t2.transform.height - (e3.top || 0), 3, Ui), qi(t2, e3.bottom || 0, 3, Ni), ji(t2, e3.left || 0, 3, Gi), ji(t2, t2.transform.width - (e3.right || 0), 3, Zi);
              let i3 = t2.transform.centerPoint;
              (function(t3, e4, i4, o3) {
                $i(t3, e4 - 1, i4 - 10, 2, 20, o3), $i(t3, e4 - 10, i4 - 1, 20, 2, o3);
              })(t2, i3.x, t2.transform.height - i3.y, Vi);
            }(this), this.context.setDefault();
          }
          renderLayer(t2, e2, i2, o2) {
            i2.isHidden(this.transform.zoom) || (i2.type === "background" || i2.type === "custom" || (o2 || []).length) && (this.id = i2.id, this.gpuTimingStart(i2), Yi[i2.type](t2, e2, i2, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
          }
          gpuTimingStart(t2) {
            if (!this.options.gpuTiming)
              return;
            let e2 = this.context.extTimerQuery, i2 = this.gpuTimers[t2.id];
            i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e2.createQueryEXT() }), i2.calls++, e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, i2.query);
          }
          gpuTimingEnd() {
            if (!this.options.gpuTiming)
              return;
            let t2 = this.context.extTimerQuery;
            t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            let t2 = this.gpuTimers;
            return this.gpuTimers = {}, t2;
          }
          queryGpuTimers(t2) {
            let e2 = {};
            for (let i2 in t2) {
              let o2 = t2[i2], a2 = this.context.extTimerQuery, r2 = a2.getQueryObjectEXT(o2.query, a2.QUERY_RESULT_EXT) / 1e6;
              a2.deleteQueryEXT(o2.query), e2[i2] = r2;
            }
            return e2;
          }
          translatePosMatrix(e2, i2, o2, a2, r2) {
            if (!o2[0] && !o2[1])
              return e2;
            let s2 = r2 ? a2 === "map" ? this.transform.angle : 0 : a2 === "viewport" ? -this.transform.angle : 0;
            if (s2) {
              let t2 = Math.sin(s2), e3 = Math.cos(s2);
              o2 = [o2[0] * e3 - o2[1] * t2, o2[0] * t2 + o2[1] * e3];
            }
            let n2 = [r2 ? o2[0] : bt(i2, o2[0], this.transform.zoom), r2 ? o2[1] : bt(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return t.translate(l2, e2, n2), l2;
          }
          saveTileTexture(t2) {
            let e2 = this._tileTextures[t2.size[0]];
            e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
          }
          getTileTexture(t2) {
            let e2 = this._tileTextures[t2];
            return e2 && e2.length > 0 ? e2.pop() : null;
          }
          isPatternMissing(t2) {
            if (!t2)
              return !1;
            if (!t2.from || !t2.to)
              return !0;
            let e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
            return !e2 || !i2;
          }
          useProgram(t2, e2) {
            this.cache = this.cache || {};
            let i2 = t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.terrain ? "/terrain" : "");
            return this.cache[i2] || (this.cache[i2] = new ne(this.context, t2, oe[t2], e2, Re[t2], this._showOverdrawInspector, this.style.terrain)), this.cache[i2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            let t2 = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new l(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
        }
        class Qi {
          constructor(t2, e2) {
            this.points = t2, this.planes = e2;
          }
          static fromInvProjectionMatrix(e2, i2, o2) {
            let a2 = Math.pow(2, o2), r2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((o3) => {
              let r3 = 1 / (o3 = t.transformMat4([], o3, e2))[3] / i2 * a2;
              return t.mul$1(o3, o3, [r3, r3, 1 / o3[3], r3]);
            }), s2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e3) => {
              let i3 = t.sub([], r2[e3[0]], r2[e3[1]]), o3 = t.sub([], r2[e3[2]], r2[e3[1]]), a3 = t.normalize([], t.cross([], i3, o3)), s3 = -t.dot(a3, r2[e3[1]]);
              return a3.concat(s3);
            });
            return new Qi(r2, s2);
          }
        }
        class to {
          constructor(e2, i2) {
            this.min = e2, this.max = i2, this.center = t.scale$1([], t.add([], this.min, this.max), 0.5);
          }
          quadrant(e2) {
            let i2 = [e2 % 2 == 0, e2 < 2], o2 = t.clone$2(this.min), a2 = t.clone$2(this.max);
            for (let t2 = 0; t2 < i2.length; t2++)
              o2[t2] = i2[t2] ? this.min[t2] : this.center[t2], a2[t2] = i2[t2] ? this.center[t2] : this.max[t2];
            return a2[2] = this.max[2], new to(o2, a2);
          }
          distanceX(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }
          distanceY(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }
          intersects(e2) {
            let i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]], o2 = !0;
            for (let a2 = 0; a2 < e2.planes.length; a2++) {
              let r2 = e2.planes[a2], s2 = 0;
              for (let e3 = 0; e3 < i2.length; e3++)
                t.dot$1(r2, i2[e3]) >= 0 && s2++;
              if (s2 === 0)
                return 0;
              s2 !== i2.length && (o2 = !1);
            }
            if (o2)
              return 2;
            for (let t2 = 0; t2 < 3; t2++) {
              let i3 = Number.MAX_VALUE, o3 = -Number.MAX_VALUE;
              for (let a2 = 0; a2 < e2.points.length; a2++) {
                let r2 = e2.points[a2][t2] - this.min[t2];
                i3 = Math.min(i3, r2), o3 = Math.max(o3, r2);
              }
              if (o3 < 0 || i3 > this.max[t2] - this.min[t2])
                return 0;
            }
            return 1;
          }
        }
        class eo {
          constructor(t2 = 0, e2 = 0, i2 = 0, o2 = 0) {
            if (isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t2, this.bottom = e2, this.left = i2, this.right = o2;
          }
          interpolate(e2, i2, o2) {
            return i2.top != null && e2.top != null && (this.top = t.number(e2.top, i2.top, o2)), i2.bottom != null && e2.bottom != null && (this.bottom = t.number(e2.bottom, i2.bottom, o2)), i2.left != null && e2.left != null && (this.left = t.number(e2.left, i2.left, o2)), i2.right != null && e2.right != null && (this.right = t.number(e2.right, i2.right, o2)), this;
          }
          getCenter(e2, i2) {
            let o2 = t.clamp((this.left + e2 - this.right) / 2, 0, e2), a2 = t.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
            return new t.pointGeometry(o2, a2);
          }
          equals(t2) {
            return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
          }
          clone() {
            return new eo(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        class io {
          constructor(e2, i2, o2, a2, r2) {
            this.tileSize = 512, this.maxValidLatitude = 85.051129, this.freezeElevation = !1, this._renderWorldCopies = r2 === void 0 || !!r2, this._minZoom = e2 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 ?? 0, this._maxPitch = a2 ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new eo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          clone() {
            let t2 = new io(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2._center = this._center, t2._elevation = this._elevation, t2.zoom = this.zoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._unmodified = this._unmodified, t2._edgeInsets = this._edgeInsets.clone(), t2._calcMatrices(), t2;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t2) {
            this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t2) {
            this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t2) {
            this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t2) {
            this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(t2) {
            t2 === void 0 ? t2 = !0 : t2 === null && (t2 = !1), this._renderWorldCopies = t2;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new t.pointGeometry(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(e2) {
            let i2 = -t.wrap(e2, -180, 180) * Math.PI / 180;
            var o2;
            this.angle !== i2 && (this._unmodified = !1, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new t.ARRAY_TYPE(4), t.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(t2, e3, i3) {
              var o3 = e3[0], a2 = e3[1], r2 = e3[2], s2 = e3[3], n2 = Math.sin(i3), l2 = Math.cos(i3);
              t2[0] = o3 * l2 + r2 * n2, t2[1] = a2 * l2 + s2 * n2, t2[2] = o3 * -n2 + r2 * l2, t2[3] = a2 * -n2 + s2 * l2;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(e2) {
            let i2 = t.clamp(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = !1, this._pitch = i2, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = !1, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t2) {
            let e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
            this._zoom !== e2 && (this._unmodified = !1, this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom, this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(t2) {
            t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = !1, this._center = t2, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t2) {
            t2 !== this._elevation && (this._elevation = t2, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t2) {
            this._edgeInsets.equals(t2) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(t2) {
            return this._edgeInsets.equals(t2);
          }
          interpolatePadding(t2, e2, i2) {
            this._unmodified = !1, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t2) {
            let e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
            return Math.max(0, e2);
          }
          getVisibleUnwrappedCoordinates(e2) {
            let i2 = [new t.UnwrappedTileID(0, e2)];
            if (this._renderWorldCopies) {
              let o2 = this.pointCoordinate(new t.pointGeometry(0, 0)), a2 = this.pointCoordinate(new t.pointGeometry(this.width, 0)), r2 = this.pointCoordinate(new t.pointGeometry(this.width, this.height)), s2 = this.pointCoordinate(new t.pointGeometry(0, this.height)), n2 = Math.floor(Math.min(o2.x, a2.x, r2.x, s2.x)), l2 = Math.floor(Math.max(o2.x, a2.x, r2.x, s2.x)), c2 = 1;
              for (let o3 = n2 - c2; o3 <= l2 + c2; o3++)
                o3 !== 0 && i2.push(new t.UnwrappedTileID(o3, e2));
            }
            return i2;
          }
          coveringTiles(e2) {
            var i2, o2;
            let a2 = this.coveringZoomLevel(e2), r2 = a2;
            if (e2.minzoom !== void 0 && a2 < e2.minzoom)
              return [];
            e2.maxzoom !== void 0 && a2 > e2.maxzoom && (a2 = e2.maxzoom);
            let s2 = this.pointCoordinate(this.getCameraPoint()), n2 = t.MercatorCoordinate.fromLngLat(this.center), l2 = Math.pow(2, a2), c2 = [l2 * s2.x, l2 * s2.y, 0], h2 = [l2 * n2.x, l2 * n2.y, 0], u2 = Qi.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a2), d2 = e2.minzoom || 0;
            !e2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = a2);
            let m2 = e2.terrain ? 2 / Math.min(this.tileSize, e2.tileSize) * this.tileSize : 3, _2 = (t2) => ({ aabb: new to([t2 * l2, 0, 0], [(t2 + 1) * l2, l2, 0]), zoom: 0, x: 0, y: 0, wrap: t2, fullyVisible: !1 }), p2 = [], f2 = [], g2 = a2, x2 = e2.reparseOverscaled ? r2 : a2;
            if (this._renderWorldCopies)
              for (let t2 = 1; t2 <= 3; t2++)
                p2.push(_2(-t2)), p2.push(_2(t2));
            for (p2.push(_2(0)); p2.length > 0; ) {
              let a3 = p2.pop(), r3 = a3.x, s3 = a3.y, n3 = a3.fullyVisible;
              if (!n3) {
                let t2 = a3.aabb.intersects(u2);
                if (t2 === 0)
                  continue;
                n3 = t2 === 2;
              }
              let l3 = e2.terrain ? c2 : h2, _3 = a3.aabb.distanceX(l3), v2 = a3.aabb.distanceY(l3), y2 = Math.max(Math.abs(_3), Math.abs(v2)), b2 = m2 + (1 << g2 - a3.zoom) - 2;
              if (a3.zoom === g2 || y2 > b2 && a3.zoom >= d2) {
                let e3 = g2 - a3.zoom, i3 = c2[0] - 0.5 - (r3 << e3), o3 = c2[1] - 0.5 - (s3 << e3);
                f2.push({ tileID: new t.OverscaledTileID(a3.zoom === g2 ? x2 : a3.zoom, a3.wrap, a3.zoom, r3, s3), distanceSq: t.sqrLen([h2[0] - 0.5 - r3, h2[1] - 0.5 - s3]), tileDistanceToCamera: Math.sqrt(i3 * i3 + o3 * o3) });
              } else
                for (let l4 = 0; l4 < 4; l4++) {
                  let c3 = (r3 << 1) + l4 % 2, h3 = (s3 << 1) + (l4 >> 1), u3 = a3.zoom + 1, d3 = a3.aabb.quadrant(l4);
                  if (e2.terrain) {
                    let r4 = new t.OverscaledTileID(u3, a3.wrap, u3, c3, h3), s4 = e2.terrain.getMinMaxElevation(r4), n4 = (i2 = s4.minElevation) !== null && i2 !== void 0 ? i2 : this.elevation, l5 = (o2 = s4.maxElevation) !== null && o2 !== void 0 ? o2 : this.elevation;
                    d3 = new to([d3.min[0], d3.min[1], n4], [d3.max[0], d3.max[1], l5]);
                  }
                  p2.push({ aabb: d3, zoom: u3, x: c3, y: h3, wrap: a3.wrap, fullyVisible: n3 });
                }
            }
            return f2.sort((t2, e3) => t2.distanceSq - e3.distanceSq).map((t2) => t2.tileID);
          }
          resize(t2, e2) {
            this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t2) {
            return Math.pow(2, t2);
          }
          scaleZoom(t2) {
            return Math.log(t2) / Math.LN2;
          }
          project(e2) {
            let i2 = t.clamp(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
            return new t.pointGeometry(t.mercatorXfromLng(e2.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
          }
          unproject(e2) {
            return new t.MercatorCoordinate(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          updateElevation(t2) {
            this.freezeElevation || (this.elevation = t2 ? this.getElevation(this._center, t2) : 0);
          }
          getElevation(e2, i2) {
            let o2 = t.MercatorCoordinate.fromLngLat(e2), a2 = (1 << this.tileZoom) * t.EXTENT, r2 = o2.x * a2, s2 = o2.y * a2, n2 = Math.floor(r2 / t.EXTENT), l2 = Math.floor(s2 / t.EXTENT), c2 = new t.OverscaledTileID(this.tileZoom, 0, this.tileZoom, n2, l2);
            return i2.getElevation(c2, r2 % t.EXTENT, s2 % t.EXTENT, t.EXTENT);
          }
          getCameraPosition() {
            return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
          }
          recalculateZoom(e2) {
            let i2 = this.pointLocation(this.centerPoint, e2), o2 = this.getElevation(i2, e2);
            if (!(this.elevation - o2))
              return;
            let a2 = this.getCameraPosition(), r2 = t.MercatorCoordinate.fromLngLat(a2.lngLat, a2.altitude), s2 = t.MercatorCoordinate.fromLngLat(i2, o2), n2 = r2.x - s2.x, l2 = r2.y - s2.y, c2 = r2.z - s2.z, h2 = Math.sqrt(n2 * n2 + l2 * l2 + c2 * c2), u2 = this.scaleZoom(this.cameraToCenterDistance / h2 / this.tileSize);
            this._elevation = o2, this._center = i2, this.zoom = u2;
          }
          setLocationAtPoint(e2, i2) {
            let o2 = this.pointCoordinate(i2), a2 = this.pointCoordinate(this.centerPoint), r2 = this.locationCoordinate(e2), s2 = new t.MercatorCoordinate(r2.x - (o2.x - a2.x), r2.y - (o2.y - a2.y));
            this.center = this.coordinateLocation(s2), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(t2, e2) {
            return e2 ? this.coordinatePoint(this.locationCoordinate(t2), this.getElevation(t2, e2), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t2));
          }
          pointLocation(t2, e2) {
            return this.coordinateLocation(this.pointCoordinate(t2, e2));
          }
          locationCoordinate(e2) {
            return t.MercatorCoordinate.fromLngLat(e2);
          }
          coordinateLocation(t2) {
            return t2 && t2.toLngLat();
          }
          pointCoordinate(e2, i2) {
            if (i2) {
              let t2 = i2.pointCoordinate(e2);
              if (t2 != null)
                return t2;
            }
            let o2 = [e2.x, e2.y, 0, 1], a2 = [e2.x, e2.y, 1, 1];
            t.transformMat4(o2, o2, this.pixelMatrixInverse), t.transformMat4(a2, a2, this.pixelMatrixInverse);
            let r2 = o2[3], s2 = a2[3], n2 = o2[1] / r2, l2 = a2[1] / s2, c2 = o2[2] / r2, h2 = a2[2] / s2, u2 = c2 === h2 ? 0 : (0 - c2) / (h2 - c2);
            return new t.MercatorCoordinate(t.number(o2[0] / r2, a2[0] / s2, u2) / this.worldSize, t.number(n2, l2, u2) / this.worldSize);
          }
          coordinatePoint(e2, i2 = 0, o2 = this.pixelMatrix) {
            let a2 = [e2.x * this.worldSize, e2.y * this.worldSize, i2, 1];
            return t.transformMat4(a2, a2, o2), new t.pointGeometry(a2[0] / a2[3], a2[1] / a2[3]);
          }
          getBounds() {
            let e2 = Math.max(0, this.height / 2 - this.getHorizon());
            return new t.LngLatBounds().extend(this.pointLocation(new t.pointGeometry(0, e2))).extend(this.pointLocation(new t.pointGeometry(this.width, e2))).extend(this.pointLocation(new t.pointGeometry(this.width, this.height))).extend(this.pointLocation(new t.pointGeometry(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          getHorizon() {
            return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
          }
          setMaxBounds(t2) {
            t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
          }
          calculatePosMatrix(e2, i2 = !1) {
            let o2 = e2.key, a2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (a2[o2])
              return a2[o2];
            let r2 = e2.canonical, s2 = this.worldSize / this.zoomScale(r2.z), n2 = r2.x + Math.pow(2, r2.z) * e2.wrap, l2 = t.identity(new Float64Array(16));
            return t.translate(l2, l2, [n2 * s2, r2.y * s2, 0]), t.scale(l2, l2, [s2 / t.EXTENT, s2 / t.EXTENT, 1]), t.multiply(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), a2[o2] = new Float32Array(l2), a2[o2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            this._constraining = !0;
            let e2, i2, o2, a2, r2 = -90, s2 = 90, n2 = -180, l2 = 180, c2 = this.size, h2 = this._unmodified;
            if (this.latRange) {
              let i3 = this.latRange;
              r2 = t.mercatorYfromLat(i3[1]) * this.worldSize, s2 = t.mercatorYfromLat(i3[0]) * this.worldSize, e2 = s2 - r2 < c2.y ? c2.y / (s2 - r2) : 0;
            }
            if (this.lngRange) {
              let e3 = this.lngRange;
              n2 = t.wrap(t.mercatorXfromLng(e3[0]) * this.worldSize, 0, this.worldSize), l2 = t.wrap(t.mercatorXfromLng(e3[1]) * this.worldSize, 0, this.worldSize), l2 < n2 && (l2 += this.worldSize), i2 = l2 - n2 < c2.x ? c2.x / (l2 - n2) : 0;
            }
            let u2 = this.point, d2 = Math.max(i2 || 0, e2 || 0);
            if (d2)
              return this.center = this.unproject(new t.pointGeometry(i2 ? (l2 + n2) / 2 : u2.x, e2 ? (s2 + r2) / 2 : u2.y)), this.zoom += this.scaleZoom(d2), this._unmodified = h2, void (this._constraining = !1);
            if (this.latRange) {
              let t2 = u2.y, e3 = c2.y / 2;
              t2 - e3 < r2 && (a2 = r2 + e3), t2 + e3 > s2 && (a2 = s2 - e3);
            }
            if (this.lngRange) {
              let e3 = (n2 + l2) / 2, i3 = t.wrap(u2.x, e3 - this.worldSize / 2, e3 + this.worldSize / 2), a3 = c2.x / 2;
              i3 - a3 < n2 && (o2 = n2 + a3), i3 + a3 > l2 && (o2 = l2 - a3);
            }
            o2 === void 0 && a2 === void 0 || (this.center = this.unproject(new t.pointGeometry(o2 !== void 0 ? o2 : u2.x, a2 !== void 0 ? a2 : u2.y)).wrap()), this._unmodified = h2, this._constraining = !1;
          }
          _calcMatrices() {
            if (!this.height)
              return;
            let e2 = this.centerOffset, i2 = this.point.x, o2 = this.point.y;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
            let a2 = t.identity(new Float64Array(16));
            t.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), t.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = t.identity(new Float64Array(16)), t.scale(a2, a2, [1, -1, 1]), t.translate(a2, a2, [-1, -1, 0]), t.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
            let r2 = Math.PI / 2 + this._pitch, s2 = this._fov * (0.5 + e2.y / this.height), n2 = Math.sin(s2) * this.cameraToSeaLevelDistance / Math.sin(t.clamp(Math.PI - r2 - s2, 0.01, Math.PI - 0.01)), l2 = this.getHorizon(), c2 = 2 * Math.atan(l2 / this.cameraToCenterDistance) * (0.5 + e2.y / (2 * l2)), h2 = Math.sin(c2) * this.cameraToSeaLevelDistance / Math.sin(t.clamp(Math.PI - r2 - c2, 0.01, Math.PI - 0.01)), u2 = Math.cos(Math.PI / 2 - this._pitch) * n2 + this.cameraToSeaLevelDistance, d2 = Math.cos(Math.PI / 2 - this._pitch) * h2 + this.cameraToSeaLevelDistance, m2 = 1.01 * Math.min(u2, d2), _2 = this.height / 50;
            a2 = new Float64Array(16), t.perspective(a2, this._fov, this.width / this.height, _2, m2), a2[8] = 2 * -e2.x / this.width, a2[9] = 2 * e2.y / this.height, t.scale(a2, a2, [1, -1, 1]), t.translate(a2, a2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(a2, a2, this._pitch), t.rotateZ(a2, a2, this.angle), t.translate(a2, a2, [-i2, -o2, 0]), this.mercatorMatrix = t.scale([], a2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(a2, a2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, a2), t.translate(a2, a2, [0, 0, -this.elevation]), this.projMatrix = a2, this.invProjMatrix = t.invert([], a2), this.pixelMatrix3D = t.multiply(new Float64Array(16), this.labelPlaneMatrix, a2);
            let p2 = this.width % 2 / 2, f2 = this.height % 2 / 2, g2 = Math.cos(this.angle), x2 = Math.sin(this.angle), v2 = i2 - Math.round(i2) + g2 * p2 + x2 * f2, y2 = o2 - Math.round(o2) + g2 * f2 + x2 * p2, b2 = new Float64Array(a2);
            if (t.translate(b2, b2, [v2 > 0.5 ? v2 - 1 : v2, y2 > 0.5 ? y2 - 1 : y2, 0]), this.alignedProjMatrix = b2, a2 = t.invert(new Float64Array(16), this.pixelMatrix), !a2)
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = a2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          maxPitchScaleFactor() {
            if (!this.pixelMatrixInverse)
              return 1;
            let e2 = this.pointCoordinate(new t.pointGeometry(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
            return t.transformMat4(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }
          getCameraPoint() {
            let e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new t.pointGeometry(0, e2));
          }
          getCameraQueryGeometry(e2) {
            let i2 = this.getCameraPoint();
            if (e2.length === 1)
              return [e2[0], i2];
            {
              let o2 = i2.x, a2 = i2.y, r2 = i2.x, s2 = i2.y;
              for (let t2 of e2)
                o2 = Math.min(o2, t2.x), a2 = Math.min(a2, t2.y), r2 = Math.max(r2, t2.x), s2 = Math.max(s2, t2.y);
              return [new t.pointGeometry(o2, a2), new t.pointGeometry(r2, a2), new t.pointGeometry(r2, s2), new t.pointGeometry(o2, s2), new t.pointGeometry(o2, a2)];
            }
          }
        }
        class oo {
          constructor(e2) {
            this._hashName = e2 && encodeURIComponent(e2), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = function(t2, e3) {
              let i2 = !1, o2 = null, a2 = () => {
                o2 = null, i2 && (t2(), o2 = setTimeout(a2, 300), i2 = !1);
              };
              return () => (i2 = !0, o2 || a2(), o2);
            }(this._updateHashUnthrottled.bind(this));
          }
          addTo(t2) {
            return this._map = t2, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(t2) {
            let e2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, o2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, o2), r2 = Math.round(e2.lng * a2) / a2, s2 = Math.round(e2.lat * a2) / a2, n2 = this._map.getBearing(), l2 = this._map.getPitch(), c2 = "";
            if (c2 += t2 ? `/${r2}/${s2}/${i2}` : `${i2}/${s2}/${r2}`, (n2 || l2) && (c2 += "/" + Math.round(10 * n2) / 10), l2 && (c2 += `/${Math.round(l2)}`), this._hashName) {
              let t3 = this._hashName, e3 = !1, i3 = window.location.hash.slice(1).split("&").map((i4) => {
                let o3 = i4.split("=")[0];
                return o3 === t3 ? (e3 = !0, `${o3}=${c2}`) : i4;
              }).filter((t4) => t4);
              return e3 || i3.push(`${t3}=${c2}`), `#${i3.join("&")}`;
            }
            return `#${c2}`;
          }
          _getCurrentHash() {
            let t2 = window.location.hash.replace("#", "");
            if (this._hashName) {
              let e2;
              return t2.split("&").map((t3) => t3.split("=")).forEach((t3) => {
                t3[0] === this._hashName && (e2 = t3);
              }), (e2 && e2[1] || "").split("/");
            }
            return t2.split("/");
          }
          _onHashChange() {
            let t2 = this._getCurrentHash();
            if (t2.length >= 3 && !t2.some((t3) => isNaN(t3))) {
              let e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: e2, pitch: +(t2[4] || 0) }), !0;
            }
            return !1;
          }
          _updateHashUnthrottled() {
            let t2 = window.location.href.replace(/(#.+)?$/, this.getHashString());
            try {
              window.history.replaceState(window.history.state, null, t2);
            } catch {
            }
          }
        }
        let ao = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, ro = t.extend({ deceleration: 2500, maxSpeed: 1400 }, ao), so = t.extend({ deceleration: 20, maxSpeed: 1400 }, ao), no = t.extend({ deceleration: 1e3, maxSpeed: 360 }, ao), lo = t.extend({ deceleration: 1e3, maxSpeed: 90 }, ao);
        class co {
          constructor(t2) {
            this._map = t2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.exported.now(), settings: e2 });
          }
          _drainInertiaBuffer() {
            let e2 = this._inertiaBuffer, i2 = t.exported.now();
            for (; e2.length > 0 && i2 - e2[0].time > 160; )
              e2.shift();
          }
          _onMoveEnd(e2) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            let i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
            for (let { settings: t2 } of this._inertiaBuffer)
              i2.zoom += t2.zoomDelta || 0, i2.bearing += t2.bearingDelta || 0, i2.pitch += t2.pitchDelta || 0, t2.panDelta && i2.pan._add(t2.panDelta), t2.around && (i2.around = t2.around), t2.pinchAround && (i2.pinchAround = t2.pinchAround);
            let o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a2 = {};
            if (i2.pan.mag()) {
              let r2 = uo(i2.pan.mag(), o2, t.extend({}, ro, e2 || {}));
              a2.offset = i2.pan.mult(r2.amount / i2.pan.mag()), a2.center = this._map.transform.center, ho(a2, r2);
            }
            if (i2.zoom) {
              let t2 = uo(i2.zoom, o2, so);
              a2.zoom = this._map.transform.zoom + t2.amount, ho(a2, t2);
            }
            if (i2.bearing) {
              let e3 = uo(i2.bearing, o2, no);
              a2.bearing = this._map.transform.bearing + t.clamp(e3.amount, -179, 179), ho(a2, e3);
            }
            if (i2.pitch) {
              let t2 = uo(i2.pitch, o2, lo);
              a2.pitch = this._map.transform.pitch + t2.amount, ho(a2, t2);
            }
            if (a2.zoom || a2.bearing) {
              let t2 = i2.pinchAround === void 0 ? i2.around : i2.pinchAround;
              a2.around = t2 ? this._map.unproject(t2) : this._map.getCenter();
            }
            return this.clear(), t.extend(a2, { noMoveStart: !0 });
          }
        }
        function ho(t2, e2) {
          (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
        }
        function uo(e2, i2, o2) {
          let { maxSpeed: a2, linearity: r2, deceleration: s2 } = o2, n2 = t.clamp(e2 * r2 / (i2 / 1e3), -a2, a2), l2 = Math.abs(n2) / (s2 * r2);
          return { easing: o2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
        }
        class mo extends t.Event {
          constructor(e2, i2, o2, a2 = {}) {
            let s2 = r.mousePos(i2.getCanvasContainer(), o2), n2 = i2.unproject(s2);
            super(e2, t.extend({ point: s2, lngLat: n2, originalEvent: o2 }, a2)), this._defaultPrevented = !1, this.target = i2;
          }
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
        }
        class _o extends t.Event {
          constructor(e2, i2, o2) {
            let a2 = e2 === "touchend" ? o2.changedTouches : o2.touches, s2 = r.touchPos(i2.getCanvasContainer(), a2), n2 = s2.map((t2) => i2.unproject(t2)), l2 = s2.reduce((t2, e3, i3, o3) => t2.add(e3.div(o3.length)), new t.pointGeometry(0, 0));
            super(e2, { points: s2, point: l2, lngLats: n2, lngLat: i2.unproject(l2), originalEvent: o2 }), this._defaultPrevented = !1;
          }
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
        }
        class po extends t.Event {
          constructor(t2, e2, i2) {
            super(t2, { originalEvent: i2 }), this._defaultPrevented = !1;
          }
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
        }
        class fo {
          constructor(t2, e2) {
            this._map = t2, this._clickTolerance = e2.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t2) {
            return this._firePreventable(new po(t2.type, this._map, t2));
          }
          mousedown(t2, e2) {
            return this._mousedownPos = e2, this._firePreventable(new mo(t2.type, this._map, t2));
          }
          mouseup(t2) {
            this._map.fire(new mo(t2.type, this._map, t2));
          }
          click(t2, e2) {
            this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new mo(t2.type, this._map, t2));
          }
          dblclick(t2) {
            return this._firePreventable(new mo(t2.type, this._map, t2));
          }
          mouseover(t2) {
            this._map.fire(new mo(t2.type, this._map, t2));
          }
          mouseout(t2) {
            this._map.fire(new mo(t2.type, this._map, t2));
          }
          touchstart(t2) {
            return this._firePreventable(new _o(t2.type, this._map, t2));
          }
          touchmove(t2) {
            this._map.fire(new _o(t2.type, this._map, t2));
          }
          touchend(t2) {
            this._map.fire(new _o(t2.type, this._map, t2));
          }
          touchcancel(t2) {
            this._map.fire(new _o(t2.type, this._map, t2));
          }
          _firePreventable(t2) {
            if (this._map.fire(t2), t2.defaultPrevented)
              return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class go {
          constructor(t2) {
            this._map = t2;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(t2) {
            this._map.fire(new mo(t2.type, this._map, t2));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new mo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t2) {
            this._delayContextMenu ? this._contextMenuEvent = t2 : this._ignoreContextMenu || this._map.fire(new mo(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class xo {
          constructor(t2, e2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(t2, e2) {
            this.isEnabled() && t2.shiftKey && t2.button === 0 && (r.disableDrag(), this._startPos = this._lastPos = e2, this._active = !0);
          }
          mousemoveWindow(t2, e2) {
            if (!this._active)
              return;
            let i2 = e2;
            if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
              return;
            let o2 = this._startPos;
            this._lastPos = i2, this._box || (this._box = r.create("div", "maplibregl-boxzoom mapboxgl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair", "mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
            let a2 = Math.min(o2.x, i2.x), s2 = Math.max(o2.x, i2.x), n2 = Math.min(o2.y, i2.y), l2 = Math.max(o2.y, i2.y);
            r.setTransform(this._box, `translate(${a2}px,${n2}px)`), this._box.style.width = s2 - a2 + "px", this._box.style.height = l2 - n2 + "px";
          }
          mouseupWindow(e2, i2) {
            if (!this._active || e2.button !== 0)
              return;
            let o2 = this._startPos, a2 = i2;
            if (this.reset(), r.suppressClick(), o2.x !== a2.x || o2.y !== a2.y)
              return this._map.fire(new t.Event("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (t2) => t2.fitScreenCoordinates(o2, a2, this._map.getBearing(), { linear: !0 }) };
            this._fireEvent("boxzoomcancel", e2);
          }
          keydown(t2) {
            this._active && t2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t2));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair", "mapboxgl-crosshair"), this._box && (r.remove(this._box), this._box = null), r.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e2, i2) {
            return this._map.fire(new t.Event(e2, { originalEvent: i2 }));
          }
        }
        function vo(t2, e2) {
          if (t2.length !== e2.length)
            throw new Error(`The number of touches and points are not equal - touches ${t2.length}, points ${e2.length}`);
          let i2 = {};
          for (let o2 = 0; o2 < t2.length; o2++)
            i2[t2[o2].identifier] = e2[o2];
          return i2;
        }
        class yo {
          constructor(t2) {
            this.reset(), this.numTouches = t2.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(e2, i2, o2) {
            (this.centroid || o2.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e2.timeStamp), o2.length === this.numTouches && (this.centroid = function(e3) {
              let i3 = new t.pointGeometry(0, 0);
              for (let t2 of e3)
                i3._add(t2);
              return i3.div(e3.length);
            }(i2), this.touches = vo(o2, i2)));
          }
          touchmove(t2, e2, i2) {
            if (this.aborted || !this.centroid)
              return;
            let o2 = vo(i2, e2);
            for (let t3 in this.touches) {
              let e3 = this.touches[t3], i3 = o2[t3];
              (!i3 || i3.dist(e3) > 30) && (this.aborted = !0);
            }
          }
          touchend(t2, e2, i2) {
            if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = !0), i2.length === 0) {
              let t3 = !this.aborted && this.centroid;
              if (this.reset(), t3)
                return t3;
            }
          }
        }
        class bo {
          constructor(t2) {
            this.singleTap = new yo(t2), this.numTaps = t2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t2, e2, i2) {
            this.singleTap.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            this.singleTap.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            let o2 = this.singleTap.touchend(t2, e2, i2);
            if (o2) {
              let e3 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
              if (e3 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                return this.reset(), o2;
            }
          }
        }
        class wo {
          constructor() {
            this._zoomIn = new bo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new bo({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t2, e2, i2) {
            this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            let o2 = this._zoomIn.touchend(t2, e2, i2), a2 = this._zoomOut.touchend(t2, e2, i2);
            return o2 ? (this._active = !0, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: e3.getZoom() + 1, around: e3.unproject(o2) }, { originalEvent: t2 }) }) : a2 ? (this._active = !0, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: e3.getZoom() - 1, around: e3.unproject(a2) }, { originalEvent: t2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        let To = { 0: 1, 2: 2 };
        class Eo {
          constructor(t2) {
            this.reset(), this._clickTolerance = t2.clickTolerance || 1;
          }
          reset() {
            this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
          }
          _correctButton(t2, e2) {
            return !1;
          }
          _move(t2, e2) {
            return {};
          }
          mousedown(t2, e2) {
            if (this._lastPoint)
              return;
            let i2 = r.mouseButton(t2);
            this._correctButton(t2, i2) && (this._lastPoint = e2, this._eventButton = i2);
          }
          mousemoveWindow(t2, e2) {
            let i2 = this._lastPoint;
            if (i2) {
              if (t2.preventDefault(), function(t3, e3) {
                let i3 = To[e3];
                return t3.buttons === void 0 || (t3.buttons & i3) !== i3;
              }(t2, this._eventButton))
                this.reset();
              else if (this._moved || !(e2.dist(i2) < this._clickTolerance))
                return this._moved = !0, this._lastPoint = e2, this._move(i2, e2);
            }
          }
          mouseupWindow(t2) {
            this._lastPoint && r.mouseButton(t2) === this._eventButton && (this._moved && r.suppressClick(), this.reset());
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Io extends Eo {
          mousedown(t2, e2) {
            super.mousedown(t2, e2), this._lastPoint && (this._active = !0);
          }
          _correctButton(t2, e2) {
            return e2 === 0 && !t2.ctrlKey;
          }
          _move(t2, e2) {
            return { around: e2, panDelta: e2.sub(t2) };
          }
        }
        class Co extends Eo {
          _correctButton(t2, e2) {
            return e2 === 0 && t2.ctrlKey || e2 === 2;
          }
          _move(t2, e2) {
            let i2 = 0.8 * (e2.x - t2.x);
            if (i2)
              return this._active = !0, { bearingDelta: i2 };
          }
          contextmenu(t2) {
            t2.preventDefault();
          }
        }
        class So extends Eo {
          _correctButton(t2, e2) {
            return e2 === 0 && t2.ctrlKey || e2 === 2;
          }
          _move(t2, e2) {
            let i2 = -0.5 * (e2.y - t2.y);
            if (i2)
              return this._active = !0, { pitchDelta: i2 };
          }
          contextmenu(t2) {
            t2.preventDefault();
          }
        }
        class Do {
          constructor(t2, e2) {
            this._minTouches = t2.cooperativeGestures ? 2 : 1, this._clickTolerance = t2.clickTolerance || 1, this._map = e2, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new t.pointGeometry(0, 0), setTimeout(() => {
              this._cancelCooperativeMessage = !1;
            }, 200);
          }
          touchstart(t2, e2, i2) {
            return this._calculateTransform(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            if (this._map._cooperativeGestures && (this._minTouches === 2 && i2.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t2, !1, i2.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = !0)), this._active && !(i2.length < this._minTouches))
              return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            this._calculateTransform(t2, e2, i2), this._active && i2.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e2, i2, o2) {
            o2.length > 0 && (this._active = !0);
            let a2 = vo(o2, i2), r2 = new t.pointGeometry(0, 0), s2 = new t.pointGeometry(0, 0), n2 = 0;
            for (let t2 in a2) {
              let e3 = a2[t2], i3 = this._touches[t2];
              i3 && (r2._add(e3), s2._add(e3.sub(i3)), n2++, a2[t2] = e3);
            }
            if (this._touches = a2, n2 < this._minTouches || !s2.mag())
              return;
            let l2 = s2.div(n2);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: r2.div(n2), panDelta: l2 };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class zo {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          _start(t2) {
          }
          _move(t2, e2, i2) {
            return {};
          }
          touchstart(t2, e2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
          }
          touchmove(t2, e2, i2) {
            if (!this._firstTwoTouches)
              return;
            t2.preventDefault();
            let [o2, a2] = this._firstTwoTouches, r2 = Po(i2, e2, o2), s2 = Po(i2, e2, a2);
            if (!r2 || !s2)
              return;
            let n2 = this._aroundCenter ? null : r2.add(s2).div(2);
            return this._move([r2, s2], n2, t2);
          }
          touchend(t2, e2, i2) {
            if (!this._firstTwoTouches)
              return;
            let [o2, a2] = this._firstTwoTouches, s2 = Po(i2, e2, o2), n2 = Po(i2, e2, a2);
            s2 && n2 || (this._active && r.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t2) {
            this._enabled = !0, this._aroundCenter = !!t2 && t2.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Po(t2, e2, i2) {
          for (let o2 = 0; o2 < t2.length; o2++)
            if (t2[o2].identifier === i2)
              return e2[o2];
        }
        function Mo(t2, e2) {
          return Math.log(t2 / e2) / Math.LN2;
        }
        class Ao extends zo {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t2) {
            this._startDistance = this._distance = t2[0].dist(t2[1]);
          }
          _move(t2, e2) {
            let i2 = this._distance;
            if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(Mo(this._distance, this._startDistance)) < 0.1))
              return this._active = !0, { zoomDelta: Mo(this._distance, i2), pinchAround: e2 };
          }
        }
        function Lo(t2, e2) {
          return 180 * t2.angleWith(e2) / Math.PI;
        }
        class Ro extends zo {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t2) {
            this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
          }
          _move(t2, e2) {
            let i2 = this._vector;
            if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
              return this._active = !0, { bearingDelta: Lo(this._vector, i2), pinchAround: e2 };
          }
          _isBelowThreshold(t2) {
            this._minDiameter = Math.min(this._minDiameter, t2.mag());
            let e2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = Lo(t2, this._startVector);
            return Math.abs(i2) < e2;
          }
        }
        function ko(t2) {
          return Math.abs(t2.y) > Math.abs(t2.x);
        }
        class Bo extends zo {
          constructor(t2) {
            super(), this._map = t2;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t2, e2, i2) {
            super.touchstart(t2, e2, i2), this._currentTouchCount = i2.length;
          }
          _start(t2) {
            this._lastPoints = t2, ko(t2[0].sub(t2[1])) && (this._valid = !1);
          }
          _move(t2, e2, i2) {
            if (this._map._cooperativeGestures && this._currentTouchCount < 3)
              return;
            let o2 = t2[0].sub(this._lastPoints[0]), a2 = t2[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(o2, a2, i2.timeStamp), this._valid ? (this._lastPoints = t2, this._active = !0, { pitchDelta: (o2.y + a2.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t2, e2, i2) {
            if (this._valid !== void 0)
              return this._valid;
            let o2 = t2.mag() >= 2, a2 = e2.mag() >= 2;
            if (!o2 && !a2)
              return;
            if (!o2 || !a2)
              return this._firstMove === void 0 && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            let r2 = t2.y > 0 == e2.y > 0;
            return ko(t2) && ko(e2) && r2;
          }
        }
        let Fo = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Oo {
          constructor() {
            let t2 = Fo;
            this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(t2) {
            if (t2.altKey || t2.ctrlKey || t2.metaKey)
              return;
            let e2 = 0, i2 = 0, o2 = 0, a2 = 0, r2 = 0;
            switch (t2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e2 = -1;
                break;
              case 37:
                t2.shiftKey ? i2 = -1 : (t2.preventDefault(), a2 = -1);
                break;
              case 39:
                t2.shiftKey ? i2 = 1 : (t2.preventDefault(), a2 = 1);
                break;
              case 38:
                t2.shiftKey ? o2 = 1 : (t2.preventDefault(), r2 = -1);
                break;
              case 40:
                t2.shiftKey ? o2 = -1 : (t2.preventDefault(), r2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (s2) => {
              let n2 = s2.getZoom();
              s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Uo, zoom: e2 ? Math.round(n2) + e2 * (t2.shiftKey ? 2 : 1) : n2, bearing: s2.getBearing() + i2 * this._bearingStep, pitch: s2.getPitch() + o2 * this._pitchStep, offset: [-a2 * this._panStep, -r2 * this._panStep], center: s2.getCenter() }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function Uo(t2) {
          return t2 * (2 - t2);
        }
        let No = 4.000244140625;
        class Go {
          constructor(e2, i2) {
            this._map = e2, this._el = e2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, t.bindAll(["_onTimeout"], this);
          }
          setZoomRate(t2) {
            this._defaultZoomRate = t2;
          }
          setWheelZoomRate(t2) {
            this._wheelZoomRate = t2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t2) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = t2 && t2.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          wheel(e2) {
            if (!this.isEnabled())
              return;
            if (this._map._cooperativeGestures) {
              if (!this._map._metaPress)
                return;
              e2.preventDefault();
            }
            let i2 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY, o2 = t.exported.now(), a2 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, i2 !== 0 && i2 % No == 0 ? this._type = "wheel" : i2 !== 0 && Math.abs(i2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(a2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i2, this._active || this._start(e2)), e2.preventDefault();
          }
          _onTimeout(t2) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t2);
          }
          _start(e2) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            let i2 = r.mousePos(this._el, e2);
            this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(i2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive()))
              return;
            let e2 = this._map.transform;
            if (this._delta !== 0) {
              let t2 = this._type === "wheel" && Math.abs(this._delta) > No ? this._wheelZoomRate : this._defaultZoomRate, i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * t2)));
              this._delta < 0 && i3 !== 0 && (i3 = 1 / i3);
              let o3 = typeof this._targetZoom == "number" ? e2.zoomScale(this._targetZoom) : e2.scale;
              this._targetZoom = Math.min(e2.maxZoom, Math.max(e2.minZoom, e2.scaleZoom(o3 * i3))), this._type === "wheel" && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            let i2 = typeof this._targetZoom == "number" ? this._targetZoom : e2.zoom, o2 = this._startZoom, a2 = this._easing, r2, s2 = !1;
            if (this._type === "wheel" && o2 && a2) {
              let e3 = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1), n2 = a2(e3);
              r2 = t.number(o2, i2, n2), e3 < 1 ? this._frameId || (this._frameId = !0) : s2 = !0;
            } else
              r2 = i2, s2 = !0;
            return this._active = !0, s2 && (this._active = !1, this._finishTimeout = setTimeout(() => {
              this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: !0, needsRenderFrame: !s2, zoomDelta: r2 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e2) {
            let i2 = t.ease;
            if (this._prevEase) {
              let e3 = this._prevEase, o2 = (t.exported.now() - e3.start) / e3.duration, a2 = e3.easing(o2 + 0.01) - e3.easing(o2), r2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - r2 * r2);
              i2 = t.bezier(r2, s2, 0.25, 1);
            }
            return this._prevEase = { start: t.exported.now(), duration: e2, easing: i2 }, i2;
          }
          reset() {
            this._active = !1;
          }
        }
        class Zo {
          constructor(t2, e2) {
            this._clickZoom = t2, this._tapZoom = e2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Vo {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(t2, e2) {
            return t2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: i2.getZoom() + (t2.shiftKey ? -1 : 1), around: i2.unproject(e2) }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class qo {
          constructor() {
            this._tap = new bo({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
          }
          touchstart(t2, e2, i2) {
            this._swipePoint || (this._tapTime && t2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = e2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(t2, e2, i2));
          }
          touchmove(t2, e2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch)
                  return;
                let o2 = e2[0], a2 = o2.y - this._swipePoint.y;
                return this._swipePoint = o2, t2.preventDefault(), this._active = !0, { zoomDelta: a2 / 128 };
              }
            } else
              this._tap.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            this._tapTime ? this._swipePoint && i2.length === 0 && this.reset() : this._tap.touchend(t2, e2, i2) && (this._tapTime = t2.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class jo {
          constructor(t2, e2, i2) {
            this._el = t2, this._mousePan = e2, this._touchPan = i2;
          }
          enable(t2) {
            this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class $o {
          constructor(t2, e2, i2) {
            this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class Xo {
          constructor(t2, e2, i2, o2) {
            this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(t2) {
            this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        let Wo = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;
        class Ho extends t.Event {
        }
        function Ko(t2) {
          return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
        }
        class Yo {
          constructor(e2, i2) {
            this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new co(e2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
            let o2 = this._el;
            this._listeners = [[o2, "touchstart", { passive: !0 }], [o2, "touchmove", { passive: !1 }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: !1 }], [o2, "keyup", void 0], [o2, "wheel", { passive: !1 }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
            for (let [t2, e3, i3] of this._listeners)
              r.addEventListener(t2, e3, t2 === document ? this.handleWindowEvent : this.handleEvent, i3);
          }
          destroy() {
            for (let [t2, e2, i2] of this._listeners)
              r.removeEventListener(t2, e2, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
          }
          _addDefaultHandlers(t2) {
            let e2 = this._map, i2 = e2.getCanvasContainer();
            this._add("mapEvent", new fo(e2, t2));
            let o2 = e2.boxZoom = new xo(e2, t2);
            this._add("boxZoom", o2);
            let a2 = new wo(), r2 = new Vo();
            e2.doubleClickZoom = new Zo(r2, a2), this._add("tapZoom", a2), this._add("clickZoom", r2);
            let s2 = new qo();
            this._add("tapDragZoom", s2);
            let n2 = e2.touchPitch = new Bo(e2);
            this._add("touchPitch", n2);
            let l2 = new Co(t2), c2 = new So(t2);
            e2.dragRotate = new $o(t2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
            let h2 = new Io(t2), u2 = new Do(t2, e2);
            e2.dragPan = new jo(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
            let d2 = new Ro(), m2 = new Ao();
            e2.touchZoomRotate = new Xo(i2, m2, d2, s2), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]);
            let _2 = e2.scrollZoom = new Go(e2, this);
            this._add("scrollZoom", _2, ["mousePan"]);
            let p2 = e2.keyboard = new Oo();
            this._add("keyboard", p2), this._add("blockableMapEvent", new go(e2));
            for (let i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
              t2.interactive && t2[i3] && e2[i3].enable(t2[i3]);
          }
          _add(t2, e2, i2) {
            this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
          }
          stop(t2) {
            if (!this._updatingCamera) {
              for (let { handler: t3 } of this._handlers)
                t3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
            }
          }
          isActive() {
            for (let { handler: t2 } of this._handlers)
              if (t2.isActive())
                return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(Wo(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t2, e2, i2) {
            for (let o2 in t2)
              if (o2 !== i2 && (!e2 || e2.indexOf(o2) < 0))
                return !0;
            return !1;
          }
          handleWindowEvent(t2) {
            this.handleEvent(t2, `${t2.type}Window`);
          }
          _getMapTouches(t2) {
            let e2 = [];
            for (let i2 of t2)
              this._el.contains(i2.target) && e2.push(i2);
            return e2;
          }
          handleEvent(t2, e2) {
            if (t2.type === "blur")
              return void this.stop(!0);
            this._updatingCamera = !0;
            let i2 = t2.type === "renderFrame" ? void 0 : t2, o2 = { needsRenderFrame: !1 }, a2 = {}, s2 = {}, n2 = t2.touches, l2 = n2 ? this._getMapTouches(n2) : void 0, c2 = l2 ? r.touchPos(this._el, l2) : r.mousePos(this._el, t2);
            for (let { handlerName: r2, handler: n3, allowed: h3 } of this._handlers) {
              if (!n3.isEnabled())
                continue;
              let u3;
              this._blockedByActive(s2, h3, r2) ? n3.reset() : n3[e2 || t2.type] && (u3 = n3[e2 || t2.type](t2, c2, l2), this.mergeHandlerResult(o2, a2, u3, r2, i2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (s2[r2] = n3);
            }
            let h2 = {};
            for (let t3 in this._previousActiveHandlers)
              s2[t3] || (h2[t3] = i2);
            this._previousActiveHandlers = s2, (Object.keys(h2).length || Ko(o2)) && (this._changes.push([o2, a2, h2]), this._triggerRenderFrame()), (Object.keys(s2).length || Ko(o2)) && this._map._stop(!0), this._updatingCamera = !1;
            let { cameraAnimation: u2 } = o2;
            u2 && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], u2(this._map));
          }
          mergeHandlerResult(e2, i2, o2, a2, r2) {
            if (!o2)
              return;
            t.extend(e2, o2);
            let s2 = { handlerName: a2, originalEvent: o2.originalEvent || r2 };
            o2.zoomDelta !== void 0 && (i2.zoom = s2), o2.panDelta !== void 0 && (i2.drag = s2), o2.pitchDelta !== void 0 && (i2.pitch = s2), o2.bearingDelta !== void 0 && (i2.rotate = s2);
          }
          _applyChanges() {
            let e2 = {}, i2 = {}, o2 = {};
            for (let [a2, r2, s2] of this._changes)
              a2.panDelta && (e2.panDelta = (e2.panDelta || new t.pointGeometry(0, 0))._add(a2.panDelta)), a2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + a2.zoomDelta), a2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + a2.bearingDelta), a2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + a2.pitchDelta), a2.around !== void 0 && (e2.around = a2.around), a2.pinchAround !== void 0 && (e2.pinchAround = a2.pinchAround), a2.noInertia && (e2.noInertia = a2.noInertia), t.extend(i2, r2), t.extend(o2, s2);
            this._updateMapTransform(e2, i2, o2), this._changes = [];
          }
          _updateMapTransform(e2, i2, o2) {
            let a2 = this._map, r2 = a2.transform, s2 = a2.style && a2.style.terrain;
            if (!(Ko(e2) || s2 && this._drag))
              return this._fireEvents(i2, o2, !0);
            let { panDelta: n2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: u2, pinchAround: d2 } = e2;
            d2 !== void 0 && (u2 = d2), a2._stop(!0), u2 = u2 || a2.transform.centerPoint;
            let m2 = r2.pointLocation(n2 ? u2.sub(n2) : u2);
            c2 && (r2.bearing += c2), h2 && (r2.pitch += h2), l2 && (r2.zoom += l2), s2 ? i2.drag && !this._drag ? (this._drag = { center: r2.centerPoint, lngLat: r2.pointLocation(u2), point: u2, handlerName: i2.drag.handlerName }, a2.fire(new t.Event("freezeElevation", { freeze: !0 }))) : this._drag && o2[this._drag.handlerName] ? (a2.fire(new t.Event("freezeElevation", { freeze: !1 })), this._drag = null) : i2.drag && this._drag && (r2.center = r2.pointLocation(r2.centerPoint.sub(n2))) : r2.setLocationAtPoint(m2, u2), this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(i2, o2, !0);
          }
          _fireEvents(e2, i2, o2) {
            let a2 = Wo(this._eventsInProgress), r2 = Wo(e2), s2 = {};
            for (let t2 in e2) {
              let { originalEvent: i3 } = e2[t2];
              this._eventsInProgress[t2] || (s2[`${t2}start`] = i3), this._eventsInProgress[t2] = e2[t2];
            }
            !a2 && r2 && this._fireEvent("movestart", r2.originalEvent);
            for (let t2 in s2)
              this._fireEvent(t2, s2[t2]);
            r2 && this._fireEvent("move", r2.originalEvent);
            for (let t2 in e2) {
              let { originalEvent: i3 } = e2[t2];
              this._fireEvent(t2, i3);
            }
            let n2 = {}, l2;
            for (let t2 in this._eventsInProgress) {
              let { handlerName: e3, originalEvent: o3 } = this._eventsInProgress[t2];
              this._handlersById[e3].isActive() || (delete this._eventsInProgress[t2], l2 = i2[e3] || o3, n2[`${t2}end`] = l2);
            }
            for (let t2 in n2)
              this._fireEvent(t2, n2[t2]);
            let c2 = Wo(this._eventsInProgress);
            if (o2 && (a2 || r2) && !c2) {
              this._updatingCamera = !0;
              let e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t2) => t2 !== 0 && -this._bearingSnap < t2 && t2 < this._bearingSnap;
              e3 ? (i3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), this._map.easeTo(e3, { originalEvent: l2 })) : (this._map.fire(new t.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
            }
          }
          _fireEvent(e2, i2) {
            this._map.fire(new t.Event(e2, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
              delete this._frameId, this.handleEvent(new Ho("renderFrame", { timeStamp: t2 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        let Jo = { extend: (e2, ...i2) => t.extend(e2, ...i2), run(t2) {
          t2();
        }, logToElement(t2, e2 = !1, i2 = "log") {
          let o2 = window.document.getElementById(i2);
          o2 && (e2 && (o2.innerHTML = ""), o2.innerHTML += `<br>${t2}`);
        } };
        class Qo extends t.Evented {
          constructor(e2, i2) {
            super(), this._moving = !1, this._zooming = !1, this.transform = e2, this._bearingSnap = i2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t2, e2) {
            return this.jumpTo({ center: t2 }, e2);
          }
          panBy(e2, i2, o2) {
            return e2 = t.pointGeometry.convert(e2).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e2 }, i2), o2);
          }
          panTo(e2, i2, o2) {
            return this.easeTo(t.extend({ center: e2 }, i2), o2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t2, e2) {
            return this.jumpTo({ zoom: t2 }, e2), this;
          }
          zoomTo(e2, i2, o2) {
            return this.easeTo(t.extend({ zoom: e2 }, i2), o2);
          }
          zoomIn(t2, e2) {
            return this.zoomTo(this.getZoom() + 1, t2, e2), this;
          }
          zoomOut(t2, e2) {
            return this.zoomTo(this.getZoom() - 1, t2, e2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t2, e2) {
            return this.jumpTo({ bearing: t2 }, e2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t2, e2) {
            return this.jumpTo({ padding: t2 }, e2), this;
          }
          rotateTo(e2, i2, o2) {
            return this.easeTo(t.extend({ bearing: e2 }, i2), o2);
          }
          resetNorth(e2, i2) {
            return this.rotateTo(0, t.extend({ duration: 1e3 }, e2), i2), this;
          }
          resetNorthPitch(e2, i2) {
            return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e2), i2), this;
          }
          snapToNorth(t2, e2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t2, e2) {
            return this.jumpTo({ pitch: t2 }, e2), this;
          }
          cameraForBounds(e2, i2) {
            e2 = t.LngLatBounds.convert(e2);
            let o2 = i2 && i2.bearing || 0;
            return this._cameraForBoxAndBearing(e2.getNorthWest(), e2.getSouthEast(), o2, i2);
          }
          _cameraForBoxAndBearing(e2, i2, o2, a2) {
            let r2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (a2 = t.extend({ padding: r2, offset: [0, 0], maxZoom: this.transform.maxZoom }, a2)).padding == "number") {
              let t2 = a2.padding;
              a2.padding = { top: t2, bottom: t2, right: t2, left: t2 };
            }
            a2.padding = t.extend(r2, a2.padding);
            let s2 = this.transform, n2 = s2.padding, l2 = s2.project(t.LngLat.convert(e2)), c2 = s2.project(t.LngLat.convert(i2)), h2 = l2.rotate(-o2 * Math.PI / 180), u2 = c2.rotate(-o2 * Math.PI / 180), d2 = new t.pointGeometry(Math.max(h2.x, u2.x), Math.max(h2.y, u2.y)), m2 = new t.pointGeometry(Math.min(h2.x, u2.x), Math.min(h2.y, u2.y)), _2 = d2.sub(m2), p2 = (s2.width - (n2.left + n2.right + a2.padding.left + a2.padding.right)) / _2.x, f2 = (s2.height - (n2.top + n2.bottom + a2.padding.top + a2.padding.bottom)) / _2.y;
            if (f2 < 0 || p2 < 0)
              return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            let g2 = Math.min(s2.scaleZoom(s2.scale * Math.min(p2, f2)), a2.maxZoom), x2 = t.pointGeometry.convert(a2.offset), v2 = new t.pointGeometry((a2.padding.left - a2.padding.right) / 2, (a2.padding.top - a2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), y2 = x2.add(v2).mult(s2.scale / s2.zoomScale(g2));
            return { center: s2.unproject(l2.add(c2).div(2).sub(y2)), zoom: g2, bearing: o2 };
          }
          fitBounds(t2, e2, i2) {
            return this._fitInternal(this.cameraForBounds(t2, e2), e2, i2);
          }
          fitScreenCoordinates(e2, i2, o2, a2, r2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.pointGeometry.convert(e2)), this.transform.pointLocation(t.pointGeometry.convert(i2)), o2, a2), a2, r2);
          }
          _fitInternal(e2, i2, o2) {
            return e2 ? (delete (i2 = t.extend(e2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
          }
          jumpTo(e2, i2) {
            this.stop();
            let o2 = this.transform, a2 = !1, r2 = !1, s2 = !1;
            return "zoom" in e2 && o2.zoom !== +e2.zoom && (a2 = !0, o2.zoom = +e2.zoom), e2.center !== void 0 && (o2.center = t.LngLat.convert(e2.center)), "bearing" in e2 && o2.bearing !== +e2.bearing && (r2 = !0, o2.bearing = +e2.bearing), "pitch" in e2 && o2.pitch !== +e2.pitch && (s2 = !0, o2.pitch = +e2.pitch), e2.padding == null || o2.isPaddingEqual(e2.padding) || (o2.padding = e2.padding), this.fire(new t.Event("movestart", i2)).fire(new t.Event("move", i2)), a2 && this.fire(new t.Event("zoomstart", i2)).fire(new t.Event("zoom", i2)).fire(new t.Event("zoomend", i2)), r2 && this.fire(new t.Event("rotatestart", i2)).fire(new t.Event("rotate", i2)).fire(new t.Event("rotateend", i2)), s2 && this.fire(new t.Event("pitchstart", i2)).fire(new t.Event("pitch", i2)).fire(new t.Event("pitchend", i2)), this.fire(new t.Event("moveend", i2));
          }
          calculateCameraOptionsFromTo(e2, i2, o2, a2 = 0) {
            let r2 = t.MercatorCoordinate.fromLngLat(e2, i2), s2 = t.MercatorCoordinate.fromLngLat(o2, a2), n2 = s2.x - r2.x, l2 = s2.y - r2.y, c2 = s2.z - r2.z, h2 = Math.hypot(n2, l2, c2);
            if (h2 === 0)
              throw new Error("Can't calculate camera options with same From and To");
            let u2 = Math.hypot(n2, l2), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / h2 / this.transform.tileSize), m2 = 180 * Math.atan2(n2, -l2) / Math.PI, _2 = 180 * Math.acos(u2 / h2) / Math.PI;
            return _2 = c2 < 0 ? 90 - _2 : 90 + _2, { center: s2.toLngLat(), zoom: d2, pitch: _2, bearing: m2 };
          }
          easeTo(e2, i2) {
            this._stop(!1, e2.easeId), ((e2 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e2)).animate === !1 || !e2.essential && t.exported.prefersReducedMotion) && (e2.duration = 0);
            let o2 = this.transform, a2 = this.getZoom(), r2 = this.getBearing(), s2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e2 ? +e2.zoom : a2, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, r2) : r2, h2 = "pitch" in e2 ? +e2.pitch : s2, u2 = "padding" in e2 ? e2.padding : o2.padding, d2 = t.pointGeometry.convert(e2.offset), m2 = o2.centerPoint.add(d2), _2 = o2.pointLocation(m2), p2 = t.LngLat.convert(e2.center || _2);
            this._normalizeCenter(p2);
            let f2 = o2.project(_2), g2 = o2.project(p2).sub(f2), x2 = o2.zoomScale(l2 - a2), v2, y2;
            e2.around && (v2 = t.LngLat.convert(e2.around), y2 = o2.locationPoint(v2));
            let b2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || l2 !== a2, this._rotating = this._rotating || r2 !== c2, this._pitching = this._pitching || h2 !== s2, this._padding = !o2.isPaddingEqual(u2), this._easeId = e2.easeId, this._prepareEase(i2, e2.noMoveStart, b2), this._ease((e3) => {
              if (this._zooming && (o2.zoom = t.number(a2, l2, e3)), this._rotating && (o2.bearing = t.number(r2, c2, e3)), this._pitching && (o2.pitch = t.number(s2, h2, e3)), this._padding && (o2.interpolatePadding(n2, u2, e3), m2 = o2.centerPoint.add(d2)), v2)
                o2.setLocationAtPoint(v2, y2);
              else {
                let t2 = o2.zoomScale(o2.zoom - a2), i3 = l2 > a2 ? Math.min(2, x2) : Math.max(0.5, x2), r3 = Math.pow(i3, 1 - e3), s3 = o2.unproject(f2.add(g2.mult(e3 * r3)).mult(t2));
                o2.setLocationAtPoint(o2.renderWorldCopies ? s3.wrap() : s3, m2);
              }
              this._fireMoveEvents(i2);
            }, (t2) => {
              this._afterEase(i2, t2);
            }, e2), this;
          }
          _prepareEase(e2, i2, o2 = {}) {
            this._moving = !0, this.fire(new t.Event("freezeElevation", { freeze: !0 })), i2 || o2.moving || this.fire(new t.Event("movestart", e2)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e2)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e2)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e2));
          }
          _fireMoveEvents(e2) {
            this.fire(new t.Event("move", e2)), this._zooming && this.fire(new t.Event("zoom", e2)), this._rotating && this.fire(new t.Event("rotate", e2)), this._pitching && this.fire(new t.Event("pitch", e2));
          }
          _afterEase(e2, i2) {
            if (this._easeId && i2 && this._easeId === i2)
              return;
            delete this._easeId, this.fire(new t.Event("freezeElevation", { freeze: !1 }));
            let o2 = this._zooming, a2 = this._rotating, r2 = this._pitching;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o2 && this.fire(new t.Event("zoomend", e2)), a2 && this.fire(new t.Event("rotateend", e2)), r2 && this.fire(new t.Event("pitchend", e2)), this.fire(new t.Event("moveend", e2));
          }
          flyTo(e2, i2) {
            if (!e2.essential && t.exported.prefersReducedMotion) {
              let o3 = t.pick(e2, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o3, i2);
            }
            this.stop(), e2 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e2);
            let o2 = this.transform, a2 = this.getZoom(), r2 = this.getBearing(), s2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e2 ? t.clamp(+e2.zoom, o2.minZoom, o2.maxZoom) : a2, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, r2) : r2, h2 = "pitch" in e2 ? +e2.pitch : s2, u2 = "padding" in e2 ? e2.padding : o2.padding, d2 = o2.zoomScale(l2 - a2), m2 = t.pointGeometry.convert(e2.offset), _2 = o2.centerPoint.add(m2), p2 = o2.pointLocation(_2), f2 = t.LngLat.convert(e2.center || p2);
            this._normalizeCenter(f2);
            let g2 = o2.project(p2), x2 = o2.project(f2).sub(g2), v2 = e2.curve, y2 = Math.max(o2.width, o2.height), b2 = y2 / d2, w2 = x2.mag();
            if ("minZoom" in e2) {
              let i3 = t.clamp(Math.min(e2.minZoom, a2, l2), o2.minZoom, o2.maxZoom), r3 = y2 / o2.zoomScale(i3 - a2);
              v2 = Math.sqrt(r3 / w2 * 2);
            }
            let T2 = v2 * v2;
            function E2(t2) {
              let e3 = (b2 * b2 - y2 * y2 + (t2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (t2 ? b2 : y2) * T2 * w2);
              return Math.log(Math.sqrt(e3 * e3 + 1) - e3);
            }
            function I2(t2) {
              return (Math.exp(t2) - Math.exp(-t2)) / 2;
            }
            function C2(t2) {
              return (Math.exp(t2) + Math.exp(-t2)) / 2;
            }
            let S2 = E2(0), D2 = function(t2) {
              return C2(S2) / C2(S2 + v2 * t2);
            }, z2 = function(t2) {
              return y2 * ((C2(S2) * (I2(e3 = S2 + v2 * t2) / C2(e3)) - I2(S2)) / T2) / w2;
              var e3;
            }, P2 = (E2(1) - S2) / v2;
            if (Math.abs(w2) < 1e-6 || !isFinite(P2)) {
              if (Math.abs(y2 - b2) < 1e-6)
                return this.easeTo(e2, i2);
              let t2 = b2 < y2 ? -1 : 1;
              P2 = Math.abs(Math.log(b2 / y2)) / v2, z2 = function() {
                return 0;
              }, D2 = function(e3) {
                return Math.exp(t2 * v2 * e3);
              };
            }
            return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * P2 / ("screenSpeed" in e2 ? +e2.screenSpeed / v2 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = !0, this._rotating = r2 !== c2, this._pitching = h2 !== s2, this._padding = !o2.isPaddingEqual(u2), this._prepareEase(i2, !1), this._ease((e3) => {
              let d3 = e3 * P2, p3 = 1 / D2(d3);
              o2.zoom = e3 === 1 ? l2 : a2 + o2.scaleZoom(p3), this._rotating && (o2.bearing = t.number(r2, c2, e3)), this._pitching && (o2.pitch = t.number(s2, h2, e3)), this._padding && (o2.interpolatePadding(n2, u2, e3), _2 = o2.centerPoint.add(m2));
              let v3 = e3 === 1 ? f2 : o2.unproject(g2.add(x2.mult(z2(d3))).mult(p3));
              o2.setLocationAtPoint(o2.renderWorldCopies ? v3.wrap() : v3, _2), this._fireMoveEvents(i2);
            }, () => this._afterEase(i2), e2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t2, e2) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              let t3 = this._onEaseEnd;
              delete this._onEaseEnd, t3.call(this, e2);
            }
            if (!t2) {
              let t3 = this.handlers;
              t3 && t3.stop(!1);
            }
            return this;
          }
          _ease(e2, i2, o2) {
            o2.animate === !1 || o2.duration === 0 ? (e2(1), i2()) : (this._easeStart = t.exported.now(), this._easeOptions = o2, this._onEaseFrame = e2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            let e2 = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(e2)), e2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(e2, i2) {
            e2 = t.wrap(e2, -180, 180);
            let o2 = Math.abs(e2 - i2);
            return Math.abs(e2 - 360 - i2) < o2 && (e2 -= 360), Math.abs(e2 + 360 - i2) < o2 && (e2 += 360), e2;
          }
          _normalizeCenter(t2) {
            let e2 = this.transform;
            if (!e2.renderWorldCopies || e2.lngRange)
              return;
            let i2 = t2.lng - e2.center.lng;
            t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
        }
        class ta {
          constructor(e2 = {}) {
            this.options = e2, t.bindAll(["_toggleAttribution", "_updateData", "_updateCompact", "_updateCompactMinimize"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t2) {
            return this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = r.create("summary", "maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r.create("div", "maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t2, e2) {
            let i2 = this._map._getUIString(`AttributionControl.${e2}`);
            t2.title = i2, t2.setAttribute("aria-label", i2);
          }
          _toggleAttribution() {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.classList.add("maplibregl-compact-show", "mapboxgl-compact-show"), this._container.removeAttribute("open")));
          }
          _updateData(t2) {
            !t2 || t2.sourceDataType !== "metadata" && t2.sourceDataType !== "visibility" && t2.dataType !== "style" && t2.type !== "terrain" || this._updateAttributions();
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let t2 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => typeof t3 != "string" ? "" : t3)) : typeof this.options.customAttribution == "string" && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
              let t3 = this._map.style.stylesheet;
              this.styleOwner = t3.owner, this.styleId = t3.id;
            }
            let e2 = this._map.style.sourceCaches;
            for (let i3 in e2) {
              let o2 = e2[i3];
              if (o2.used || o2.usedForTerrain) {
                let e3 = o2.getSource();
                e3.attribution && t2.indexOf(e3.attribution) < 0 && t2.push(e3.attribution);
              }
            }
            t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e3) => t3.length - e3.length), t2 = t2.filter((e3, i3) => {
              for (let o2 = i3 + 1; o2 < t2.length; o2++)
                if (t2[o2].indexOf(e3) >= 0)
                  return !1;
              return !0;
            });
            let i2 = t2.join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty", "mapboxgl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty", "mapboxgl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "mapboxgl-compact", "maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show", "mapboxgl-compact", "mapboxgl-compact-show"));
          }
          _updateCompactMinimize() {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show");
          }
        }
        class ea {
          constructor(e2 = {}) {
            this.options = e2, t.bindAll(["_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t2) {
            this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("div", "maplibregl-ctrl mapboxgl-ctrl");
            let e2 = r.create("a", "maplibregl-ctrl-logo mapboxgl-ctrl-logo");
            return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
          _updateCompact() {
            let t2 = this._container.children;
            if (t2.length) {
              let e2 = t2[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && e2.classList.add("maplibregl-compact", "mapboxgl-compact") : e2.classList.remove("maplibregl-compact", "mapboxgl-compact");
            }
          }
        }
        class ia {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(t2) {
            let e2 = ++this._id;
            return this._queue.push({ callback: t2, id: e2, cancelled: !1 }), e2;
          }
          remove(t2) {
            let e2 = this._currentlyRunning, i2 = e2 ? this._queue.concat(e2) : this._queue;
            for (let e3 of i2)
              if (e3.id === t2)
                return void (e3.cancelled = !0);
          }
          run(t2 = 0) {
            if (this._currentlyRunning)
              throw new Error("Attempting to run(), but is already running.");
            let e2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (let i2 of e2)
              if (!i2.cancelled && (i2.callback(t2), this._cleared))
                break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        let oa = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" }, aa = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, fadeDuration: 300, crossSourceCollisions: !0 }, ra = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
        class sa {
          constructor(e2, i2, o2 = !1) {
            this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Co({ clickTolerance: e2.dragRotate._mouseRotate._clickTolerance }), this.map = e2, o2 && (this.mousePitch = new So({ clickTolerance: e2.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), r.addEventListener(i2, "mousedown", this.mousedown), r.addEventListener(i2, "touchstart", this.touchstart, { passive: !1 }), r.addEventListener(i2, "touchmove", this.touchmove), r.addEventListener(i2, "touchend", this.touchend), r.addEventListener(i2, "touchcancel", this.reset);
          }
          down(t2, e2) {
            this.mouseRotate.mousedown(t2, e2), this.mousePitch && this.mousePitch.mousedown(t2, e2), r.disableDrag();
          }
          move(t2, e2) {
            let i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(t2, e2);
            if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
              let o3 = this.mousePitch.mousemoveWindow(t2, e2);
              o3 && o3.pitchDelta && i2.setPitch(i2.getPitch() + o3.pitchDelta);
            }
          }
          off() {
            let t2 = this.element;
            r.removeEventListener(t2, "mousedown", this.mousedown), r.removeEventListener(t2, "touchstart", this.touchstart, { passive: !1 }), r.removeEventListener(t2, "touchmove", this.touchmove), r.removeEventListener(t2, "touchend", this.touchend), r.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            r.enableDrag(), r.removeEventListener(window, "mousemove", this.mousemove), r.removeEventListener(window, "mouseup", this.mouseup);
          }
          mousedown(e2) {
            this.down(t.extend({}, e2, { ctrlKey: !0, preventDefault: () => e2.preventDefault() }), r.mousePos(this.element, e2)), r.addEventListener(window, "mousemove", this.mousemove), r.addEventListener(window, "mouseup", this.mouseup);
          }
          mousemove(t2) {
            this.move(t2, r.mousePos(this.element, t2));
          }
          mouseup(t2) {
            this.mouseRotate.mouseupWindow(t2), this.mousePitch && this.mousePitch.mouseupWindow(t2), this.offTemp();
          }
          touchstart(t2) {
            t2.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = r.touchPos(this.element, t2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => t2.preventDefault() }, this._startPos));
          }
          touchmove(t2) {
            t2.targetTouches.length !== 1 ? this.reset() : (this._lastPos = r.touchPos(this.element, t2.targetTouches)[0], this.move({ preventDefault: () => t2.preventDefault() }, this._lastPos));
          }
          touchend(t2) {
            t2.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        function na(e2, i2, o2) {
          if (e2 = new t.LngLat(e2.lng, e2.lat), i2) {
            let a2 = new t.LngLat(e2.lng - 360, e2.lat), r2 = new t.LngLat(e2.lng + 360, e2.lat), s2 = o2.locationPoint(e2).distSqr(i2);
            o2.locationPoint(a2).distSqr(i2) < s2 ? e2 = a2 : o2.locationPoint(r2).distSqr(i2) < s2 && (e2 = r2);
          }
          for (; Math.abs(e2.lng - o2.center.lng) > 180; ) {
            let t2 = o2.locationPoint(e2);
            if (t2.x >= 0 && t2.y >= 0 && t2.x <= o2.width && t2.y <= o2.height)
              break;
            e2.lng > o2.center.lng ? e2.lng -= 360 : e2.lng += 360;
          }
          return e2;
        }
        let la = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function ca(t2, e2, i2) {
          let o2 = t2.classList;
          for (let t3 in la)
            o2.remove(`maplibregl-${i2}-anchor-${t3}`, `mapboxgl-${i2}-anchor-${t3}`);
          o2.add(`maplibregl-${i2}-anchor-${e2}`, `mapboxgl-${i2}-anchor-${e2}`);
        }
        class ha extends t.Evented {
          constructor(e2, i2) {
            if (super(), (e2 instanceof HTMLElement || i2) && (e2 = t.extend({ element: e2 }, i2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || !1, this._clickTolerance = e2 && e2.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && e2.pitchAlignment !== "auto" ? e2.pitchAlignment : this._rotationAlignment, e2 && e2.element)
              this._element = e2.element, this._offset = t.pointGeometry.convert(e2 && e2.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = r.create("div"), this._element.setAttribute("aria-label", "Map marker");
              let i3 = r.createNS("http://www.w3.org/2000/svg", "svg"), o2 = 41, a2 = 27;
              i3.setAttributeNS(null, "display", "block"), i3.setAttributeNS(null, "height", `${o2}px`), i3.setAttributeNS(null, "width", `${a2}px`), i3.setAttributeNS(null, "viewBox", `0 0 ${a2} ${o2}`);
              let s2 = r.createNS("http://www.w3.org/2000/svg", "g");
              s2.setAttributeNS(null, "stroke", "none"), s2.setAttributeNS(null, "stroke-width", "1"), s2.setAttributeNS(null, "fill", "none"), s2.setAttributeNS(null, "fill-rule", "evenodd");
              let n2 = r.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "fill-rule", "nonzero");
              let l2 = r.createNS("http://www.w3.org/2000/svg", "g");
              l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
              let c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (let t2 of c2) {
                let e3 = r.createNS("http://www.w3.org/2000/svg", "ellipse");
                e3.setAttributeNS(null, "opacity", "0.04"), e3.setAttributeNS(null, "cx", "10.5"), e3.setAttributeNS(null, "cy", "5.80029008"), e3.setAttributeNS(null, "rx", t2.rx), e3.setAttributeNS(null, "ry", t2.ry), l2.appendChild(e3);
              }
              let h2 = r.createNS("http://www.w3.org/2000/svg", "g");
              h2.setAttributeNS(null, "fill", this._color);
              let u2 = r.createNS("http://www.w3.org/2000/svg", "path");
              u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(u2);
              let d2 = r.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
              let m2 = r.createNS("http://www.w3.org/2000/svg", "path");
              m2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(m2);
              let _2 = r.createNS("http://www.w3.org/2000/svg", "g");
              _2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), _2.setAttributeNS(null, "fill", "#FFFFFF");
              let p2 = r.createNS("http://www.w3.org/2000/svg", "g");
              p2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              let f2 = r.createNS("http://www.w3.org/2000/svg", "circle");
              f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
              let g2 = r.createNS("http://www.w3.org/2000/svg", "circle");
              g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), p2.appendChild(f2), p2.appendChild(g2), n2.appendChild(l2), n2.appendChild(h2), n2.appendChild(d2), n2.appendChild(_2), n2.appendChild(p2), i3.appendChild(n2), i3.setAttributeNS(null, "height", o2 * this._scale + "px"), i3.setAttributeNS(null, "width", a2 * this._scale + "px"), this._element.appendChild(i3), this._offset = t.pointGeometry.convert(e2 && e2.offset || [0, -14]);
            }
            this._element.classList.add("maplibregl-marker", "mapboxgl-marker"), this._element.addEventListener("dragstart", (t2) => {
              t2.preventDefault();
            }), this._element.addEventListener("mousedown", (t2) => {
              t2.preventDefault();
            }), ca(this._element, this._anchor, "marker"), this._popup = null;
          }
          addTo(t2) {
            return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t.LngLat.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
              if (!("offset" in t2.options)) {
                let o2 = Math.sqrt(Math.pow(13.5, 2) / 2);
                t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [o2, -1 * (38.1 - 13.5 + o2)], "bottom-right": [-o2, -1 * (38.1 - 13.5 + o2)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          _onKeyPress(t2) {
            let e2 = t2.code, i2 = t2.charCode || t2.keyCode;
            e2 !== "Space" && e2 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
          }
          _onMapClick(t2) {
            let e2 = t2.originalEvent.target, i2 = this._element;
            this._popup && (e2 === i2 || i2.contains(e2)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            let t2 = this._popup;
            return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
          }
          _update(t2) {
            if (!this._map)
              return;
            this._map.transform.renderWorldCopies && (this._lngLat = na(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
            let e2 = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? e2 = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (e2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let i2 = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? i2 = "rotateX(0deg)" : this._pitchAlignment === "map" && (i2 = `rotateX(${this._map.getPitch()}deg)`), t2 && t2.type !== "moveend" || (this._pos = this._pos.round()), r.setTransform(this._element, `${la[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i2} ${e2}`), this._map.style && this._map.style.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
              let t3 = this._map.unproject(this._pos), e3 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
              this._element.style.opacity = t3.distanceTo(this._lngLat) > 20 * e3 ? "0.2" : "1.0", this._opacityTimeout = null;
            }, 100));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e2) {
            return this._offset = t.pointGeometry.convert(e2), this._update(), this;
          }
          _onMove(e2) {
            if (!this._isDragging) {
              let t2 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = e2.point.dist(this._pointerdownPos) >= t2;
            }
            this._isDragging && (this._pos = e2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new t.Event("dragend")), this._state = "inactive";
          }
          _addDragHandler(t2) {
            this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._offset), this._pointerdownPos = t2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }
          setDraggable(t2) {
            return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t2) {
            return this._rotation = t2 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t2) {
            return this._rotationAlignment = t2 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t2) {
            return this._pitchAlignment = t2 && t2 !== "auto" ? t2 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
        }
        let ua = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, da, ma = 0, _a = !1, pa = { maxWidth: 100, unit: "metric" };
        function fa(t2, e2, i2) {
          let o2 = i2 && i2.maxWidth || 100, a2 = t2._container.clientHeight / 2, r2 = t2.unproject([0, a2]), s2 = t2.unproject([o2, a2]), n2 = r2.distanceTo(s2);
          if (i2 && i2.unit === "imperial") {
            let i3 = 3.2808 * n2;
            i3 > 5280 ? ga(e2, o2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : ga(e2, o2, i3, t2._getUIString("ScaleControl.Feet"));
          } else
            i2 && i2.unit === "nautical" ? ga(e2, o2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1e3 ? ga(e2, o2, n2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : ga(e2, o2, n2, t2._getUIString("ScaleControl.Meters"));
        }
        function ga(t2, e2, i2, o2) {
          let a2 = function(t3) {
            let e3 = Math.pow(10, `${Math.floor(t3)}`.length - 1), i3 = t3 / e3;
            return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
              let e4 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
              return Math.round(t4 * e4) / e4;
            }(i3), e3 * i3;
          }(i2);
          t2.style.width = e2 * (a2 / i2) + "px", t2.innerHTML = `${a2}&nbsp;${o2}`;
        }
        let xa = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, va = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function ya(e2) {
          if (e2) {
            if (typeof e2 == "number") {
              let i2 = Math.round(Math.sqrt(0.5 * Math.pow(e2, 2)));
              return { center: new t.pointGeometry(0, 0), top: new t.pointGeometry(0, e2), "top-left": new t.pointGeometry(i2, i2), "top-right": new t.pointGeometry(-i2, i2), bottom: new t.pointGeometry(0, -e2), "bottom-left": new t.pointGeometry(i2, -i2), "bottom-right": new t.pointGeometry(-i2, -i2), left: new t.pointGeometry(e2, 0), right: new t.pointGeometry(-e2, 0) };
            }
            if (e2 instanceof t.pointGeometry || Array.isArray(e2)) {
              let i2 = t.pointGeometry.convert(e2);
              return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
            }
            return { center: t.pointGeometry.convert(e2.center || [0, 0]), top: t.pointGeometry.convert(e2.top || [0, 0]), "top-left": t.pointGeometry.convert(e2["top-left"] || [0, 0]), "top-right": t.pointGeometry.convert(e2["top-right"] || [0, 0]), bottom: t.pointGeometry.convert(e2.bottom || [0, 0]), "bottom-left": t.pointGeometry.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.pointGeometry.convert(e2["bottom-right"] || [0, 0]), left: t.pointGeometry.convert(e2.left || [0, 0]), right: t.pointGeometry.convert(e2.right || [0, 0]) };
          }
          return ya(new t.pointGeometry(0, 0));
        }
        let ba = { supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: class extends Qo {
          constructor(e2) {
            var i2;
            if (t.PerformanceUtils.mark(t.PerformanceMarkers.create), (e2 = t.extend({}, aa, e2)).minZoom != null && e2.maxZoom != null && e2.minZoom > e2.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (e2.minPitch != null && e2.maxPitch != null && e2.minPitch > e2.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (e2.minPitch != null && e2.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (e2.maxPitch != null && e2.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (super(new io(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies), { bearingSnap: e2.bearingSnap }), this._interactive = e2.interactive, this._cooperativeGestures = e2.cooperativeGestures, this._maxTileCacheSize = e2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new ia(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, oa, e2.locale), this._clickTolerance = e2.clickTolerance, this._pixelRatio = (i2 = e2.pixelRatio) !== null && i2 !== void 0 ? i2 : devicePixelRatio, this._requestManager = new s(e2.transformRequest), typeof e2.container == "string") {
              if (this._container = document.getElementById(e2.container), !this._container)
                throw new Error(`Container '${e2.container}' not found.`);
            } else {
              if (!(e2.container instanceof HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = e2.container;
            }
            if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
              throw new Error("Failed to initialize WebGL.");
            this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            }), typeof window < "u" && (addEventListener("online", this._onWindowOnline, !1), addEventListener("resize", this._onWindowResize, !1), addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new Yo(this, e2), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e2.hash && new oo(typeof e2.hash == "string" && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.extend({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new ta({ customAttribution: e2.customAttribution })), e2.maplibreLogo && this.addControl(new ea(), e2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (e3) => {
              this._update(e3.dataType === "style"), this.fire(new t.Event(`${e3.dataType}data`, e3));
            }), this.on("dataloading", (e3) => {
              this.fire(new t.Event(`${e3.dataType}dataloading`, e3));
            }), this.on("dataabort", (e3) => {
              this.fire(new t.Event("sourcedataabort", e3));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(e2, i2) {
            if (i2 === void 0 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            let o2 = e2.onAdd(this);
            this._controls.push(e2);
            let a2 = this._controlPositions[i2];
            return i2.indexOf("bottom") !== -1 ? a2.insertBefore(o2, a2.firstChild) : a2.appendChild(o2), this;
          }
          removeControl(e2) {
            if (!e2 || !e2.onRemove)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            let i2 = this._controls.indexOf(e2);
            return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
          }
          hasControl(t2) {
            return this._controls.indexOf(t2) > -1;
          }
          calculateCameraOptionsFromTo(t2, e2, i2, o2) {
            return o2 == null && this.style.terrain && (o2 = this.transform.getElevation(i2, this.style.terrain)), super.calculateCameraOptionsFromTo(t2, e2, i2, o2);
          }
          resize(e2) {
            let i2 = this._containerDimensions(), o2 = i2[0], a2 = i2[1];
            this._resizeCanvas(o2, a2, this.getPixelRatio()), this.transform.resize(o2, a2), this.painter.resize(o2, a2, this.getPixelRatio());
            let r2 = !this._moving;
            return r2 && (this.stop(), this.fire(new t.Event("movestart", e2)).fire(new t.Event("move", e2))), this.fire(new t.Event("resize", e2)), r2 && this.fire(new t.Event("moveend", e2)), this;
          }
          getPixelRatio() {
            return this._pixelRatio;
          }
          setPixelRatio(t2) {
            let [e2, i2] = this._containerDimensions();
            this._pixelRatio = t2, this._resizeCanvas(e2, i2, t2), this.painter.resize(e2, i2, t2);
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(e2) {
            return this.transform.setMaxBounds(t.LngLatBounds.convert(e2)), this._update();
          }
          setMinZoom(t2) {
            if ((t2 = t2 ?? -2) >= -2 && t2 <= this.transform.maxZoom)
              return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t2) {
            if ((t2 = t2 ?? 22) >= this.transform.minZoom)
              return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t2) {
            if ((t2 = t2 ?? 0) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch)
              return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t2) {
            if ((t2 = t2 ?? 60) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t2 >= this.transform.minPitch)
              return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t2) {
            return this.transform.renderWorldCopies = t2, this._update();
          }
          project(e2) {
            return this.transform.locationPoint(t.LngLat.convert(e2), this.style && this.style.terrain);
          }
          unproject(e2) {
            return this.transform.pointLocation(t.pointGeometry.convert(e2), this.style && this.style.terrain);
          }
          isMoving() {
            return this._moving || this.handlers.isMoving();
          }
          isZooming() {
            return this._zooming || this.handlers.isZooming();
          }
          isRotating() {
            return this._rotating || this.handlers.isRotating();
          }
          _createDelegatedListener(t2, e2, i2) {
            if (t2 === "mouseenter" || t2 === "mouseover") {
              let o2 = !1;
              return { layer: e2, listener: i2, delegates: { mousemove: (a3) => {
                let r2 = this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : [];
                r2.length ? o2 || (o2 = !0, i2.call(this, new mo(t2, this, a3.originalEvent, { features: r2 }))) : o2 = !1;
              }, mouseout: () => {
                o2 = !1;
              } } };
            }
            if (t2 === "mouseleave" || t2 === "mouseout") {
              let o2 = !1;
              return { layer: e2, listener: i2, delegates: { mousemove: (a3) => {
                (this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : []).length ? o2 = !0 : o2 && (o2 = !1, i2.call(this, new mo(t2, this, a3.originalEvent)));
              }, mouseout: (e3) => {
                o2 && (o2 = !1, i2.call(this, new mo(t2, this, e3.originalEvent)));
              } } };
            }
            {
              let o2 = (t3) => {
                let o3 = this.getLayer(e2) ? this.queryRenderedFeatures(t3.point, { layers: [e2] }) : [];
                o3.length && (t3.features = o3, i2.call(this, t3), delete t3.features);
              };
              return { layer: e2, listener: i2, delegates: { [t2]: o2 } };
            }
          }
          on(t2, e2, i2) {
            if (i2 === void 0)
              return super.on(t2, e2);
            let o2 = this._createDelegatedListener(t2, e2, i2);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(o2);
            for (let t3 in o2.delegates)
              this.on(t3, o2.delegates[t3]);
            return this;
          }
          once(t2, e2, i2) {
            if (i2 === void 0)
              return super.once(t2, e2);
            let o2 = this._createDelegatedListener(t2, e2, i2);
            for (let t3 in o2.delegates)
              this.once(t3, o2.delegates[t3]);
            return this;
          }
          off(t2, e2, i2) {
            return i2 === void 0 ? super.off(t2, e2) : (this._delegatedListeners && this._delegatedListeners[t2] && ((o2) => {
              let a2 = this._delegatedListeners[t2];
              for (let t3 = 0; t3 < a2.length; t3++) {
                let o3 = a2[t3];
                if (o3.layer === e2 && o3.listener === i2) {
                  for (let t4 in o3.delegates)
                    this.off(t4, o3.delegates[t4]);
                  return a2.splice(t3, 1), this;
                }
              }
            })(), this);
          }
          queryRenderedFeatures(e2, i2) {
            if (!this.style)
              return [];
            let o2;
            if (i2 !== void 0 || e2 === void 0 || e2 instanceof t.pointGeometry || Array.isArray(e2) || (i2 = e2, e2 = void 0), i2 = i2 || {}, (e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.pointGeometry || typeof e2[0] == "number")
              o2 = [t.pointGeometry.convert(e2)];
            else {
              let i3 = t.pointGeometry.convert(e2[0]), a2 = t.pointGeometry.convert(e2[1]);
              o2 = [i3, new t.pointGeometry(a2.x, i3.y), a2, new t.pointGeometry(i3.x, a2.y), i3];
            }
            return this.style.queryRenderedFeatures(o2, i2, this.transform);
          }
          querySourceFeatures(t2, e2) {
            return this.style.querySourceFeatures(t2, e2);
          }
          setStyle(e2, i2) {
            return (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i2)).diff !== !1 && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
          }
          setTransformRequest(t2) {
            return this._requestManager.setTransformRequest(t2), this;
          }
          _getUIString(t2) {
            let e2 = this._locale[t2];
            if (e2 == null)
              throw new Error(`Missing UI string '${t2}'`);
            return e2;
          }
          _updateStyle(t2, e2) {
            return this.style && (this.style.setEventedParent(null), this.style._remove()), t2 ? (this.style = new ee(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), typeof t2 == "string" ? this.style.loadURL(t2) : this.style.loadJSON(t2), this) : (delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new ee(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(e2, i2) {
            if (typeof e2 == "string") {
              let o2 = this._requestManager.transformRequest(e2, t.ResourceType.Style);
              t.getJSON(o2, (e3, o3) => {
                e3 ? this.fire(new t.ErrorEvent(e3)) : o3 && this._updateDiff(o3, i2);
              });
            } else
              typeof e2 == "object" && this._updateDiff(e2, i2);
          }
          _updateDiff(e2, i2) {
            try {
              this.style.setState(e2) && this._update(!0);
            } catch (o2) {
              t.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i2);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
          }
          addSource(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(!0);
          }
          isSourceLoaded(e2) {
            let i2 = this.style && this.style.sourceCaches[e2];
            if (i2 !== void 0)
              return i2.loaded();
            this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e2}'`)));
          }
          setTerrain(t2) {
            return this.style.setTerrain(t2), this;
          }
          getTerrain() {
            return this.style.terrain && this.style.terrain.options;
          }
          areTilesLoaded() {
            let t2 = this.style && this.style.sourceCaches;
            for (let e2 in t2) {
              let i2 = t2[e2]._tiles;
              for (let t3 in i2) {
                let e3 = i2[t3];
                if (e3.state !== "loaded" && e3.state !== "errored")
                  return !1;
              }
            }
            return !0;
          }
          addSourceType(t2, e2, i2) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e2, i2);
          }
          removeSource(t2) {
            return this.style.removeSource(t2), this._update(!0);
          }
          getSource(t2) {
            return this.style.getSource(t2);
          }
          addImage(e2, i2, { pixelRatio: o2 = 1, sdf: a2 = !1, stretchX: r2, stretchY: s2, content: n2 } = {}) {
            if (this._lazyInitEmptyStyle(), i2 instanceof HTMLImageElement || t.isImageBitmap(i2)) {
              let { width: l2, height: c2, data: h2 } = t.exported.getImageData(i2);
              this.style.addImage(e2, { data: new t.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: r2, stretchY: s2, content: n2, sdf: a2, version: 0 });
            } else {
              if (i2.width === void 0 || i2.height === void 0)
                return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                let { width: l2, height: c2, data: h2 } = i2, u2 = i2;
                this.style.addImage(e2, { data: new t.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2)), pixelRatio: o2, stretchX: r2, stretchY: s2, content: n2, sdf: a2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e2);
              }
            }
          }
          updateImage(e2, i2) {
            let o2 = this.style.getImage(e2);
            if (!o2)
              return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            let a2 = i2 instanceof HTMLImageElement || t.isImageBitmap(i2) ? t.exported.getImageData(i2) : i2, { width: r2, height: s2, data: n2 } = a2;
            if (r2 === void 0 || s2 === void 0)
              return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (r2 !== o2.data.width || s2 !== o2.data.height)
              return this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            let l2 = !(i2 instanceof HTMLImageElement || t.isImageBitmap(i2));
            o2.data.replace(n2, l2), this.style.updateImage(e2, o2);
          }
          hasImage(e2) {
            return e2 ? !!this.style.getImage(e2) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), !1);
          }
          removeImage(t2) {
            this.style.removeImage(t2);
          }
          loadImage(e2, i2) {
            t.getImage(this._requestManager.transformRequest(e2, t.ResourceType.Image), i2);
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(!0);
          }
          moveLayer(t2, e2) {
            return this.style.moveLayer(t2, e2), this._update(!0);
          }
          removeLayer(t2) {
            return this.style.removeLayer(t2), this._update(!0);
          }
          getLayer(t2) {
            return this.style.getLayer(t2);
          }
          setLayerZoomRange(t2, e2, i2) {
            return this.style.setLayerZoomRange(t2, e2, i2), this._update(!0);
          }
          setFilter(t2, e2, i2 = {}) {
            return this.style.setFilter(t2, e2, i2), this._update(!0);
          }
          getFilter(t2) {
            return this.style.getFilter(t2);
          }
          setPaintProperty(t2, e2, i2, o2 = {}) {
            return this.style.setPaintProperty(t2, e2, i2, o2), this._update(!0);
          }
          getPaintProperty(t2, e2) {
            return this.style.getPaintProperty(t2, e2);
          }
          setLayoutProperty(t2, e2, i2, o2 = {}) {
            return this.style.setLayoutProperty(t2, e2, i2, o2), this._update(!0);
          }
          getLayoutProperty(t2, e2) {
            return this.style.getLayoutProperty(t2, e2);
          }
          setLight(t2, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setFeatureState(t2, e2) {
            return this.style.setFeatureState(t2, e2), this._update();
          }
          removeFeatureState(t2, e2) {
            return this.style.removeFeatureState(t2, e2), this._update();
          }
          getFeatureState(t2) {
            return this.style.getFeatureState(t2);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t2 = 0, e2 = 0;
            return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
          }
          _setupContainer() {
            let t2 = this._container;
            t2.classList.add("maplibregl-map", "mapboxgl-map");
            let e2 = this._canvasContainer = r.create("div", "maplibregl-canvas-container mapboxgl-canvas-container", t2);
            this._interactive && e2.classList.add("maplibregl-interactive", "mapboxgl-interactive"), this._canvas = r.create("canvas", "maplibregl-canvas mapboxgl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            let i2 = this._containerDimensions();
            this._resizeCanvas(i2[0], i2[1], this.getPixelRatio());
            let o2 = this._controlContainer = r.create("div", "maplibregl-control-container mapboxgl-control-container", t2), a2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
              a2[t3] = r.create("div", `maplibregl-ctrl-${t3} mapboxgl-ctrl-${t3}`, o2);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _setupCooperativeGestures() {
            let t2 = this._container;
            this._metaPress = !1, this._cooperativeGesturesScreen = r.create("div", "maplibregl-cooperative-gesture-screen", t2);
            let e2 = "Control", i2 = typeof this._cooperativeGestures != "boolean" && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
            navigator.platform.indexOf("Mac") === 0 && (i2 = typeof this._cooperativeGestures != "boolean" && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use \u2318 + scroll to zoom the map", e2 = "Meta"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${i2}</div>
            <div class="maplibregl-mobile-message">${typeof this._cooperativeGestures != "boolean" && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, document.addEventListener("keydown", (t3) => {
              t3.key === e2 && (this._metaPress = !0);
            }), document.addEventListener("keyup", (t3) => {
              t3.key === e2 && (this._metaPress = !1);
            }), this._canvasContainer.addEventListener("wheel", (t3) => {
              this._onCooperativeGesture(t3, this._metaPress, 1);
            }, !1), this._canvasContainer.classList.remove("mapboxgl-touch-drag-pan", "maplibregl-touch-drag-pan");
          }
          _resizeCanvas(t2, e2, i2) {
            this._canvas.width = i2 * t2, this._canvas.height = i2 * e2, this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${e2}px`;
          }
          _setupPainter() {
            let i2 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), o2 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
            o2 ? (this.painter = new Ji(o2, this.transform), t.exported$1.testSupport(o2)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
          }
          _contextLost(e2) {
            e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e2 }));
          }
          _contextRestored(e2) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e2 }));
          }
          _onMapScroll(t2) {
            if (t2.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }
          _onCooperativeGesture(t2, e2, i2) {
            return !e2 && i2 < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
              this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
            }, 100)), !1;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(t2) {
            return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(t2) {
            return this._update(), this._renderTaskQueue.add(t2);
          }
          _cancelRenderFrame(t2) {
            this._renderTaskQueue.remove(t2);
          }
          _render(e2) {
            let i2, o2 = 0, a2 = this.painter.context.extTimerQuery;
            if (this.listens("gpu-timing-frame") && (i2 = a2.createQueryEXT(), a2.beginQueryEXT(a2.TIME_ELAPSED_EXT, i2), o2 = t.exported.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed)
              return;
            let r2 = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              let e3 = this.transform.zoom, i3 = t.exported.now();
              this.style.zoomHistory.update(e3, i3);
              let o3 = new t.EvaluationParameters(e3, { now: i3, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), a3 = o3.crossFadingFactor();
              a3 === 1 && a3 === this._crossFadingFactor || (r2 = !0, this._crossFadingFactor = a3), this.style.update(o3);
            }
            if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.style.terrain && this.style.terrain.sourceCache.update(this.transform, this.style.terrain), this.transform.updateElevation(this.style.terrain), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, t.PerformanceUtils.mark(t.PerformanceMarkers.load), this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || r2) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              let e3 = t.exported.now() - o2;
              a2.endQueryEXT(a2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                let o3 = a2.getQueryObjectEXT(i2, a2.QUERY_RESULT_EXT) / 1e6;
                a2.deleteQueryEXT(i2), this.fire(new t.Event("gpu-timing-frame", { cpuTime: e3, gpuTime: o3 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              let e3 = this.painter.collectGpuTimers();
              setTimeout(() => {
                let i3 = this.painter.queryGpuTimers(e3);
                this.fire(new t.Event("gpu-timing-layer", { layerTimes: i3 }));
              }, 50);
            }
            let s2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return s2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || s2 || (this._fullyLoaded = !0, t.PerformanceUtils.mark(t.PerformanceMarkers.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
          }
          remove() {
            this._hash && this._hash.remove();
            for (let t2 of this._controls)
              t2.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && (removeEventListener("resize", this._onWindowResize, !1), removeEventListener("orientationchange", this._onWindowResize, !1), removeEventListener("online", this._onWindowOnline, !1));
            let e2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e2 && e2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), r.remove(this._canvasContainer), r.remove(this._controlContainer), this._cooperativeGestures && r.remove(this._cooperativeGesturesScreen), this._container.classList.remove("maplibregl-map", "mapboxgl-map"), t.PerformanceUtils.clearMetrics(), this._removed = !0, this.fire(new t.Event("remove"));
          }
          triggerRepaint() {
            this.style && !this._frame && (this._frame = t.exported.frame((e2) => {
              t.PerformanceUtils.frame(e2), this._frame = null, this._render(e2);
            }));
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(t2) {
            this._trackResize && this.resize({ originalEvent: t2 })._update();
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t2) {
            this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t2) {
            this._showPadding !== t2 && (this._showPadding = t2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t2) {
            this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t2) {
            this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t2) {
            this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t2) {
            this._vertices = t2, this._update();
          }
          _setCacheLimits(e2, i2) {
            t.setCacheLimits(e2, i2);
          }
          get version() {
            return "2.4.0";
          }
        }, NavigationControl: class {
          constructor(e2) {
            this.options = t.extend({}, ra, e2), this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in", (t2) => this._map.zoomIn({}, { originalEvent: t2 })), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out", (t2) => this._map.zoomOut({}, { originalEvent: t2 })), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("maplibregl-ctrl-compass mapboxgl-ctrl-compass", (t2) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t2 }) : this._map.resetNorth({}, { originalEvent: t2 });
            }), this._compassIcon = r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            let t2 = this._map.getZoom(), e2 = t2 === this._map.getMaxZoom(), i2 = t2 === this._map.getMinZoom();
            this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
          }
          _rotateCompassArrow() {
            let t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t2;
          }
          onAdd(t2) {
            return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new sa(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            r.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(t2, e2) {
            let i2 = r.create("button", t2, this._container);
            return i2.type = "button", i2.addEventListener("click", e2), i2;
          }
          _setButtonTitle(t2, e2) {
            let i2 = this._map._getUIString(`NavigationControl.${e2}`);
            t2.title = i2, t2.setAttribute("aria-label", i2);
          }
        }, GeolocateControl: class extends t.Evented {
          constructor(e2) {
            super(), this.options = t.extend({}, ua, e2), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
          }
          onAdd(t2) {
            var e2;
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), e2 = this._setupUI, da !== void 0 ? e2(da) : window.navigator.permissions !== void 0 ? window.navigator.permissions.query({ name: "geolocation" }).then((t3) => {
              da = t3.state !== "denied", e2(da);
            }) : (da = !!window.navigator.geolocation, e2(da)), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ma = 0, _a = !1;
          }
          _isOutOfMapMaxBounds(t2) {
            let e2 = this._map.getMaxBounds(), i2 = t2.coords;
            return e2 && (i2.longitude < e2.getWest() || i2.longitude > e2.getEast() || i2.latitude < e2.getSouth() || i2.latitude > e2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _onSuccess(e2) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e2))
                return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e2)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = e2, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e2), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e2), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e2)), this._finish();
            }
          }
          _updateCamera(e2) {
            let i2 = new t.LngLat(e2.coords.longitude, e2.coords.latitude), o2 = e2.coords.accuracy, a2 = this._map.getBearing(), r2 = t.extend({ bearing: a2 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i2.toBounds(o2), r2, { geolocateSource: !0 });
          }
          _updateMarker(e2) {
            if (e2) {
              let i2 = new t.LngLat(e2.coords.longitude, e2.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            let t2 = this._map._container.clientHeight / 2, e2 = this._map.unproject([0, t2]), i2 = this._map.unproject([1, t2]), o2 = e2.distanceTo(i2), a2 = Math.ceil(2 * this._accuracy / o2);
            this._circleElement.style.width = `${a2}px`, this._circleElement.style.height = `${a2}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _onError(e2) {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (e2.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  let t2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e2.code === 3 && _a)
                    return;
                  this._setErrorState();
                }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e2)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(e2) {
            if (this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this._geolocateButton = r.create("button", "maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate", this._container), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", e2 === !1) {
              t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              let e3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = !0, this._geolocateButton.title = e3, this._geolocateButton.setAttribute("aria-label", e3);
            } else {
              let t2 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r.create("div", "maplibregl-user-location-dot mapboxgl-user-location-dot"), this._userLocationDotMarker = new ha(this._dotElement), this._circleElement = r.create("div", "maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ha({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (e3) => {
              e3.geolocateSource || this._watchState !== "ACTIVE_LOCK" || e3.originalEvent && e3.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this.fire(new t.Event("trackuserlocationend")));
            });
          }
          trigger() {
            if (!this._setup)
              return t.warnOnce("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  ma--, _a = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let t2;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ma++, ma > 1 ? (t2 = { maximumAge: 6e5, timeout: 0 }, _a = !0) : (t2 = this.options.positionOptions, _a = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
              }
            } else
              window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: ta, LogoControl: ea, ScaleControl: class {
          constructor(e2) {
            this.options = t.extend({}, pa, e2), t.bindAll(["_onMove", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _onMove() {
            fa(this._map, this._container, this.options);
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
          setUnit(t2) {
            this.options.unit = t2, fa(this._map, this._container, this.options);
          }
        }, FullscreenControl: class {
          constructor(e2) {
            this._fullscreen = !1, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(e2) {
            return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            r.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled);
          }
          _setupUI() {
            let t2 = this._fullscreenButton = r.create("button", "maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen", this._controlContainer);
            r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            let t2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen && window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, TerrainControl: class {
          constructor(e2) {
            this.options = e2, t.bindAll(["_toggleTerrain", "_updateTerrainIcon"], this);
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._terrainButton = r.create("button", "maplibregl-ctrl-terrain mapboxgl-ctrl-terrain", this._container), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
          _toggleTerrain() {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }
          _updateTerrainIcon() {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._map.style.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
          }
        }, Popup: class extends t.Evented {
          constructor(e2) {
            super(), this.options = t.extend(Object.create(xa), e2), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
          }
          addTo(e2) {
            return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            return this._content && r.remove(this._content), this._container && (r.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t.LngLat.convert(e2), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t2) {
            return this.setDOMContent(document.createTextNode(t2));
          }
          setHTML(t2) {
            let e2 = document.createDocumentFragment(), i2 = document.createElement("body"), o2;
            for (i2.innerHTML = t2; o2 = i2.firstChild, o2; )
              e2.appendChild(o2);
            return this.setDOMContent(e2);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(t2) {
            return this.options.maxWidth = t2, this._update(), this;
          }
          setDOMContent(t2) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else
              this._content = r.create("div", "maplibregl-popup-content mapboxgl-popup-content", this._container);
            return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(t2) {
            this._container && this._container.classList.add(t2);
          }
          removeClassName(t2) {
            this._container && this._container.classList.remove(t2);
          }
          setOffset(t2) {
            return this.options.offset = t2, this._update(), this;
          }
          toggleClassName(t2) {
            if (this._container)
              return this._container.classList.toggle(t2);
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = r.create("button", "maplibregl-popup-close-button mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _onMouseUp(t2) {
            this._update(t2.point);
          }
          _onMouseMove(t2) {
            this._update(t2.point);
          }
          _onDrag(t2) {
            this._update(t2.point);
          }
          _update(t2) {
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content || (this._container || (this._container = r.create("div", "maplibregl-popup mapboxgl-popup", this._map.getContainer()), this._tip = r.create("div", "maplibregl-popup-tip mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((t3) => this._container.classList.add(t3)), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = na(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t2))
              return;
            let e2 = this._pos = this._trackPointer && t2 ? t2 : this._map.project(this._lngLat), i2 = this.options.anchor, o2 = ya(this.options.offset);
            if (!i2) {
              let t3 = this._container.offsetWidth, a3 = this._container.offsetHeight, r2;
              r2 = e2.y + o2.bottom.y < a3 ? ["top"] : e2.y > this._map.transform.height - a3 ? ["bottom"] : [], e2.x < t3 / 2 ? r2.push("left") : e2.x > this._map.transform.width - t3 / 2 && r2.push("right"), i2 = r2.length === 0 ? "bottom" : r2.join("-");
            }
            let a2 = e2.add(o2[i2]).round();
            r.setTransform(this._container, `${la[i2]} translate(${a2.x}px,${a2.y}px)`), ca(this._container, i2, "popup");
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            let t2 = this._container.querySelector(va);
            t2 && t2.focus();
          }
          _onClose() {
            this.remove();
          }
        }, Marker: ha, Style: ee, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.pointGeometry, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, AJAXError: t.AJAXError, config: t.config, CanvasSource: P, GeoJSONSource: C, ImageSource: D, RasterDEMTileSource: I, RasterTileSource: T, VectorTileSource: w, VideoSource: z, prewarm: function() {
          j().acquire(G);
        }, clearPrewarmedResources: function() {
          let t2 = q;
          t2 && (t2.isPreloaded() && t2.numActive() === 1 ? (t2.release(G), q = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get version() {
          return "2.4.0";
        }, get workerCount() {
          return Z.workerCount;
        }, set workerCount(t2) {
          Z.workerCount = t2;
        }, get maxParallelImageRequests() {
          return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(e2) {
          t.config.MAX_PARALLEL_IMAGE_REQUESTS = e2;
        }, clearStorage(e2) {
          t.clearTileCache(e2);
        }, workerUrl: "", addProtocol(e2, i2) {
          t.config.REGISTERED_PROTOCOLS[e2] = i2;
        }, removeProtocol(e2) {
          delete t.config.REGISTERED_PROTOCOLS[e2];
        } };
        return Jo.extend(ba, { isSafari: t.isSafari, getPerformanceMetrics: t.PerformanceUtils.getPerformanceMetrics }), ba;
      });
      var maplibregl$1 = maplibregl2;
      return maplibregl$1;
    });
  }
});

// server.ts
var server_exports = {};
__export(server_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(server_exports);
var import_architect = require("@remix-run/architect");

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  assetsBuildDirectory: () => assetsBuildDirectory,
  entry: () => entry,
  future: () => future,
  publicPath: () => publicPath,
  routes: () => routes
});

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
var import_stream = require("stream"), import_node = require("@remix-run/node"), import_react = require("@remix-run/react"), import_isbot = __toESM(require("isbot")), import_server = require("react-dom/server"), import_jsx_runtime = require("react/jsx-runtime"), ABORT_DELAY = 5e3;
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  let callbackName = (0, import_isbot.default)(request.headers.get("user-agent")) ? "onAllReady" : "onShellReady";
  return new Promise((resolve, reject) => {
    let didError = !1, { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.RemixServer, { context: remixContext, url: request.url }),
      {
        [callbackName]: () => {
          let body = new import_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: didError ? 500 : responseStatusCode
            })
          ), pipe(body);
        },
        onShellError: (err) => {
          reject(err);
        },
        onError: (error) => {
          didError = !0, console.error(error);
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}

// app/root.tsx
var root_exports = {};
__export(root_exports, {
  default: () => App,
  links: () => links,
  meta: () => meta
});
var import_react6 = require("react"), import_react7 = require("@remix-run/react"), import_react_bootstrap3 = require("react-bootstrap");

// app/mapContext.ts
var import_react2 = require("react"), MapContext = (0, import_react2.createContext)({
  mapState: void 0,
  setMapState: (_) => {
    console.error("setMapState not implemented. Did you pass it to context?");
  },
  currentYearState: void 0,
  setCurrentYearState: (_) => {
    console.error("setCurrentYearState not implemented. Did you pass it to context?");
  }
});
MapContext.displayName = "MapContext";
var mapContext_default = MapContext;

// app/components/BaseMap.tsx
var import_maplibre_gl = __toESM(require_maplibre_gl()), import_react3 = require("react");

// app/components/lngLatContext.ts
var lngLatContext = (lngLat, popup) => {
  console.log("\u{1F680} ~ file: lngLatContext.ts:2 ~ lngLatContext ~ lngLat, popup:", lngLat, popup);
  let { lat, lng } = lngLat, button = document.createElement("button");
  return button.classList.add("btn", "btn-outline-primary"), button.addEventListener("click", () => toClipBoard(`${lat}, ${lng}`, popup)), button.innerText = `${lat}, ${lng}`, button.setAttribute("type", "button"), button.setAttribute("title", "Click to copy coordinates to your clipboard."), console.log("\u{1F680} ~ file: lngLatContext.ts:12 ~ lngLatContext ~ button:", button), button;
}, alertDiv = () => {
  let alertContainer = document.createElement("div");
  return alertContainer.classList.add("alert", "alert-success", "position-absolute", "bottom-0", "start-50", "translate-middle-x"), alertContainer.style.zIndex = 999999, alertContainer.innerText = "Coordinates copied to clipboard!", alertContainer;
}, toClipBoard = async (str, popup) => {
  popup.remove(), await navigator.clipboard.writeText(str);
  let clipboardAlert = alertDiv();
  document.getElementById("root").append(clipboardAlert), await new Promise((resolve) => setTimeout(resolve, 3e3)), clipboardAlert.remove();
}, lngLatContext_default = lngLatContext;

// app/components/BaseMap.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
function BaseMap() {
  let { mapState, setMapState, center } = (0, import_react3.useContext)(mapContext_default), mapContainerRef = (0, import_react3.useRef)();
  return (0, import_react3.useEffect)(() => {
    let map;
    if (!mapState && mapContainerRef.current) {
      map = new import_maplibre_gl.default.Map({
        container: "map",
        center,
        zoom: 16,
        style: {
          version: 8,
          sources: {
            modernTerrain: {
              type: "raster",
              tiles: [
                "https://api.mapbox.com/styles/v1/jayvarner/ck9n8d4rj02bh1iom9elzka33/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiamF5dmFybmVyIiwiYSI6ImVkYjliN2Y3ZDZlYzEyNzg5NDhiMGU4MWRiZTY3Mzk3In0.U4Sc4HVk2F4MkKyd7ybgXw&fresh=true"
              ],
              tileSize: 256,
              maxzoom: 19
            }
          },
          layers: [
            {
              id: "modernTerrain",
              type: "raster",
              source: "modernTerrain"
            }
          ]
        }
      });
      let nav = new import_maplibre_gl.default.NavigationControl({ visualizePitch: !0 });
      map.addControl(nav, "top-left"), setMapState(map), map.on("contextmenu", ({ lngLat }) => {
        console.log("\u{1F680} ~ file: BaseMap.tsx:50 ~ map.on ~ lngLat:", lngLat);
        let popup = new import_maplibre_gl.default.Popup();
        popup.setLngLat(lngLat), popup.setDOMContent(lngLatContext_default(lngLat, popup)), popup.addTo(map);
      });
    }
    return () => {
      map.remove(), setMapState(void 0);
    };
  }, [setMapState, mapContainerRef]), /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { ref: mapContainerRef, id: "map" });
}

// app/styles/app.css
var app_default = "/_static/build/_assets/app-WGLPCIAZ.css";

// app/components/MainNav.tsx
var import_Navbar = __toESM(require("react-bootstrap/Navbar")), import_NavDropdown = __toESM(require("react-bootstrap/NavDropdown")), import_Nav = __toESM(require("react-bootstrap/Nav")), import_Container = __toESM(require("react-bootstrap/Container")), import_react_router_bootstrap = require("react-router-bootstrap"), import_jsx_runtime3 = require("react/jsx-runtime");
function MainNav() {
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_Navbar.default, { bg: "primary", expand: "lg", className: "nav", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_Container.default, { fluid: !0, children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react_router_bootstrap.LinkContainer, { to: "/", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_Navbar.default.Brand, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "img",
        {
          src: "/images/logo192.png",
          width: "40px",
          height: "40px",
          alt: "",
          role: "presentation",
          className: "mx-lg-3"
        }
      ),
      "Open World Atlanta"
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_Navbar.default.Toggle, { "aria-controls": "main-nav" }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_Navbar.default.Collapse, { id: "main-nav", className: "pb-1", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_Nav.default, { className: "me-auto", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_NavDropdown.default, { title: "Buildings", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react_router_bootstrap.LinkContainer, { to: "/buildings/1928", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_NavDropdown.default.Item, { children: "1928" }) }) }) }) })
  ] }) });
}

// app/components/TileLayers.tsx
var import_react5 = require("react"), import_react_bootstrap2 = require("react-bootstrap"), import_react_fontawesome2 = require("@fortawesome/react-fontawesome"), import_free_solid_svg_icons2 = require("@fortawesome/free-solid-svg-icons");

// app/data/tileLayers.ts
var geoserverUrl = (workspace, layer) => ({
  type: "raster",
  tiles: [
    `https://geoserver.ecds.emory.edu/${workspace}/gwc/service/wms?layers=${workspace}:${layer}&service=WMS&request=GetMap&layers=&styles=&format=image/png&transparent=true&version=1.1.1&width=256&height=256&srs=EPSG:3857&bbox={bbox-epsg-3857}`
  ],
  tileSize: 256
}), defaultPaintOptions = {
  "raster-opacity": 0,
  "raster-opacity-transition": {
    duration: 700,
    delay: 0
  }
}, tileLayers = [
  {
    year: 1840,
    title: "1853 City Atlas",
    description: 'Originally produced in 1853 for the City Council by civil engineer Edward Vincent. Includes index and circle marking the extended city limits. "These numbers are city numbers, and deeds refer to them--whether subdivisions or not. N.B. The City Line has been extended."',
    researchLinks: [
      "https://scholarblogs.emory.edu/woodruff/news/explore-marbls-digital-historic-map-collection",
      "http://www.digitalgallery.emory.edu/luna/servlet/detail/EMORYUL~3~3~1000~100068:Old-Map-of-Atlanta?sort=Publication_Title%2CTitle%2CPage_No_%2CPages&qvq=sort:Publication_Title%2CTitle%2CPage_No_%2CPages;lc:EMORYUL%7E3%7E3&mi=0&trs=24",
      "https://muse.jhu.edu/article/430839/pdf",
      "https://en.wikipedia.org/wiki/Edward_A._Vincent",
      "https://www.loc.gov/resource/g3924a.ct001134/"
    ],
    source: geoserverUrl("Atlanta1878", "q516x4"),
    layer: {
      id: "atl1840",
      type: "raster",
      source: "atl1840",
      paint: defaultPaintOptions
    }
  },
  {
    year: 1870,
    title: "1870 City Map",
    description: "The Hanlieter's Directory Map was published as part of the 1870 Atlanta City Directory. William R. Hanleiter of 1 South Broad Street was the publisher and the directory sold for two dollars. The document was a full alphabetical record of names of persons, firms, companies, orders, and associations in Atlanta and the West End.",
    researchLinks: [
      "https://dlg.usg.edu/record/gsu_afpl_26?canvas=0&x=1948&y=2577&w=5795",
      "https://archive.org/details/emory1870/page/n1/mode/2up"
    ],
    source: geoserverUrl("ATLMaps", "2rwkdcdv"),
    layer: {
      id: "atl1870",
      type: "raster",
      source: "atl1870",
      paint: defaultPaintOptions
    }
  },
  {
    year: 1895,
    title: "1895 City Map",
    source: geoserverUrl("ATLMaps", "2s4d022m"),
    layer: {
      id: "atl1895",
      type: "raster",
      source: "atl1895",
      paint: defaultPaintOptions
    }
  },
  {
    year: 1906,
    title: "1906 City Map",
    source: geoserverUrl("ATLMaps", "2s6zg3zx"),
    layer: {
      id: "atl1906",
      type: "raster",
      source: "atl1906",
      paint: defaultPaintOptions
    }
  },
  {
    year: 1911,
    title: "1911 Street Map",
    source: geoserverUrl("ATLMaps", "sq4pd"),
    layer: {
      id: "atl1911",
      type: "raster",
      source: "atl1911",
      paint: defaultPaintOptions
    }
  },
  {
    year: 1928,
    title: "1928 Atlas",
    source: geoserverUrl("ATLMaps", "ATL28"),
    layer: {
      id: "atl1928",
      type: "raster",
      source: "atl1928",
      paint: defaultPaintOptions
    }
  },
  {
    year: 1934,
    title: "1934 Street Map",
    source: geoserverUrl("ATLMaps", "2s3w9vfd"),
    layer: {
      id: "atl1934",
      type: "raster",
      source: "atl1934",
      paint: defaultPaintOptions
    }
  },
  {
    year: 2023,
    title: "Modern Street Map",
    source: {
      type: "raster",
      tileSize: 256,
      tiles: [
        "https://basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png"
      ]
    },
    layer: {
      id: "modernStreet",
      type: "raster",
      source: "modernStreet",
      paint: defaultPaintOptions
    }
  },
  {
    year: 2023,
    title: "Modern Satellite Image",
    source: {
      type: "raster",
      tileSize: 256,
      tiles: [
        "https://api.mapbox.com/styles/v1/jayvarner/clfl9e5bl002d01nuiuh6onc3/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiamF5dmFybmVyIiwiYSI6ImVkYjliN2Y3ZDZlYzEyNzg5NDhiMGU4MWRiZTY3Mzk3In0.U4Sc4HVk2F4MkKyd7ybgXw"
      ]
    },
    layer: {
      id: "modernSatellite",
      type: "raster",
      source: "modernSatellite",
      paint: defaultPaintOptions
    }
  }
];

// app/components/OpacityControl.tsx
var import_react4 = require("react");
var import_react_fontawesome = require("@fortawesome/react-fontawesome"), import_free_solid_svg_icons = require("@fortawesome/free-solid-svg-icons"), import_free_regular_svg_icons = require("@fortawesome/free-regular-svg-icons"), import_react_bootstrap = require("react-bootstrap"), import_jsx_runtime4 = require("react/jsx-runtime");
function OpacityControl({ layer }) {
  let { mapState, currentYearState } = (0, import_react4.useContext)(mapContext_default), [opacityState, setOpacityState] = (0, import_react4.useState)(0);
  return (0, import_react4.useEffect)(() => {
    setOpacityState(currentYearState === layer.year ? 1 : 0);
  }, [setOpacityState, currentYearState, layer]), (0, import_react4.useEffect)(() => {
    mapState != null && mapState.getLayer(layer.layer.id) && (mapState == null || mapState.setPaintProperty(
      layer.layer.id,
      "raster-opacity",
      parseFloat(opacityState)
    ));
  }, [opacityState, layer.layer.id, mapState]), /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_react_bootstrap.Row, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_react_bootstrap.Col, { className: "fs-6 mt-1", sm: 1, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      "span",
      {
        role: "button",
        tabIndex: 0,
        "aria-label": `Toggle opacity for tile layer ${layer.title}`,
        onClick: () => setOpacityState(opacityState > 0 ? 0 : 1),
        onKeyDown: () => setOpacityState(opacityState > 0 ? 0 : 1),
        children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          import_react_fontawesome.FontAwesomeIcon,
          {
            icon: opacityState === 0 ? import_free_regular_svg_icons.faSun : import_free_solid_svg_icons.faSun,
            style: { opacity: opacityState === 0 ? 1 : opacityState + 0.2 }
          }
        )
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_react_bootstrap.Col, { className: "mt-1", sm: 7, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      "input",
      {
        type: "range",
        className: "form-range",
        min: "0",
        max: "1",
        step: ".05",
        "aria-label": `Set opacity for base layer ${layer.title ?? ""}`,
        value: opacityState,
        onChange: ({ target }) => setOpacityState(target.value)
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_react_bootstrap.Col, { sm: 4, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "input-group input-group-sm", children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
        "input",
        {
          type: "number",
          className: "form-control form-control-sm pe-0",
          min: "0",
          max: "100",
          step: "5",
          "aria-label": `Set opacity for base layer ${layer.title}`,
          value: opacityState / 0.01,
          onChange: ({ target }) => setOpacityState(target.value * 0.01)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "input-group-text", children: "%" })
    ] }) })
  ] });
}

// app/components/TileLayers.tsx
var import_jsx_runtime5 = require("react/jsx-runtime");
function TileLayers() {
  let { mapState, currentYearState } = (0, import_react5.useContext)(mapContext_default);
  return (0, import_react5.useEffect)(() => {
    for (let tileLayer of tileLayers)
      mapState == null || mapState.addSource(tileLayer.layer.id, tileLayer.source), mapState == null || mapState.addLayer(tileLayer.layer), console.log("\u{1F680} ~ file: TileLayers.tsx:15 ~ useEffect ~ tileLayer.layer.id:", tileLayer.layer.id);
    return () => {
      for (let tileLayer of tileLayers)
        mapState == null || mapState.removeLayer(tileLayer.layer.id), mapState == null || mapState.removeSource(tileLayer.layer.id);
    };
  }, [mapState, currentYearState]), /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.ToastContainer, { position: "bottom-start", className: "ms-2 mb-2 overflow-hidden", tabIndex: 0, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Toast, { show: !0, className: "overflow-auto", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Accordion, { defaultActiveKey: 0, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_react_bootstrap2.Accordion.Item, { eventKey: 0, children: [
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Accordion.Header, { children: "Base Layers" }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Accordion.Body, { className: "base-layer-control", children: tileLayers.map((layer, index) => /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_react_bootstrap2.Container, { fluid: !0, children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Row, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Col, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("span", { className: "fs-5", children: [
        layer.title,
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          import_react_bootstrap2.OverlayTrigger,
          {
            trigger: ["focus"],
            placement: "right",
            overlay: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_react_bootstrap2.Popover, { style: { zIndex: 1090 }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Popover.Header, { as: "h3", children: layer.title }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Popover.Body, { children: layer.description })
            ] }),
            children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_fontawesome2.FontAwesomeIcon, { className: "fs-6 text-muted ms-2", icon: import_free_solid_svg_icons2.faInfoCircle, role: "button", tabIndex: 0 })
          }
        )
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(OpacityControl, { layer }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Row, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_bootstrap2.Col, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("hr", {}) }) })
    ] }, index)) })
  ] }) }) }) });
}

// app/root.tsx
var import_jsx_runtime6 = require("react/jsx-runtime"), meta = () => ({
  charset: "utf-8",
  title: "New Remix App",
  viewport: "width=device-width,initial-scale=1"
});
function links() {
  return [
    { rel: "stylesheet", href: app_default }
  ];
}
function App() {
  let [mapState, setMapState] = (0, import_react6.useState)(void 0), [currentYearState, setCurrentYearState] = (0, import_react6.useState)(void 0), center = [-84.3891, 33.7528];
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("html", { lang: "en", children: [
    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react7.Meta, {}),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react7.Links, {})
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("body", { id: "root", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react_bootstrap3.SSRProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
      mapContext_default.Provider,
      {
        value: {
          mapState,
          setMapState,
          currentYearState,
          setCurrentYearState,
          center
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(MainNav, {}),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(BaseMap, {}),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(TileLayers, {}),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react7.Outlet, {}),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react7.ScrollRestoration, {}),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react7.Scripts, {}),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react7.LiveReload, {})
        ]
      }
    ) }) })
  ] });
}

// app/routes/buildings.$year.tsx
var buildings_year_exports = {};
__export(buildings_year_exports, {
  default: () => Buildings,
  loader: () => loader
});
var import_react11 = require("@remix-run/react"), import_react12 = require("react"), import_react_bootstrap7 = require("react-bootstrap");

// app/buildingMetadata.ts
var omekaURL = "https://dvl.ecdsdev.org/api", omekaKey = "23bd7efbce6d7e1ceeee3265cddf6060543f0459", uses = (use) => {
  switch (use) {
    case "M":
      return "Manufacturing/Industrial";
    case "C":
      return "Commercial/Office";
    case "P":
      return "Public/Institutional";
    case "R":
      return "Residential";
    case "TU":
      return "Transportation/Utility";
    case "TR":
      return "Residential Transient";
    case "W":
      return "Warehouse";
    default:
      return use;
  }
}, omekaImages = async (omekaId) => (await (await fetch(`${omekaURL}/files?item=${omekaId}&key=${omekaKey}`)).json()).map((image) => ({
  thumb: image.file_urls.thumbnail,
  full: image.file_urls.original,
  caption: image.original_filename
})), omekaMetadata = async () => {
  let reasonableJSON = await (await (await fetch(`${omekaURL}/items?collection=16&key=${omekaKey}&per_page=1000`)).json()).map(async (building) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    return {
      omekaID: building.id,
      fileCount: building.files.count,
      bldgID: building.element_texts.find((el) => el.element.id === 43).text,
      title: (_a = building.element_texts.find((el) => el.element.id === 50)) == null ? void 0 : _a.text,
      address: (_b = building.element_texts.find((el) => el.element.id === 53)) == null ? void 0 : _b.text,
      description: (_c = building.element_texts.find((el) => el.element.id === 41)) == null ? void 0 : _c.text,
      metadata: {
        landUse: uses((_d = building.element_texts.find((el) => el.element.id === 49)) == null ? void 0 : _d.text),
        date: (_e = building.element_texts.find((el) => el.element.id === 69)) == null ? void 0 : _e.text,
        architect: (_f = building.element_texts.find((el) => el.element.id === 76)) == null ? void 0 : _f.text,
        type: (_g = building.element_texts.find((el) => el.element.id === 55)) == null ? void 0 : _g.text,
        businesses: (_h = building.element_texts.find((el) => el.element.id === 72)) == null ? void 0 : _h.text,
        residents: (_i = building.element_texts.find((el) => el.element.id === 58)) == null ? void 0 : _i.text,
        race: (_j = building.element_texts.find((el) => el.element.id === 59)) == null ? void 0 : _j.text,
        removed: (_k = building.element_texts.find((el) => el.element.id === 63)) == null ? void 0 : _k.text
      },
      landUse: building.element_texts.find((el) => el.element.id === 49).text[0],
      location: building.element_texts.find((el) => el.element.id === 4).text.split(", ").map((c) => parseFloat(c)),
      images: []
    };
  });
  return await Promise.all(reasonableJSON);
}, shapeFileMetadata = (building) => ({
  omekaID: building.Omeka,
  fileCount: 0,
  bldgID: building.Identifier,
  title: building.Title,
  address: building.Address,
  description: building.Description,
  metadata: {
    landUse: uses(building.Land_Use),
    date: building.Date_BD,
    type: building.Bldg_Type,
    businesses: building.Occupants_,
    residents: building.Occupants1,
    race: building.Race,
    removed: building.Bldg_Remov
  },
  landUse: uses(building.Land_Use),
  Land_Use: building.Land_Use,
  location: [building.X_Coord, building.Y_Coord],
  images: []
});

// app/data/buildings.ts
var buildings = {
  1928: {
    source: {
      type: "vector",
      scheme: "tms",
      tiles: [
        "https://geoserver.ecds.emory.edu/gwc/service/tms/1.0.0/ATLMaps:OWAbuildings07OCT22@EPSG:900913@pbf/{z}/{x}/{y}.pbf"
      ],
      promoteId: "Identifier"
    },
    layer: {
      id: "buildings1928",
      type: "fill-extrusion",
      source: "buildings1928",
      "source-layer": "OWAbuildings07OCT22",
      paint: {
        "fill-extrusion-color": [
          "case",
          ["boolean", ["feature-state", "clicked"], !1],
          "deeppink",
          ["==", ["get", "Land_Use"], "M"],
          "#AB59C9",
          ["==", ["get", "Land_Use"], "C"],
          "#E83333",
          ["==", ["get", "Land_Use"], "P"],
          "#2E6DFF",
          ["==", ["get", "Land_Use"], "R"],
          "#FFFF00",
          ["==", ["get", "Land_Use"], "TU"],
          "#FFCCFF",
          ["==", ["get", "Land_Use"], "TR"],
          "#FF6F00",
          ["==", ["get", "Land_Use"], "W"],
          "#5D4037",
          "#EBEBEB"
        ],
        "fill-extrusion-height": ["*", ["get", "calc_ht"], 0.3048],
        "fill-extrusion-opacity": 0.6
      }
    }
  }
}, buildingUses = [
  {
    label: "Residential",
    color: "#FFFF00",
    code: "R"
  },
  {
    label: "Residential Transient",
    color: "#FF6F00",
    code: "TR"
  },
  {
    label: "Commercial/Office",
    color: "#E83333",
    code: "C"
  },
  {
    label: "Warehouse",
    color: "#5D4037",
    code: "W"
  },
  {
    label: "Manufacturing/Industrial",
    color: "#AB59C9",
    code: "M"
  },
  {
    label: "Public/Institutional",
    color: "#2E6DFF",
    code: "P"
  },
  {
    label: "Transportation/Utility",
    color: "#FFCCFF",
    code: "TU"
  }
];

// app/utils.ts
var camelToTitle = (string) => string.replace(/([A-Z])/g, (match) => ` ${match}`).replace(/^./, (match) => match.toUpperCase()).replace(/_/g, "").trim();

// app/components/Images.tsx
var import_react8 = require("react"), import_react_bootstrap4 = require("react-bootstrap"), import_jsx_runtime7 = require("react/jsx-runtime");
function Images({ images }) {
  let [show, setShow] = (0, import_react8.useState)(!1);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react_bootstrap4.Carousel, { className: "my-3", interval: null, children: images.map((image, index) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_react_bootstrap4.Carousel.Item, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      "img",
      {
        src: image.full,
        alt: image.caption,
        className: "d-block w-100 owa-image-button",
        onClick: () => setShow(!0),
        role: "button"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_react_bootstrap4.Modal, { size: "lg", show, onHide: () => setShow(!1), children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react_bootstrap4.Modal.Header, { closeButton: !0 }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react_bootstrap4.Modal.Body, { className: "mx-auto", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("img", { className: "img-fluid", src: image.full, alt: image.caption }) }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react_bootstrap4.Modal.Footer, { children: image.caption })
    ] })
  ] }, index)) });
}

// app/components/BuildingLgend.tsx
var import_react9 = require("react");
var import_chroma_js = __toESM(require("chroma-js")), import_react_bootstrap5 = require("react-bootstrap");
var import_jsx_runtime8 = require("react/jsx-runtime"), outlineStyle = (color) => ({
  backgroundColor: (0, import_chroma_js.default)(color).alpha(0.3),
  borderColor: color,
  color: "black"
}), colorStyle = (color) => ({
  backgroundColor: color,
  borderColor: "#888",
  borderStyle: "solid",
  color: import_chroma_js.default.contrast(color, "white") > 4 ? "white" : "black"
}), BuildingLegend = ({ open, toggle }) => {
  let { mapState } = (0, import_react9.useContext)(mapContext_default), [currentFilter, setCurrentFilter] = (0, import_react9.useState)(void 0), filterByUse = (useCode) => {
    useCode ? mapState.setFilter("buildings1928", ["==", ["get", "Land_Use"], useCode]) : mapState == null || mapState.setFilter("buildings1928", void 0), setCurrentFilter(useCode);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    import_react_bootstrap5.Accordion,
    {
      activeKey: open,
      onSelect: (eventKey) => {
        toggle(eventKey);
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_react_bootstrap5.Accordion.Item, { eventKey: 1, children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_react_bootstrap5.Accordion.Header, { children: "Building Color Key" }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_react_bootstrap5.Accordion.Body, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_react_bootstrap5.ButtonGroup, { vertical: !0, className: "d-grid col-12", style: { justifyContent: "unset" }, children: [
          buildingUses.map((use, index) => currentFilter === use.code ? /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            import_react_bootstrap5.Button,
            {
              style: colorStyle(use.color),
              size: "lg",
              children: use.label
            },
            index
          ) : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            import_react_bootstrap5.Button,
            {
              style: currentFilter ? outlineStyle(use.color) : colorStyle(use.color),
              size: "lg",
              onClick: () => filterByUse(use.code),
              children: use.label
            },
            index
          )),
          currentFilter && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_react_bootstrap5.Button, { size: "lg", variant: "secondary", onClick: () => filterByUse(void 0), children: "All Buildings" })
        ] }) })
      ] })
    }
  );
}, BuildingLgend_default = BuildingLegend;

// app/components/ToggleButton.tsx
var import_react10 = require("react"), import_react_bootstrap6 = require("react-bootstrap"), import_jsx_runtime9 = require("react/jsx-runtime"), ToggleButton = ({ toggle, children }) => {
  let toggleRef = (0, import_react10.useRef)();
  return (0, import_react10.useEffect)(() => {
    var _a;
    (_a = toggleRef.current) == null || _a.focus();
  }, [toggleRef]), /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    import_react_bootstrap6.Button,
    {
      ref: toggleRef,
      onClick: () => toggle(!0),
      className: "position-absolute top-50 end-0 me-5 shadow-lg",
      children
    }
  );
}, ToggleButton_default = ToggleButton;

// app/routes/buildings.$year.tsx
var import_jsx_runtime10 = require("react/jsx-runtime"), loader = async ({ params }) => {
  let buildingMetaData = await omekaMetadata();
  return { year: params.year, buildingMetaData, ...buildings[params.year] };
};
function Buildings() {
  let { year, source, buildingMetaData, layer } = (0, import_react11.useLoaderData)(), { mapState, setCurrentYearState, center } = (0, import_react12.useContext)(mapContext_default), [showDetails, setShowDetails] = (0, import_react12.useState)(!0), [showLegend, setShowLegend] = (0, import_react12.useState)(1), [selectedBuilding, setSelectedBuilding] = (0, import_react12.useState)(void 0), location = (0, import_react11.useLocation)();
  return (0, import_react12.useEffect)(() => {
    mapState == null || mapState.flyTo({
      bearing: 0,
      center,
      pitch: 60,
      zoom: 15
    });
  }, [location, center, mapState]), (0, import_react12.useEffect)(() => (setCurrentYearState(parseInt(year)), () => {
    setCurrentYearState(void 0);
  }), [year, setCurrentYearState]), (0, import_react12.useEffect)(() => {
    let layerId = layer.id, clicked;
    mapState == null || mapState.addSource(layerId, source), mapState == null || mapState.addLayer(layer), mapState == null || mapState.once("idle", () => {
      mapState.getLayer(layerId) && mapState.moveLayer(layerId);
    });
    let getBuilding = async (properties) => {
      clicked && mapState.setFeatureState(
        { source: layerId, sourceLayer: layer["source-layer"], id: clicked },
        { clicked: !1 }
      ), mapState.setFeatureState(
        { source: layerId, sourceLayer: layer["source-layer"], id: properties.Identifier },
        { clicked: !0 }
      ), clicked = properties.Identifier;
      let omekaBuilding = await buildingMetaData.find((bldg) => bldg.bldgID === properties.Identifier);
      omekaBuilding ? (omekaBuilding.fileCount > 0 && omekaBuilding.images.length === 0 && (omekaBuilding.images = await omekaImages(omekaBuilding.omekaID)), setSelectedBuilding(omekaBuilding)) : setSelectedBuilding(shapeFileMetadata(properties));
    };
    return mapState == null || mapState.on("click", layerId, ({ features }) => {
      getBuilding(features[0].properties), setShowLegend(0);
    }), mapState == null || mapState.on("mouseenter", layerId, () => {
      mapState.getCanvas().style.cursor = "pointer";
    }), mapState == null || mapState.on("mouseleave", layerId, () => {
      mapState.getCanvas().style.cursor = "";
    }), () => {
      mapState == null || mapState.removeLayer(layerId), mapState == null || mapState.removeSource(layerId);
    };
  }, [mapState, source, layer, buildingMetaData, setSelectedBuilding]), /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("section", { children: [
    !showDetails && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ToggleButton_default, { toggle: setShowDetails, children: "Show building details" }),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(import_react_bootstrap7.Offcanvas, { show: showDetails, placement: "end", scroll: !0, backdrop: !1, onHide: () => setShowDetails(!1), children: [
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_react_bootstrap7.Offcanvas.Header, { closeButton: !0, onHide: () => setShowDetails(!1), children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("h4", { children: [
        "Buildings ",
        year
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_react_bootstrap7.Offcanvas.Body, { className: "pt-0", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("article", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("section", { className: "sticky-top", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(BuildingLgend_default, { open: showLegend, toggle: setShowLegend }) }),
        selectedBuilding && /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
          selectedBuilding.images.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("section", { className: "sticky-top", style: { top: "56px" }, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Images, { images: selectedBuilding.images }) }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("section", { className: "position-relative", children: [
            /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("h5", { children: selectedBuilding.title }),
            /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("p", { className: "lead", children: selectedBuilding.description }),
            Object.keys(selectedBuilding.metadata).map((key, index) => selectedBuilding.metadata[key] ? /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(import_react_bootstrap7.Row, { as: "dl", children: [
              /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_react_bootstrap7.Col, { className: "text-truncate", sm: 12, as: "dt", children: camelToTitle(key) }),
              /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_react_bootstrap7.Col, { as: "dd", sm: 12, children: selectedBuilding.metadata[key] })
            ] }, index) : /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", {}, index))
          ] })
        ] })
      ] }) })
    ] })
  ] });
}

// app/routes/index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index
});
var import_jsx_runtime11 = require("react/jsx-runtime");
function Index() {
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", {});
}

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { version: "f3fc89ee", entry: { module: "/_static/build/entry.client-JJGISC77.js", imports: ["/_static/build/_shared/chunk-W337WKPO.js", "/_static/build/_shared/chunk-BHXIG2AN.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/_static/build/root-MUMF7INW.js", imports: ["/_static/build/_shared/chunk-EZTW72HS.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, routes: { id: "routes", parentId: "root", path: void 0, index: void 0, caseSensitive: void 0, module: "/_static/build/routes-QJBWLW6N.js", imports: void 0, hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/buildings.$year": { id: "routes/buildings.$year", parentId: "root", path: "buildings/:year", index: void 0, caseSensitive: void 0, module: "/_static/build/routes/buildings.$year-YYUZ6EAJ.js", imports: void 0, hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 } }, cssBundleHref: void 0, hmr: void 0, url: "/_static/build/manifest-F3FC89EE.js" };

// server-entry-module:@remix-run/dev/server-build
var assetsBuildDirectory = "public/build", future = { unstable_cssModules: !1, unstable_cssSideEffectImports: !1, unstable_dev: !1, unstable_postcss: !1, unstable_tailwind: !1, unstable_vanillaExtract: !1, v2_errorBoundary: !1, v2_meta: !1, v2_routeConvention: !0 }, publicPath = "/_static/build/", entry = { module: entry_server_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/buildings.$year": {
    id: "routes/buildings.$year",
    parentId: "root",
    path: "buildings/:year",
    index: void 0,
    caseSensitive: void 0,
    module: buildings_year_exports
  },
  routes: {
    id: "routes",
    parentId: "root",
    path: void 0,
    index: void 0,
    caseSensitive: void 0,
    module: routes_exports
  }
};

// server.ts
var handler = (0, import_architect.createRequestHandler)({
  build: server_build_exports,
  mode: "production"
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
